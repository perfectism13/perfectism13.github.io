<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CNN</title>
    <url>/2020/07/24/CNN/</url>
    <content><![CDATA[<h1 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h1><p>Convolutional Neural Networks</p>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><h3 id="卷积层（Convolutional-layer"><a href="#卷积层（Convolutional-layer" class="headerlink" title="卷积层（Convolutional layer)"></a>卷积层（Convolutional layer)</h3><p><strong>作用：</strong>对输入的数据进行<strong>特征提取</strong>，可对应多个卷积核，一般来说经过卷积层后，尺寸变小，厚度变厚，越往后面感受野变大，既降尺寸，又降厚度，参数需要学习</p>
<p>卷积核和图像一样有通道数，卷积核滑动步长（stride），每个卷积核对应一个局部特征（梯度特征）</p>
<p>为了让输入图像的全部像素都能被滑动窗口捕获，使用same方式在输入图像最外层加上指定层数（padding）全为0的像素边界，使用valid方式不做像素填充。经过卷积后输出图像的宽度与高度参数如下：</p>
<p> Woutput =Winput −Wfilter +2PS+1Houtput =Hintput−Hfilter +2PS+1 Woutput =Winput −Wfilter +2PS+1Houtput =Hintput−Hfilter +2PS+1</p>
<p>多通道卷积操作：卷积核变为$ kernelsize<em>kernelsize</em>c $单独通道卷积后求和+偏置,如下图：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/j8kLBKs.gif" alt="img"></p>
<h3 id="池化层-Pooling-layer"><a href="#池化层-Pooling-layer" class="headerlink" title="池化层(Pooling layer)"></a>池化层(Pooling layer)</h3><p><strong>作用：**</strong>一种提取输入数据核心特征的方式，特征融合、降维压缩原始数据**，减少参与模型计算的参数，不降通道数，只降图片尺寸，参数不需要学习</p>
<p>常用方法：平均池化、最大池化</p>
<p>WoutputHoutput=Winput−WfilterS+1=Hinput−HfilterS+1Woutput=Winput−WfilterS+1Houtput=Hinput−HfilterS+1</p>
<h3 id="全连接层-Fully-Connected-layer"><a href="#全连接层-Fully-Connected-layer" class="headerlink" title="全连接层(Fully-Connected layer)"></a>全连接层(Fully-Connected layer)</h3><p><strong>作用：推理器、分类器</strong>，将前两层的输出给到一个完全连接前馈网络，经激活函数处理，便可以得到分类预测的结果，全局感受野，直接去除空间信息，需要学习参数，等效于全局卷积（1x1卷积）</p>
<p>下图是一张28x28的图片经3x3的卷积核（最外层加一层0、步长为1）的卷积层，2x2的步长为2的最大池化层、再经过一个全连接层的结果。</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/img.png" alt="img"></p>
<h3 id="Softmax层-批量归一化层-Batch-Normalization-layer"><a href="#Softmax层-批量归一化层-Batch-Normalization-layer" class="headerlink" title="Softmax层(批量归一化层-Batch Normalization layer)"></a>Softmax层(批量归一化层-Batch Normalization layer)</h3><p>指数归一化函数</p>
<p>σ(z)j=ezj∑Kk=1ezk for j=1,…,Kσ(z)j=ezj∑k=1Kezk for j=1,…,K</p>
<p>将一个实数值向量压缩到（0，1）</p>
<h2 id="Traning-tricks"><a href="#Traning-tricks" class="headerlink" title="Traning tricks"></a>Traning tricks</h2><h3 id="图像像素中心化"><a href="#图像像素中心化" class="headerlink" title="图像像素中心化"></a>图像像素中心化</h3><p>（R,G,B)减去各自通道的均值</p>
<h3 id="防过拟合，提高泛化能力"><a href="#防过拟合，提高泛化能力" class="headerlink" title="防过拟合，提高泛化能力"></a>防过拟合，提高泛化能力</h3><p><strong>数据增强</strong>：</p>
<p>1.在256x256的图片中，随机裁剪一块224x224的子区域</p>
<p>2.旋转、反转</p>
<p><strong>Dropout随机失活</strong>：一般是让一半的神经元仍有推断能力，反向传播时不经过这些节点，防止网络过度依赖全部节点，只在training时dropout</p>
<p><strong>Weight decay权重衰减（L2正则）</strong>：其中C0C0为原本的loss function</p>
<p>C=C0+λ2n∑ww2C=C0+λ2n∑ww2</p>
<h2 id="感受野（-Receptive-Field-）"><a href="#感受野（-Receptive-Field-）" class="headerlink" title="感受野（ Receptive Field ）"></a>感受野（ Receptive Field ）</h2><p>在卷积神经网络中，感受野（Receptive Field）的定义是卷积神经网络每一层输出的特征图（feature map）上每个像素点在原始图像上映射的区域大小，这里的原始图像是指网络的输入图像，是经过预处理（如resize，warp，crop）后的图像。</p>
<p>神经元之所以无法对原始图像的所有信息进行感知，是因为在卷积神经网络中普遍使用卷积层和pooling层，在层与层之间均为局部连接。</p>
<p>神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次.</p>
<p>i.e,</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/5413944-d91ffdd1cd88f593.webp" alt="img"></p>
<p>计算公式：</p>
<p>rn=rn−1∗kn−(kn−1)∗(rn−1−∏i=1n−1si)n&gt;=2rn=rn−1∗kn−(kn−1)∗(rn−1−∏i=1n−1si)n&gt;=2</p>
<h2 id="CNN的发展"><a href="#CNN的发展" class="headerlink" title="CNN的发展"></a>CNN的发展</h2><p><img src="https://perfectism13.github.io/2019/11/23/CNN/3.png" alt="img"></p>
<p>常见的CNN 结构一般为：输入～＞［［ 卷积～＞激活函数］ × N ～＞池化］ × M ～〉［ 全连接～＞激活］ × K ～＞全连接， N 个卷积＋激活＋池化构成一个子网络，通过叠加这个子网络达到增强整个网络表达能力的效果，接着再跟上几组全连接加激活的子网络， 最后进行一次全连接＋ s。如nax （对于二分类使用sigmoid ）。这样就可以使网络模块化，搭建网络就像搭积木一样简洁。</p>
<h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>Hinton课题组，2012ILSVRC冠军，一举超越SVM，标志着DNN革命的开始</p>
<p>训练时长：2weeks，5个卷积层，3个全连接层，60M个参数，650k个神经元</p>
<p>新技术：ReLU、最大池化、dropout、局部响应归一化（Local Response Normalization,LRN)</p>
<p>详细参数如下表：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/AlexNet_Summary_Table.jpg" alt="img"></p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191130201534590.png" alt="image-20191130201534590"></p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/4.png" alt="img"></p>
<p>对于conv1的Pad是否为2仍然有争议</p>
<h4 id="局部响应归一化（Local-Response-Normalization"><a href="#局部响应归一化（Local-Response-Normalization" class="headerlink" title="局部响应归一化（Local Response Normalization)"></a>局部响应归一化（Local Response Normalization)</h4><p>bix,y=aix,y(k+α∑i+n/2j=i−n/2(ajx,y)2)βbx,yi=ax,yi(k+α∑j=i−n/2i+n/2(ax,yj)2)β</p>
<p>在某一层得到多通道的响应图后，对相应图上某一位置和临近通道的值按上式做归一化，k,α,βk,α,β均为超参数，nn为局部通道的总数，模拟的是动物神经的横向抑制效应。</p>
<p>若该通道和邻近通道的绝对之都比较大，归一后值有更小的趋势。但VGG组发现LRN在11层网络中已经起了负作用。而且将LRN放在maxpool层前，在计算上并不经济，caffenet将两层的顺序更换，进行了改进。</p>
<h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3><p>由牛津大学视觉几何组（visual geometry group),2014ILSVRC定位第一，分类第二，网络改造的首选基础网络</p>
<p>核心思想卷积核拆解，或者说将卷积核的size固定为3x3，5拆成两个3x3,7拆成3x3,不同层数的VGG参数如下：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/0_HREIJ1hjF7z4y9Dd.jpg" alt="img"></p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/VGG16_Summary-Table.jpg" alt="img"></p>
<h3 id="NiN（Network-in-Network"><a href="#NiN（Network-in-Network" class="headerlink" title="NiN（Network-in-Network)"></a>NiN（Network-in-Network)</h3><p>提高CNN的局部感知区域（bottleneck）,为1x1卷积层，通过调整1×1卷积核的数量，可以在不改变输入feature map尺寸和感受野的情况下，灵活地增加或减少feature map的channel数量，<strong>特征组合与降维、引入更多的非线性</strong>，当然也可以升维，表达能力更强，在实现feature map间信息交流的同时，获得信息的压缩或增广表示。 相当于直接压缩特征图厚度，节省了计算资源。</p>
<h3 id="全局平均池化（Global-Average-Pooling）"><a href="#全局平均池化（Global-Average-Pooling）" class="headerlink" title="全局平均池化（Global Average Pooling）"></a>全局平均池化（Global Average Pooling）</h3><p>对最后一层卷积的响应图，每个通道求整个响应图的均值，再接一层全连接，全局池化后的值相当于一像素，最后的全连接相当于一个加权相加，这种结构比直接的全连接更直观，泛化性更好。</p>
<p>把特征图全局平均一下输出一个值，也就是把$H<em>W</em>D的一个张量变成的一个张量变成1<em>1</em>D$的张量</p>
<h3 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h3><p>2014分类第一，减少参数，降低计算，增加宽度、深度</p>
<h4 id="Naive-Inception"><a href="#Naive-Inception" class="headerlink" title="Naive Inception"></a>Naive Inception</h4><p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201134358397.png" alt="image-20191201134358397"></p>
<p>1）所有卷积层直接和上层的输出对接，卷积核的参数异常多，计算量异常大，2）最大池化层不改变深度，合并时深度增加明显，计算量过大</p>
<h4 id="Inception-V1"><a href="#Inception-V1" class="headerlink" title="Inception V1"></a>Inception V1</h4><p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201135206376.png" alt="image-20191201135206376"></p>
<p>1）<strong>分离与合并</strong>，增加多尺度适应性，增加网络宽度 ，串接合并所有分支输出，2）使用<strong>1x1卷积</strong>进行特征降维与组合，极大降低后续卷积操作的卷积参数数量，3）取消参数量大的FC，本质是全尺寸的卷积层，由<strong>全局平均池化</strong>代替，4）<strong>两个辅助分类器</strong>，解决前几层的梯度消失，测试阶段不使用</p>
<p>具体的参数如下：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/1207807-20190324141917298-1669677542.png" alt="img"></p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/1_rXcdL9OV5YKlYyks9XK-wA.png" alt="img"></p>
<p>网络结构如下：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201162719817.png" alt="image-20191201162719817"></p>
<h4 id="Inception-V2"><a href="#Inception-V2" class="headerlink" title="Inception V2"></a>Inception V2</h4><p><img src="https://perfectism13.github.io/2019/11/23/CNN/th.tiff" alt="img"></p>
<p>1）<strong>批量归一化（Batch Normalization)</strong>，在batch范围内对每个特征通道分别进行归一化,解决Internal Covariate Shift问题（神经元数据分布发生变动）,保证训练数据里数值都在同一<strong>量级</strong>上，使训练时的数值更加稳定。 <strong>批量归一化层</strong>的提出是针对这个情况。它<strong>将一个批量里的输入数据进行归一化然后输出</strong>。如果我们将批量归一化层放置在网络的各个层之间，那么就可以不断的对中间输出进行调整，从而保证整个网络的中间输出的<strong>数值稳定性</strong>。</p>
<ul>
<li><p>白化：使每一层的输出规范到N(0,1)N(0,1),因为大多数激活函数在(−1,1)(−1,1)间都有较大梯度，故可以允许较高学习率, conv→BN→ReLUconv→BN→ReLU</p>
</li>
<li><p>可取代部分Dropout，注意BN在卷积层，Dropout在全连接层</p>
</li>
<li><p>μ←1m∑mi=1xiσ2=1m∑mi=1(xi−μ)x^i←xi−μσ2+ε√μ←1m∑i=1mxiσ2=1m∑i=1m(xi−μ)x^i←xi−μσ2+ε</p>
</li>
<li><p>这里ϵ是一个很小的常数保证不除以0 ，但这样并不是最好的分布，i.e,数据本身不对称，激活函数在(−1,1)(−1,1)间梯度变化不大，因此配对使用scale和shift，γ,βγ,β需要学习</p>
</li>
<li><p>y^i←γx^i+βy^i←γx^i+β</p>
</li>
<li><p>Training：每个batch中μ,σμ,σ会被存储，Testing:使用所有batch的μ,σμ,σ均值</p>
</li>
</ul>
<p>2）卷积核：卷积核拆解</p>
<h4 id="Inception-V3"><a href="#Inception-V3" class="headerlink" title="Inception V3"></a>Inception V3</h4><p>工程实验因素明显</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/th.jpg" alt="img"></p>
<p>1）<strong>非对称卷积</strong>：NXN分解成$1<em>N\to N</em>1$,降低参数数量和计算量</p>
<p>2）不同分辨率使用不同inception modules</p>
<ul>
<li><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201201755562.png" alt="image-20191201201755562"></li>
<li><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201201856514.png" alt="image-20191201201856514"></li>
</ul>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201202413767.png" alt="image-20191201202413767"></p>
<p>3）解决pooling导致的特征损失与计算量增大之间的矛盾</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201203933188.png" alt="image-20191201203933188"></p>
<p> 提出了如下解决方案：卷积分支与池化分支并行，然后串接分支结果</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191201204319424.png" alt="image-20191201204319424"></p>
<p>4）取消完全无用的浅层分类器，深层辅助分类器只在训练后期有用，起到一定正则化作用</p>
<h4 id="Inception-V4"><a href="#Inception-V4" class="headerlink" title="Inception V4"></a>Inception V4</h4><p>引入残差的思想：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191203000234253.png" alt="image-20191203000234253"></p>
<h3 id="ResNet残差网络"><a href="#ResNet残差网络" class="headerlink" title="ResNet残差网络"></a>ResNet残差网络</h3><p>2015分类任务第一，发明者为何凯明，现在Facebook AI</p>
<p><strong>目的：</strong>解决退化问题</p>
<p><strong>退化问题</strong>：随着层数加深到一定程度，越深的网络效果反而更差，并不是因为”深”造成了过拟合或梯度传播的衰减</p>
<p> <strong>简单的例子</strong>：堆叠一层使堆叠后的输出和堆叠前的输出相同，即使用全为1x1的值为1的卷积核，但实验结果表明，网络层数达到一定深度，结果变差</p>
<p>深度更深，∂L∂W&gt;1∂L∂W&gt;1，一般来说浅层的卷积核尺寸大，因为浅层需要大的感受野来感知原始信息</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191202223355957.png" alt="image-20191202223355957"></p>
<p>1）残差网络（Residual net)</p>
<ul>
<li>因为Plain net（朴素网络）可以拟合任意目标映射，故Residual可以拟合任意目标映射，</li>
<li>F(x)F(x)对于xx来说是残差映射</li>
<li>当H(X)H(X)接近xx时，很容易捕捉到小的波动</li>
</ul>
<p>2) 除了第一层的7X7卷积层，剩下全是3x3卷积层</p>
<p>3）卷积步长为2代替池化，使用BN，取消全连接层，取消Dropout</p>
<p>4）恒等映射两种使用情况：残差模块的输入数据若和输出结果的维度一致，贝lj 直接相加；若维度不一致，则先进行线性投影，在得到一致的维度后，再进行相加或者对维度不一致的部分使用0 填充。</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/Users/%E9%97%B5%E6%99%A8%E9%98%B31998/AppData/Roaming/Typora/typora-user-images/image-20191202235511488.png" alt="image-20191202235511488"></p>
<p>注意此处的相加为通道直接叠加，详细参数：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/resnet-architectures-34-101.png" alt="img"></p>
<h3 id="ResNeXt网络"><a href="#ResNeXt网络" class="headerlink" title="ResNeXt网络"></a>ResNeXt网络</h3><p>2016竞赛第二</p>
<p>1)提出第三个DNN维度，<strong>cardinality基数</strong>，采用Split-Transform-Aggregate策略将卷积核按通道分组，形成32个并行分支，最后逐像素进行加法合并</p>
<p>2）100层ResNeXt相当于200层ResNet，</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191203151455943.png" alt="image-20191203151455943"></p>
<p>没有基数前的参数数量：$256<em>1</em>1<em>64+64</em>3<em>3</em>64+64<em>1</em>1*256 = 69632$</p>
<p>并行分支后的参数数量：$32<em>(256</em>1<em>1</em>4+4<em>3</em>3<em>4+4</em>1<em>1</em>256) = 70144$可见参数数量差别不大</p>
<p>3）增加基数会不断提高性能</p>
<p>详细参数：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/resnext_table.png" alt="img"></p>
<p><strong>FLOPs</strong>： floating point operations ， 意指浮点运算数，理解为计算量。可以用来衡量算法/模型的复杂度</p>
<p><strong>FLOPS</strong>: floating point operations per second , 意指每秒浮点运算次数，理解为计算速度。是一个衡量硬件性能的指标。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://perfectism13.github.io/2019/11/23/CNN/Users/%E9%97%B5%E6%99%A8%E9%98%B31998/AppData/Roaming/Typora/typora-user-images/image-20191203154319654.png" alt="image-20191203154319654"></p>
<p>ImageNet分类的准确性和执行效率对比：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191203184638688.png" alt="image-20191203184638688"></p>
<p>场景分类的性能对比：</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191203185114194.png" alt="image-20191203185114194"></p>
<h3 id="CNN的设计准则"><a href="#CNN的设计准则" class="headerlink" title="CNN的设计准则"></a>CNN的设计准则</h3><p>1.<strong>避免信息瓶颈</strong>:使数据量$H<em>W</em>C$缓慢变小，不能突降或突升</p>
<p>2.<strong>通道（卷积核）数量保持在可控范围内</strong>，假设输入通道为CC，输出通道为KK,则参数数量为$H<em>{f}*W</em>{f}<em>C</em>K,操作数量为,操作数量为\frac {H<em>H_{f}}{stride}</em>\frac {W<em>W_{f}}{stride}</em>C*K$</p>
<p>3.<strong>感受野要足够大</strong></p>
<ul>
<li>多个小尺寸卷积核比用一个大的卷积核更优，参数少，计算快；多个非线性激活，i,e. $64<em>5</em>5<em>64&lt;64</em>(3<em>3+3</em>3)*64$,且多了一个激活函数，非线性因素更多</li>
</ul>
<p>4.<strong>分组策略</strong>，降低计算量，i,e.$64<em>3</em>3<em>64+32</em>3<em>3</em>32&lt;96<em>3</em>3*96$</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/image-20191203171558330.png" alt="image-20191203171558330"></p>
<p>5.<strong>低秩分解</strong>：降低参数，降低计算量</p>
<p><img src="https://perfectism13.github.io/2019/11/23/CNN/Users/%E9%97%B5%E6%99%A8%E9%98%B31998/AppData/Roaming/Typora/typora-user-images/image-20191203184243798.png" alt="image-20191203184243798"></p>
]]></content>
  </entry>
  <entry>
    <title>Detection of Secondary Driving Tasks</title>
    <url>/2020/07/24/Detection%20of%20Secondary%20Driving%20Tasks/</url>
    <content><![CDATA[<h1 id="Detection-of-Secondary-Driving-Tasks"><a href="#Detection-of-Secondary-Driving-Tasks" class="headerlink" title="Detection of Secondary Driving Tasks"></a>Detection of Secondary Driving Tasks</h1><p>MIT—AVT</p>
<h2 id="王飞跃等的相关工作"><a href="#王飞跃等的相关工作" class="headerlink" title="王飞跃等的相关工作"></a>王飞跃等的相关工作</h2><p>1.<strong>End-to-End Driving Activities and Secondary Tasks Recognition Using Deep Convolutional Neural Network and Transfer Learning</strong></p>
<ul>
<li>Specifically, seven common driving activities are identified, which are <strong>normal driving, right mirror checking, rear mirror checking, left mirror checking, using in-vehicle video device, texting, and answering mobile phone</strong>. Among these, the first four activities are regarded as normal driving tasks, while the rest three are divided into distraction group.</li>
<li>using a <strong>Gaussian mixture model (GMM)</strong> to extract the driver region from the background</li>
<li><strong>AlexNet</strong>：directly takes the processed RGB images as the input and outputs the identified label.</li>
<li>to reduce the training cost, the <strong>transfer learning</strong> mechanism is applied</li>
<li>An average of <strong>79%</strong> detection accuracy</li>
</ul>
<p>2.<strong>Identification and Analysis of Driver Postures for In-Vehicle Driving Activities and Secondary Tasks Recognition</strong></p>
<ul>
<li>the importance of these features to behaviour recognition is evaluated using <strong>Random Forests (RF) andMaximal Information Coefficient (MIC)</strong> methods.</li>
<li><strong>Feedforward Neural Network (FFNN)</strong> is used to identify the seven tasks</li>
<li><img src="https://perfectism13.github.io/2019/11/10/Driving%20Tasks%20review/image-20191204225003730.png" alt="image-20191204225003730"></li>
</ul>
<p>3.</p>
<p><img src="https://perfectism13.github.io/2019/11/10/Driving%20Tasks%20review/image-20191205095652323.png" alt="image-20191205095652323"></p>
<p>4.Non-Driving Activities Recognition using two-stream convolutional neural network and FlowNet 2.0</p>
<h2 id="datasets"><a href="#datasets" class="headerlink" title="datasets"></a>datasets</h2><p><a href="https://devyhia.github.io/projects/auc-distracted-driver-dataset" target="_blank" rel="noopener">AUC Distracted Driver Dataset</a></p>
<p>原文见《Real-time Distracted Driver Posture Classification》</p>
<p><a href="https://www.kaggle.com/c/state-farm-distracted-driver-detection/overview" target="_blank" rel="noopener">State Farm Distracted Driver Detection</a></p>
<p><a href="https://perfectism13.github.io/2019/11/10/Driving Tasks review/www.driveandact.com" target="_blank" rel="noopener">Drive&amp;Act</a></p>
<p><a href="https://sites.google.com/site/benkhalifaanouar1/6-datasets?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1" target="_blank" rel="noopener">MDAD: A Multimodal and Multiview in-Vehicle Driver Action Dataset</a></p>
<p>R-DA</p>
<p>原文见：《Feature refinement for image-based driver action recognition via multi-scale attention convolutional neural network》</p>
<h2 id="ideas"><a href="#ideas" class="headerlink" title="ideas"></a>ideas</h2><h3 id="skeleton"><a href="#skeleton" class="headerlink" title="skeleton"></a>skeleton</h3><ol>
<li>Skeleton-Based Action Recognition（基于骨骼关键点）</li>
<li>openpose for skeleton for 1</li>
</ol>
<h3 id="直接分类"><a href="#直接分类" class="headerlink" title="直接分类"></a>直接分类</h3><ol>
<li>训练好图片分类器后，使用对指定数目的帧取平均的办法对视频分类</li>
</ol>
<h3 id="将传统图像处理的办法与深度学习相结合"><a href="#将传统图像处理的办法与深度学习相结合" class="headerlink" title="将传统图像处理的办法与深度学习相结合"></a>将传统图像处理的办法与深度学习相结合</h3><p>图像的滤波、分裂、归并、分割以及形态学处理</p>
<h3 id="传统的SVM-KNN仍有很强的应用前景"><a href="#传统的SVM-KNN仍有很强的应用前景" class="headerlink" title="传统的SVM,KNN仍有很强的应用前景"></a>传统的SVM,KNN仍有很强的应用前景</h3><h3 id="语义分割，然后定位（分离驾驶员和背景再输入网络）"><a href="#语义分割，然后定位（分离驾驶员和背景再输入网络）" class="headerlink" title="语义分割，然后定位（分离驾驶员和背景再输入网络）"></a>语义分割，然后定位（分离驾驶员和背景再输入网络）</h3><h3 id="全卷积，解决驾驶员有多个第二驾驶员任务时"><a href="#全卷积，解决驾驶员有多个第二驾驶员任务时" class="headerlink" title="全卷积，解决驾驶员有多个第二驾驶员任务时"></a>全卷积，解决驾驶员有多个第二驾驶员任务时</h3><h3 id="利用人体骨骼做图像预处理"><a href="#利用人体骨骼做图像预处理" class="headerlink" title="利用人体骨骼做图像预处理"></a>利用人体骨骼做图像预处理</h3><p>在模型的训练过程中，并没有对图像进行裁切，事实上很多图像元素是不需要的，我们只需要关注驾驶员的肢体及面部等特征，并不需要去过多关注车身等部分特征，一定程度上可提高训练效果。<br>通过基于人体骨骼点识别，根据人体骨骼点的完整程度，识别司机肢体，再进行凸包形态学处理，从而把人体相关的部分图片提取出来，完成剪切操作；把图片用白色填充成一个方形图片，此时，图片大小、特征减少，从而使图片可以正常用于训练。</p>
<h3 id="每一帧图片增加两帧光流，再对连续几帧数据的CNN结果融合"><a href="#每一帧图片增加两帧光流，再对连续几帧数据的CNN结果融合" class="headerlink" title="每一帧图片增加两帧光流，再对连续几帧数据的CNN结果融合"></a>每一帧图片增加两帧光流，再对连续几帧数据的CNN结果融合</h3><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>降低错检率和漏检率</p>
<h2 id="inception-v3"><a href="#inception-v3" class="headerlink" title="inception v3"></a>inception v3</h2><h2 id="xception"><a href="#xception" class="headerlink" title="xception"></a>xception</h2><p>163/163 [==============================] - 4334s 27s/step - loss: 0.2972 - acc: 0.9080 - val_loss: 2.9806 - val_acc: 0.3750 Epoch 2/4</p>
<p>出现每一epoch，训练时的准确率很高，测试时却很低的情况</p>
<p>如何解决断点续训的问题，每一epoch都保存一次模型，下一次load？</p>
<h3 id="NameError-name-‘backend’-is-not-defined"><a href="#NameError-name-‘backend’-is-not-defined" class="headerlink" title="NameError: name ‘backend’ is not defined"></a>NameError: name ‘backend’ is not defined</h3><p><a href="http://studyai.com/article/d3616cea" target="_blank" rel="noopener">http://studyai.com/article/d3616cea</a></p>
<p><a href="https://github.com/keras-team/keras/issues/5088" target="_blank" rel="noopener">https://github.com/keras-team/keras/issues/5088</a></p>
<p><a href="https://blog.csdn.net/Mr_green_bean/article/details/94575883" target="_blank" rel="noopener">https://blog.csdn.net/Mr_green_bean/article/details/94575883</a></p>
<h3 id="调用flow-from-directory-出现“Found-0-images-belonging-to-2-classes”问题"><a href="#调用flow-from-directory-出现“Found-0-images-belonging-to-2-classes”问题" class="headerlink" title="调用flow_from_directory()出现“Found 0 images belonging to 2 classes”问题"></a>调用flow_from_directory()出现“Found 0 images belonging to 2 classes”问题</h3><p><a href="https://blog.csdn.net/space_dandy/article/details/88431421" target="_blank" rel="noopener">https://blog.csdn.net/space_dandy/article/details/88431421</a></p>
<p>创建一个子文件夹</p>
<h3 id="StopIteration-cannot-identify-image-file-‘-test-test-img-15308-jpg’"><a href="#StopIteration-cannot-identify-image-file-‘-test-test-img-15308-jpg’" class="headerlink" title="StopIteration: cannot identify image file ‘./test/test/img_15308.jpg’"></a>StopIteration: cannot identify image file ‘./test/test/img_15308.jpg’</h3><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="image-classification"><a href="#image-classification" class="headerlink" title="image classification"></a>image classification</h3><ul>
<li>[x] Resnet 50 M1 NOT CAM</li>
<li>[x] Xception M11 CAM</li>
<li>[x] Xception M9 CAM，两个预测</li>
<li>[x] Xception M12 CAM,目前效果最好</li>
<li>[x] Xception M10 CAM,目前效果最差</li>
<li>[x] InceptionResNetV2 M13 ，not CAM</li>
<li>[x] M9+M11+M1+M13，效果待定</li>
<li>[x] save model</li>
<li>[x] cam visualization</li>
<li>[x] 统计不同模型对不同类别的检测准确度，Confusion matrix</li>
<li>[x] <strong>skeleton preprocessing,效果究竟如何？（骨架）</strong></li>
<li>[ ] <strong>使用语义分割分割驾驶员和背景再输入网络,提取头部、手部、脸部、特征</strong></li>
<li>[x] 综合 Xception、InceptionV3和InceptionResNetV2</li>
<li>[ ] NASNetLarge</li>
<li>[x] InceptionResNetV2</li>
<li>[ ] Faster R-CNN</li>
<li>[x] mobilenet NASNETmobile轻量模型的尝试</li>
<li>[x] auto ML，已使用百度的DL</li>
<li>[x] 完善类激活图</li>
<li>[ ] 晚上可能要用红外摄像头</li>
<li>[x] <strong>融合模型的方法：特征Concatenate ，每帧结果直接取平均（去掉最大和最小），SVM，遗传算法求加权平均，关键是确定可学习和不可学习参数</strong></li>
<li>[ ] <strong>K-近邻算法投票（相邻几帧（滑窗0投票）</strong>,时间对最终结果的影响</li>
<li>[ ] 权重可学习</li>
<li>[ ] 二阶梯度最优化器，SGD,Nadam</li>
<li>[ ] 使用元学习的方法，重新采样构建每个batch的support set和query set</li>
<li>[ ] 图卷积神经网络</li>
<li>[ ] 使用类别不平衡思想，增强数据</li>
<li>[x] <strong>在图片上施加噪声，模拟光照变化，头发遮挡，帽子等</strong></li>
<li>[x] <strong>动态视频检测，体现实时性，时间变化和检测结果同时显现</strong></li>
<li>[x] 每个epoch打乱，提高训练稳定性</li>
<li>[x] 加隐藏层，全连接单元数量下降慢点，可在论文中对比</li>
<li>[x] 与原论文结果进行对比</li>
<li>[x] <strong>找到batch_size不能取更大的原因，如workers，采用128，256等更大的batch_size</strong></li>
<li>[ ] 填周志</li>
<li>[x] 比较冻结与放开全部层数的结果 V1 Xception、InceptionV3、 V2 InceptionV3</li>
<li>[x] 重新训练 AUC V2的模型</li>
<li>[x] 使用batch_size减小继续训练AUC V1模型</li>
<li>[x] 在AUC V2上重新启用Resnet50 主要是改变图片的预处理方式,每个通道分别减去训练集该通道平均值</li>
<li>[x] 使用sklearn记录模型融合时的损失值,底层求准确率</li>
<li>[ ] 解决自己录制的视频中：V1版本模型右手打字、喝水、操作收音机三个类别识别准确率低，V2版本模型右手打字准确率低，喝水、整理头发和化妆易混淆：1.手动标定，加入训练集中训练（掩耳盗铃） <strong>2.拍摄与数据集摄像头角度相似的数据</strong> 3.V2版本的模型泛化能力更好，在此基础上实验滑窗</li>
<li>[x] V1的loss和time，V2的loss</li>
<li>[x] 整理state-farm数据集结果,并使用其预测采集的视频</li>
<li>[x] 在camera2的demo视频上尝试视频滑窗预测，看在低分类准确率时会不会有提升</li>
<li>[x] 找到三个版本的数据集中摄像头的安装位置信息</li>
<li>[ ] 使用模型压缩和量化，<strong>丢帧处理</strong>等方式提高<strong>实时性</strong></li>
<li>[ ] <strong>标定好自己采集的视频，还需要采集强曝光、晚上的视频，并进行预测</strong></li>
<li>[x] <strong>尝试openpose获取的骨架输入CNN，并整理分类效果</strong></li>
<li>[x] 开始写论文</li>
<li>[x] 整理好4.7和4.9的123视频滑窗预测效果</li>
<li>[x] 中期答辩ppt</li>
<li>[x] 整理中期答辩文件</li>
<li>[x] 模拟答辩一次，确认所有文件</li>
<li>[x] 理解交叉熵</li>
<li>[x] 实时性对比需要明确硬件</li>
<li>[ ] 小数点不要太多</li>
<li>[ ] 扩充数据集</li>
<li>[x] 可视化CNN每层提取的特征(滤波器)</li>
<li>[ ] 了解召回率</li>
<li>[ ] 使用增强后的图片做预测，测试模型的鲁棒性</li>
<li>[ ] 每个模型的权重占比与模糊数学的关系</li>
<li>[ ] 模型融合 stacking</li>
<li>[x] <strong>V1上InceptionV3和Xception 特征堆叠</strong></li>
<li>[x] 提取关键帧，目前关键帧提取时间过长</li>
<li>[ ] 图片相似比较 ，哈希算法，SIFT，SURF特征</li>
<li>[ ] 使用卷积层代替最终的全连接层 错误：ValueError: Error when checking target: expected last_conv to have 4 dimensions, but got array with shape (128, 10)</li>
<li>[x] <strong>检查和修改论文</strong></li>
<li>[x] <strong>图纸</strong></li>
<li>[ ] <strong>创新点</strong></li>
<li>[ ] <strong>提升分类准确率</strong></li>
<li>[x] <strong>FCN</strong></li>
<li>[x] CAM可视化 描述的更清楚点</li>
<li>[x] 丢帧处理 目的是提升实时性能</li>
<li>[x] 章与章之间要有过渡语句，章开始用将来时，结束用完成时</li>
<li>[x] CAM可视化 云图的颜色表达</li>
<li>[x] CAM 可视化视频制作</li>
<li>[x] 没有丢帧处理前的视频整理</li>
<li>[x] ppt制作</li>
<li>[ ] ppt讲解问题：</li>
<li>[ ] 优化器中的偏差校正作用</li>
<li>[ ] 固定极小常量的作用</li>
</ul>
<h3 id="video-classification"><a href="#video-classification" class="headerlink" title="video classification"></a>video classification</h3><ul>
<li>[x] video input and predict video output</li>
<li>[x] simple model to classify video ，single frame in and out</li>
<li>[x] video dataset,Drive&amp;Act</li>
<li>[ ] CNN Based Spatio-Temporal Approach，append flow frame到RGB，input Xception，然后取视频里的四帧进行预测平均，Motion Fused Frames (MFFs)，model is ready</li>
<li>[ ] 融合特征，输入softmax或者SVM，需修改video_model</li>
<li>[ ] two-stream</li>
<li>[ ] I3D，model is ready, flip aug</li>
<li>[ ] C3D</li>
<li>[ ] P3D Resnet</li>
<li>[ ] CNN+LSTM model to classify video</li>
<li>[ ] AUTO ML？</li>
</ul>
<h2 id="model-trained-logs"><a href="#model-trained-logs" class="headerlink" title="model trained logs"></a>model trained logs</h2><p>M1 2epochs</p>
<p>M11 6epochs</p>
<p>M9 4epochs</p>
<p>video_model 5epochs</p>
<p>video_model_change_vd 8epochs</p>
<p>video_model_change_vd_aug 3epochs 不是一个动作的两帧！网络模型，第一个conv2d提取的特征不够</p>
<p>flow_xception 3epochs</p>
<p>flow_xception_lock70 2epochs</p>
<p>I3D 数据存在问题</p>
<p>尝试使用交叉验证</p>
<p>修改ini_lr,batch_size等超参数</p>
<p>mffs_model_dropout_more_shift_modified 5epochs</p>
<h2 id="Websites"><a href="#Websites" class="headerlink" title="Websites"></a>Websites</h2><p>分心驾驶危害：</p>
<p><a href="https://www.nhtsa.gov/risky-driving/distracted-driving/" target="_blank" rel="noopener">https://www.nhtsa.gov/risky-driving/distracted-driving/</a></p>
<p>Keras中的模型搭建和配置：</p>
<p><a href="https://keras.io/zh/getting-started/sequential-model-guide/#lstm" target="_blank" rel="noopener">https://keras.io/zh/getting-started/sequential-model-guide/#lstm</a></p>
<p>kaggle比赛经验：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26309073" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26309073</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1556210" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1556210</a></p>
<p><a href="https://towardsdatascience.com/distracted-driver-detection-using-deep-learning-e893715e02a4" target="_blank" rel="noopener">https://towardsdatascience.com/distracted-driver-detection-using-deep-learning-e893715e02a4</a></p>
<p><a href="https://mc.ai/distracted-driver-detection/" target="_blank" rel="noopener">https://mc.ai/distracted-driver-detection/</a></p>
<p>驾驶员行为检测：</p>
<p><a href="https://xugang.ink/wiki/2018-09-14-驾驶员行为检测/" target="_blank" rel="noopener">https://xugang.ink/wiki/2018-09-14-%E9%A9%BE%E9%A9%B6%E5%91%98%E8%A1%8C%E4%B8%BA%E6%A3%80%E6%B5%8B/</a></p>
<p>人体姿态估计：</p>
<p><a href="http://www.ilovepose.cn/tags" target="_blank" rel="noopener">http://www.ilovepose.cn/tags</a></p>
<p>视频分类：</p>
<p><a href="https://www.pyimagesearch.com/2019/07/15/video-classification-with-keras-and-deep-learning/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2019/07/15/video-classification-with-keras-and-deep-learning/</a></p>
<p>cnn+lstm：<a href="https://github.com/apachecn/ml-mastery-zh/blob/master/docs/lstm/cnn-long-short-term-memory-networks.md" target="_blank" rel="noopener">https://github.com/apachecn/ml-mastery-zh/blob/master/docs/lstm/cnn-long-short-term-memory-networks.md</a></p>
<p>杂：</p>
<p><a href="https://www.youtube.com/watch?time_continue=1988&amp;v=dwukLOPpaHw&amp;feature=emb_title" target="_blank" rel="noopener">https://www.youtube.com/watch?time_continue=1988&amp;v=dwukLOPpaHw&amp;feature=emb_title</a></p>
<p>现场演示：</p>
<p><a href="https://github.com/luisarojas/distracted-driver-detection" target="_blank" rel="noopener">https://github.com/luisarojas/distracted-driver-detection</a></p>
<p>wget远程下载数据集</p>
<p><a href="https://blog.csdn.net/yanlisuo/article/details/81329920" target="_blank" rel="noopener">https://blog.csdn.net/yanlisuo/article/details/81329920</a></p>
<p>keras函数式编程：</p>
<p><a href="https://keras.io/getting-started/functional-api-guide/" target="_blank" rel="noopener">https://keras.io/getting-started/functional-api-guide/</a></p>
<p><a href="https://blog.csdn.net/ting0922/article/details/94437540" target="_blank" rel="noopener">https://blog.csdn.net/ting0922/article/details/94437540</a></p>
<p>减少过拟合的方法：</p>
<p><a href="http://iot-fans.xyz/2017/11/20/deeplearning/overfitting/" target="_blank" rel="noopener">http://iot-fans.xyz/2017/11/20/deeplearning/overfitting/</a></p>
<p><a href="https://www.zhihu.com/question/59201590" target="_blank" rel="noopener">https://www.zhihu.com/question/59201590</a></p>
<p><a href="https://kaiyuanzhang.com/2018/05/02/overfitting-and-underfitting/" target="_blank" rel="noopener">https://kaiyuanzhang.com/2018/05/02/overfitting-and-underfitting/</a></p>
<p>kaggle数据集无法在论文中使用：</p>
<p><a href="https://www.kaggle.com/c/state-farm-distracted-driver-detection/discussion/20043" target="_blank" rel="noopener">https://www.kaggle.com/c/state-farm-distracted-driver-detection/discussion/20043</a></p>
<p>Auto ML平台</p>
<p><a href="https://zhuanlan.zhihu.com/p/57896464" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57896464</a></p>
<p><a href="https://ai.baidu.com/easydl/app/1/models/50071/iterations?deployType=cloud" target="_blank" rel="noopener">https://ai.baidu.com/easydl/app/1/models/50071/iterations?deployType=cloud</a></p>
<p>sklearn使用</p>
<p><a href="https://www.cnblogs.com/lianyingteng/p/7811126.html" target="_blank" rel="noopener">https://www.cnblogs.com/lianyingteng/p/7811126.html</a></p>
<p>CSV文件编写：</p>
<p><a href="https://www.cnblogs.com/jasontang369/p/9241334.html" target="_blank" rel="noopener">https://www.cnblogs.com/jasontang369/p/9241334.html</a></p>
<p>ImageNet上预训练是否真的有用：</p>
<p><a href="https://www.52cv.net/?p=1741" target="_blank" rel="noopener">https://www.52cv.net/?p=1741</a></p>
<p>batchsize的选取：</p>
<p><a href="https://www.zhihu.com/question/61607442" target="_blank" rel="noopener">https://www.zhihu.com/question/61607442</a></p>
<p>128（0.005）256（0.01）</p>
<p>交叉验证和过拟合：</p>
<p><a href="https://www.cnblogs.com/solong1989/p/9415606.html" target="_blank" rel="noopener">https://www.cnblogs.com/solong1989/p/9415606.html</a></p>
<p>CNN调优总结：</p>
<p><a href="https://flashgene.com/archives/64534.html" target="_blank" rel="noopener">https://flashgene.com/archives/64534.html</a></p>
<p>面试100问：</p>
<p><a href="https://github.com/changgyhub/notes/blob/master/machine-learning/deep-learning/100-questions-part-1.md" target="_blank" rel="noopener">https://github.com/changgyhub/notes/blob/master/machine-learning/deep-learning/100-questions-part-1.md</a></p>
<p>模型评估，过拟合等：</p>
<p><a href="https://flashgene.com/archives/27598.html" target="_blank" rel="noopener">https://flashgene.com/archives/27598.html</a></p>
<p>数据预处理：</p>
<p><a href="https://zhuanlan.zhihu.com/p/29513760" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29513760</a></p>
<p>模型融合：</p>
<p><a href="https://machinelearningmastery.com/ensemble-methods-for-deep-learning-neural-networks/" target="_blank" rel="noopener">https://machinelearningmastery.com/ensemble-methods-for-deep-learning-neural-networks/</a></p>
<p>求解损失值：</p>
<p><a href="https://scikit-learn.org/stable/modules/model_evaluation.html#log-loss" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/model_evaluation.html#log-loss</a></p>
<p>有用的链接：</p>
<p><a href="https://github.com/Apoorvajasti/Distracted-Driver-Detection" target="_blank" rel="noopener">https://github.com/Apoorvajasti/Distracted-Driver-Detection</a> 含视频预测和KNN(以vgg卷积层的输出作为KNN的输入)</p>
<p><a href="https://github.com/nkjsy/Distracted-Driver-Detection" target="_blank" rel="noopener">https://github.com/nkjsy/Distracted-Driver-Detection</a>    12个，有报告</p>
<p><a href="https://github.com/godloveliang/MLND_distracted_driver_tetection" target="_blank" rel="noopener">https://github.com/godloveliang/MLND_distracted_driver_tetection</a> 烂，中文，有报告</p>
<p><a href="https://github.com/mwakaba2/Computer-Vision-Capstone-Project" target="_blank" rel="noopener">https://github.com/mwakaba2/Computer-Vision-Capstone-Project</a> 英文，含有传统特征，有报告</p>
<p><a href="https://github.com/ksasi/Machine-Learning-Capstone-Project" target="_blank" rel="noopener">https://github.com/ksasi/Machine-Learning-Capstone-Project</a> 英文</p>
<p><a href="https://gitee.com/ltg00/distracted_driver_detection?_from=gitee_search" target="_blank" rel="noopener">https://gitee.com/ltg00/distracted_driver_detection?_from=gitee_search</a> 全新的CAM，有报告</p>
<p><a href="https://github.com/luisarojas/distracted-driver-detection" target="_blank" rel="noopener">https://github.com/luisarojas/distracted-driver-detection</a> 网络结构对比</p>
<p><a href="https://github.com/nkcr7/Distracted-Driver-Detection" target="_blank" rel="noopener">https://github.com/nkcr7/Distracted-Driver-Detection</a> 兰中文，有报告</p>
<p><a href="https://github.com/jartantupjar/7-Distracted-Driver-Detection" target="_blank" rel="noopener">https://github.com/jartantupjar/7-Distracted-Driver-Detection</a> 兰英文，有报告</p>
<p><a href="https://github.com/LiuKaixinHappy/distracted_driver_detection" target="_blank" rel="noopener">https://github.com/LiuKaixinHappy/distracted_driver_detection</a> 中文，报告较好</p>
<p><a href="https://github.com/NaughtyFlame/distracted_driver_detection" target="_blank" rel="noopener">https://github.com/NaughtyFlame/distracted_driver_detection</a> 烂中文</p>
<p><a href="https://github.com/HarshineeSriram/Distracted-Driver-Detection" target="_blank" rel="noopener">https://github.com/HarshineeSriram/Distracted-Driver-Detection</a> 含有光流 svm LSTM</p>
<p><a href="https://github.com/Raj1036/ML_Distracted_Driver_Detection" target="_blank" rel="noopener">https://github.com/Raj1036/ML_Distracted_Driver_Detection</a> 含有随机森林，svm等，英文</p>
<p><a href="https://github.com/claudehotline/distracted_driver_detection" target="_blank" rel="noopener">https://github.com/claudehotline/distracted_driver_detection</a> 中文</p>
<p>使用格式工厂修改视频分辨率时，输出配置里的屏幕大小和宽高比例都要修改，第一次采用的是mp4格式</p>
<p><a href="https://zhuanlan.zhihu.com/p/53828405" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53828405</a> CNN 模型压缩与加速算法综述</p>
<p><a href="https://rss.paoluz.xyz/link/cEm96r3wztdHMrOc?sub=1" target="_blank" rel="noopener">https://rss.paoluz.xyz/link/cEm96r3wztdHMrOc?sub=1</a></p>
<p><a href="https://github.com/devyhia/action-annotation" target="_blank" rel="noopener">https://github.com/devyhia/action-annotation</a> 视频标注</p>
<p><a href="https://github.com/microsoft/VoTT#download-and-install-a-release-package-for-your-platform-recommended" target="_blank" rel="noopener">https://github.com/microsoft/VoTT#download-and-install-a-release-package-for-your-platform-recommended</a> 微软的视频标注软件</p>
<p><a href="https://www.pyimagesearch.com/2018/11/26/instance-segmentation-with-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2018/11/26/instance-segmentation-with-opencv/</a> 分离人体和背景</p>
<p>皮肤分割：</p>
<p><a href="https://www.pyimagesearch.com/2014/08/18/skin-detection-step-step-example-using-python-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2014/08/18/skin-detection-step-step-example-using-python-opencv/</a></p>
<p>colab安装openpose：</p>
<p><a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose/issues/949" target="_blank" rel="noopener">https://github.com/CMU-Perceptual-Computing-Lab/openpose/issues/949</a></p>
<p>可视化CNN的滤波器：</p>
<p><a href="https://keras-cn.readthedocs.io/en/latest/legacy/blog/cnn_see_world/" target="_blank" rel="noopener">https://keras-cn.readthedocs.io/en/latest/legacy/blog/cnn_see_world/</a></p>
<p>CNN可视化：</p>
<p><a href="https://blog.csdn.net/xys430381_1/article/details/90413169" target="_blank" rel="noopener">https://blog.csdn.net/xys430381_1/article/details/90413169</a></p>
<p>FFmpeg提取关键帧：</p>
<p><a href="https://blog.csdn.net/u011394059/article/details/78728809" target="_blank" rel="noopener">https://blog.csdn.net/u011394059/article/details/78728809</a></p>
<p>FLOPS和FLOPs的区别：</p>
<p><a href="https://blog.csdn.net/zt1091574181/article/details/97393278" target="_blank" rel="noopener">https://blog.csdn.net/zt1091574181/article/details/97393278</a></p>
<p>CNN的空间复杂度与时间复杂度：</p>
<p><a href="https://zhuanlan.zhihu.com/p/31575074" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31575074</a></p>
<p>CNN的发展：</p>
<p><a href="https://zhuanlan.zhihu.com/p/38681805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38681805</a></p>
<p>图片相似性匹配：</p>
<p><a href="https://blog.csdn.net/qq_16234613/article/details/83118222" target="_blank" rel="noopener">https://blog.csdn.net/qq_16234613/article/details/83118222</a></p>
<p>三种哈希算法的实现：</p>
<p><a href="https://blog.csdn.net/qq_32799915/article/details/81000437" target="_blank" rel="noopener">https://blog.csdn.net/qq_32799915/article/details/81000437</a></p>
<p><a href="https://www.cnblogs.com/Kalafinaian/p/11260808.html" target="_blank" rel="noopener">https://www.cnblogs.com/Kalafinaian/p/11260808.html</a></p>
<p><a href="https://content-blockchain.org/research/testing-different-image-hash-functions/" target="_blank" rel="noopener">https://content-blockchain.org/research/testing-different-image-hash-functions/</a></p>
<p><a href="http://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html" target="_blank" rel="noopener">http://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>New Words</title>
    <url>/2020/07/24/New%20Words/</url>
    <content><![CDATA[<h1 id="New-Words"><a href="#New-Words" class="headerlink" title="New Words"></a>New Words</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scalar 标量的</span><br><span class="line">neuron 神经元</span><br><span class="line">neural 神经的</span><br><span class="line">vector 向量</span><br><span class="line">parameter 参数</span><br><span class="line">gradient descent 梯度下降</span><br><span class="line">backpropagation 反向传播</span><br><span class="line">sentiment 感情、情绪</span><br><span class="line">embedded 嵌入的、植入的</span><br><span class="line">trimming 整理、修剪、切除</span><br><span class="line">syntactic parsing 语法分析</span><br><span class="line">semantic analysis 语义分析</span><br><span class="line">indicator 指示器，指示符</span><br><span class="line">shallow 浅的</span><br><span class="line">adversarial 对抗的</span><br><span class="line">indent 缩进</span><br><span class="line">contour 轮廓</span><br><span class="line">approx&#x3D;approxiate 大约的</span><br><span class="line">hierarchy 层级，等级制度</span><br><span class="line">Skeleton Joint 骨骼关节</span><br><span class="line">Semantic Segmentation 语义分割</span><br><span class="line">advent 来临</span><br><span class="line">gaze 注视</span><br><span class="line">row 行</span><br><span class="line">colunm 列</span><br><span class="line">extremum 极值</span><br><span class="line">gray level 灰度</span><br><span class="line">entropy 熵</span><br><span class="line">stochastic 随机的，猜测的</span><br><span class="line">crop 修剪，种植</span><br><span class="line">shuffle 随机播放，打乱顺序</span><br><span class="line">transpose 调换，转置</span><br><span class="line">precisely 恰好地</span><br><span class="line">dilation 扩张</span><br><span class="line">co-adaptation 过拟合</span><br><span class="line">syllabus 教学摘要，课程表</span><br><span class="line">spatial 空间的</span><br><span class="line">stochastic 随机的</span><br><span class="line">bottleneck 瓶颈</span><br><span class="line">geometry 几何结构</span><br><span class="line">plain 平的，简单的，朴素的</span><br><span class="line">Fine-tune 微调</span><br><span class="line">spatial 空间的</span><br><span class="line">sparse 稀疏的</span><br><span class="line">backend 后端</span><br><span class="line">attribute 属性</span><br><span class="line">deque 双端队列</span><br><span class="line">combat 反抗战斗</span><br><span class="line">temporal，temporary 暂时的</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Note of ROS to Ubantu</title>
    <url>/2020/07/24/Note%20of%20ROS%20to%20Ubantu/</url>
    <content><![CDATA[<h3 id="Note-of-ROS-to-Ubantu"><a href="#Note-of-ROS-to-Ubantu" class="headerlink" title="Note of ROS to Ubantu"></a>Note of ROS to Ubantu</h3><h4 id="terminal命令"><a href="#terminal命令" class="headerlink" title="terminal命令"></a>terminal命令</h4><p>echo $PATH： echo $PATH用于列出变量PATH的值，里面包含了已添加的目录</p>
<p>env：env命令是environment的缩写，用于列出所有的环境变量</p>
<p>export：单独使用export命令也可以像env列出所有的环境变量，不过export命令还有其他额外的功能</p>
]]></content>
  </entry>
  <entry>
    <title>Notes of Machine Learning</title>
    <url>/2020/07/24/Notes%20of%20Machine%20Learning/</url>
    <content><![CDATA[<h1 id="Notes-of-Machine-Learning"><a href="#Notes-of-Machine-Learning" class="headerlink" title="Notes of Machine Learning"></a>Notes of Machine Learning</h1><p>Min Chen Yang, Hunan University, 2019.11</p>
<h2 id="初识机器学习"><a href="#初识机器学习" class="headerlink" title="初识机器学习"></a>初识机器学习</h2><p><strong>从原始数据中提取模式的能力。</strong></p>
<p>进入21世纪，纵观机器学习发展历程，研究热点可以简单总结为2000-2006年的流形学习、2006年-2011年的稀疏学习、2012年至今的深度学习 、未来迁移学习？</p>
<p>人工智能的真正挑战在于解决对人来说很容易执行，但很难形式化描述的任务。</p>
<p>常用的10大机器学习算法有：决策树、随机森林、逻辑回归、SVM、朴素贝叶斯、K最近邻算法、K均值算法、Adaboost算法、神经网络、马尔科夫</p>
<p>大致分类：</p>
<p>监督式学习：决策树、KNN（K邻近）、朴素贝叶斯(贝叶斯分类器）、逻辑回归、支持向量机</p>
<p>非监督式学习：聚类、主成分分析PCA</p>
<p>深度学习：卷积神经网络、自编码器、循环神经网络</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/21.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/22.PNG" alt="22"></p>
<p>机器学习的三个步骤：搭建model（一系列函数），选择评价loss，选择最优的model</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/23.PNG" alt="23"></p>
<p>结构化学习：超出分类的问题，如seq2seq、机器翻译、语音辨识</p>
<p>半监督学习：少量带label数据和大量没有label的数据，让model从没有label的数据中获益</p>
<p>无监督学习：全为无label数据，如让机器画画、阅读文章等</p>
<p>强化学习：从惩罚或者批评中学习，而监督学习从老师学习，需要老师手把手交，显然强化学习更加智能</p>
<h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p><strong>让计算机从经验中学习，根据层次化的概念体系来理解世界，每个概念通过与相对简单的概念之间的关系定义。</strong></p>
<h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><p>一维数组，二维矩阵，三维张量</p>
<h4 id="雅可比Jacobian矩阵"><a href="#雅可比Jacobian矩阵" class="headerlink" title="雅可比Jacobian矩阵"></a>雅可比Jacobian矩阵</h4><p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/jacobian-1572707333030.PNG" alt="img"></p>
<h4 id="海森Hessian矩阵"><a href="#海森Hessian矩阵" class="headerlink" title="海森Hessian矩阵"></a>海森Hessian矩阵</h4><p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/hessian.PNG" alt="img"></p>
<h4 id="softmax函数（归一化指数函数）"><a href="#softmax函数（归一化指数函数）" class="headerlink" title="softmax函数（归一化指数函数）"></a>softmax函数（归一化指数函数）</h4><p>σ(z)j=ezj∑Kk=1ezk for j=1,…,Kσ(z)j=ezj∑k=1Kezk for j=1,…,K</p>
<p>观察到的数据属于某个类的概率,经常将其作为神经网络的输出层</p>
<h4 id="linear-algebra"><a href="#linear-algebra" class="headerlink" title="linear algebra"></a>linear algebra</h4><p>标量、向量、矩阵、张量</p>
<p>矩阵乘积、矩阵点积</p>
<p>单位矩阵、逆矩阵</p>
<p>生成子空间（列空间、值域）、线性相关（无关）、矩阵的奇异性</p>
<p>范数、欧几里得范数、最大范数</p>
<p>对角矩阵、正交矩阵、实对称矩阵</p>
<p>特征值、特征向量、矩阵的特征分解、实对称矩阵特征分解来优化二次方程</p>
<h3 id="DNN基础"><a href="#DNN基础" class="headerlink" title="DNN基础"></a>DNN基础</h3><p>感知机是神经网络的最小单元</p>
<h4 id="线性变化与仿射变换"><a href="#线性变化与仿射变换" class="headerlink" title="线性变化与仿射变换"></a>线性变化与仿射变换</h4><p><strong>线性变换</strong>：</p>
<ul>
<li>变换前是直线的，变换后依然是直线</li>
<li>直线比例保持不变</li>
<li>变换前是原点的，变换后依然是原点</li>
</ul>
<p><strong>仿射变换</strong>：线性变换+平移</p>
<ul>
<li><p>变换前是直线的，变换后依然是直线</p>
</li>
<li><p>直线比例保持不变</p>
</li>
<li><p>变换前是原点的，变换后依然是原点</p>
</li>
</ul>
<p>  y⃗ =Ax⃗ +b⃗ y→=Ax→+b→</p>
<p><strong>通过线性变换来完成仿射变换</strong></p>
<p>通过高维度的线性变换完成低维度的仿射变换：</p>
<p>[y⃗ 1]=[A0b⃗ 1][x⃗ 1][y→1]=[Ab→01][x→1]</p>
<p>假设某二维图形上每个点为x⃗ x→，则[x⃗ 1][x→1]表示将其平移到z=1z=1的平面上</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/v2-01d06795480b91a9bc1fa57ce5fd7009_hd.webp" alt="img"></p>
<p>线性不可分的样本在经过仿射变换后，仍然是不可分的</p>
<h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p>提供一组输入数据和其对应的标签数据，然后搭建一个模型，让模型在通过训练后准确地找到输入数据和标签数据之间的最优映射关系，在输入新的数据后，模型能够通过之前学到的最优映射关系， 快速地预测出这组新数据的标签。</p>
<h5 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h5><p>模型通过训练后得到一个连续的线性映射关系，i.e,根据离散的（房屋面积，房屋价格）之间的关系找到房屋价格与房屋面积间的连续函数关系</p>
<h5 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h5><p>模型通过训练后得到一个离散的线性映射关系，输出结果为有限个</p>
<h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>提供一组没有任何标签的输入数据，将其在我们搭建好的模型中进行训练，对整个训练过程不做任何干涉，最后得到一个能够发现数据之间隐藏特征的映射模型，使用这个映射模型能够实现对新数据的分类，使用无监督学习实现分类的算法叫做<strong>聚类</strong>。更具有创造性，有利于提高机器学习算法对新鲜样本的适应能力（泛化能力）。</p>
<p><strong>半监督学习、弱监督学习</strong>等创新方法也在出现。</p>
<h4 id="欠拟合、过拟合"><a href="#欠拟合、过拟合" class="headerlink" title="欠拟合、过拟合"></a>欠拟合、过拟合</h4><p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/2.png" alt="image-20191128224211081"></p>
<p>如图：a)为欠拟合，b)为过拟合，c）为正常训练出的模型</p>
<p>欠拟合：对已有数据的匹配性很差，但对数据中的噪声不敏感，不能对新数据准确预测</p>
<p>原因及解决方法：1）没有把握数据的主要特征，加入更多和原数据有重要相关性的特征来训练，2）增加函数次项来增加泛化能力，3）减少正则化参数:正则化参数是为了防止过拟合，若出现欠拟合，可减少正则化参数</p>
<p>过拟合：对数据的匹配性太好，对数据中的噪声特别敏感</p>
<p>解决方法：1）过度捕获了数据的有限特征，可增大训练的数据量，2）正则化：对目标函数增加一个参数范数惩罚，限制其学习能力</p>
<h4 id="后向传播"><a href="#后向传播" class="headerlink" title="后向传播"></a>后向传播</h4><h4 id="损失和优化"><a href="#损失和优化" class="headerlink" title="损失和优化"></a>损失和优化</h4><p><strong>损失函数</strong>:进行损失值计算的函数，均方误差（MSE)、均方根误差(RMSE)、平均绝对误差(MAE)</p>
<p>MSE=1N∑i=1N(yitrue −yipred )2MSE=1N∑i=1N(ytrue i−ypred i)2</p>
<p>RMSE=1N∑i=1N(yitrue −yipred )2−−−−−−−−−−−−−−−−−−⎷RMSE=1N∑i=1N(ytrue i−ypred i)2</p>
<p>MAE=1N∑i=1N∣∣(yitrue −yipred )∣∣MAE=1N∑i=1N|(ytrue i−ypred i)|</p>
<p><strong>优化函数</strong>：对模型参数进行优化的函数，解决参数初始化、参数微调形式、学习速率如何选取的方案的集合</p>
<p> 梯度：多元函数的偏导以向量的形式展示。</p>
<p> 常用优化函数：</p>
<p> <strong>1）全局梯度下降GD</strong>：模型的训练依赖整个训练集，增加了计算损失值的时间成本和模型训练过程的复杂度</p>
<p> <strong>2）批量梯度下降BGD</strong>：将训练集分成若干份，每个批次（batch）使用一次来进行梯度更新，可能会导致局部最优</p>
<p> <strong>3）随机梯度下降SGD</strong>：随机从数据集中选取一部分参与模型训练，可能导致局部最优，受噪声影响严重</p>
<p> <strong>4）Adam</strong>：损失值大时采用大的ηη,反之采用小的ηη，对梯度消失、收敛过慢、高方差的参数更新等导致的损失值波动均有很好的方法。ηη过大会导致局部最优和抖动，反之会使参数优化的时间变长</p>
<p> <strong>5）扰动—动量算法</strong></p>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>多层感知机无论多深，始终为线性，线性模型很难处理非线性问题，激活函数可带来非线性元素，抑制输出，便可近似拟合所有函数</p>
<h5 id="Logistic-sigmoid-函数"><a href="#Logistic-sigmoid-函数" class="headerlink" title="Logistic sigmoid 函数"></a>Logistic sigmoid 函数</h5><p>f(x)=11+e−xf(x)=11+e−x</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/logistic-1572783311445.PNG" alt="img"></p>
<p>与生物神经网络的工作机理非常相似，</p>
<p><strong>1）</strong>因dfdx∈(0∼0.25)dfdx∈(0∼0.25),会导致梯度消失（后向传播时每逆向经过一个节点，梯度值缩小为1/41/4,t梯度值越来越小）</p>
<p><strong>2）</strong>因f(x)&gt;0f(x)&gt;0,模型优化时收敛速度变慢，会增加时间成本，因此应尽量使用零中心数据，保证计算得到的输出结果是零中心数据</p>
<h5 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h5><p>f(x)=ex−e−xex+e−xf(x)=ex−e−xex+e−x</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/19.png" alt="img"></p>
<p>tanh输出结果是零中心数据，可解决收敛速度变慢的问题，但dfdx∈(0∼1)dfdx∈(0∼1),仍可能出现梯度消失，特别是x→−∞x→−∞或x→+∞x→+∞时，dfdx→0dfdx→0</p>
<h5 id="ReLU函数（修正线性单元）"><a href="#ReLU函数（修正线性单元）" class="headerlink" title="ReLU函数（修正线性单元）"></a>ReLU函数（修正线性单元）</h5><p>f(x)=max(0,x)f(x)=max(0,x)</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/20.PNG" alt="img"></p>
<p>分段线性、收敛速度非常快、无饱和问题、明显减轻梯度消失问题，但输出不是零中心数据，可能导致某些神经元永远不被激活，对应参数永远不被更新</p>
<p>解决方法：使用Xavier方法初始化参数</p>
<p>改进版本：Leaky—ReLU、R-ReLU</p>
<h3 id="李宏毅note"><a href="#李宏毅note" class="headerlink" title="李宏毅note"></a>李宏毅note</h3><p>DNN:深度神经网络</p>
<p>CNN：卷积神经网络</p>
<p>RNN：递归（循环）神经网络</p>
<p>LSTM：长短期记忆</p>
<h5 id="单层感知机模型实现与门、或门、非门"><a href="#单层感知机模型实现与门、或门、非门" class="headerlink" title="单层感知机模型实现与门、或门、非门"></a>单层感知机模型实现与门、或门、非门</h5><p>假定三个输入：x0=1,x1,x2x0=1,x1,x2,激活函数为用小于0时输出10，大于等于0时输出1</p>
<p>与门：输入均为1输出为1，其他输出为0，设定w0=−8,w1=5,w2=5w0=−8,w1=5,w2=5可实现</p>
<p>或门：有1为1，设定w0=−5,w1=8,w2=8w0=−5,w1=8,w2=8可实现</p>
<p>非门：去掉输入x2x2,设定w0=10,w1=20w0=10,w1=20可实现</p>
<p>异或门：单层只能处理线性可分问题，不能处理非线性问题，因此多层感知机诞生了。</p>
<h5 id="完全连接前馈网络"><a href="#完全连接前馈网络" class="headerlink" title="完全连接前馈网络"></a>完全连接前馈网络</h5><p>定义一组函数：</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/3-1573908546270.PNG" alt="3"></p>
<ul>
<li><p>给定参数 𝜃, 定义一个函数；给定网络结构，定义一个函数集</p>
</li>
<li><p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/4-1573908942871.PNG" alt="4"></p>
</li>
<li><p>f([1−1])=[0.620.83]f([1−1])=[0.620.83]</p>
</li>
</ul>
<p>深度学习的三个步骤：</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/frame.PNG" alt="img"></p>
<p>模型和数据的拟合：</p>
<ul>
<li>准备训练数据—图片及其标签</li>
<li>softmax层作为输出层，正确结果应对应输出层的最大值</li>
</ul>
<p>最优函数的选择：</p>
<ul>
<li>神经网络的两个参数：权重和偏差</li>
<li>损失是神经网络输出和目标之间的距离</li>
<li>最优的函数：找到使总损失最小的参数 𝜽</li>
<li>关键计算算是关于参数的偏导</li>
</ul>
<p>选择的方法：梯度下降 Backpropagation？</p>
<ul>
<li>选取W的初始值,计算w←w−η∂L/∂ww←w−η∂L/∂w,直到∂L/∂w∂L/∂w足够小</li>
<li>不能保证全局最小值，不同的初始点到达不同的初始值</li>
<li>反向传播是一种有效的计算∂L/∂w∂L/∂w的方法—深度学习框架</li>
<li><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/15.PNG" alt="img"></li>
<li>ηη可认为其参数值更新的快慢，即学习率</li>
</ul>
<h5 id="为什么使用深度神经网络"><a href="#为什么使用深度神经网络" class="headerlink" title="为什么使用深度神经网络"></a>为什么使用深度神经网络</h5><p>对于同样个数的神经元数量，浅胖或者深瘦？</p>
<p><strong>EX</strong>：深瘦：长短发，男孩女孩，浅胖：长发男孩、长发女孩、短法男孩、短法女孩</p>
<p>深瘦: 每个基础分类器都可以有足够的训练实例 浅胖：长发男孩样本少，没有足够的训练实例</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/2.PNG" alt="img"></p>
<h5 id="神经网络变体"><a href="#神经网络变体" class="headerlink" title="神经网络变体"></a>神经网络变体</h5><h6 id="卷积神经网络（CNN"><a href="#卷积神经网络（CNN" class="headerlink" title="卷积神经网络（CNN)"></a>卷积神经网络（CNN)</h6><p><strong>为什么CNN用于图像识别</strong></p>
<ol>
<li>当处理图像时，全连接网络的第一层将会非常大</li>
<li>一些模式比整张图片小得多（如：识别鸟嘴即可识别出鸟），神经元通过较少的参数连接到小区域去发现模式</li>
<li>同样的模式可能出现在图像的不同区域，不同区域的神经元可能相同</li>
<li>对图像进行二次采样不会改变图像中的物体、使图像变小（获取图像压缩比例、加载图像缩略图、避免图片加载时的OOM异常 ）</li>
<li><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/7.PNG" alt="7"></li>
</ol>
<p><strong>滤波器</strong></p>
<p>给定宽度和高度的滤波器，不同滤波器提取一个 patch 的不同特性。例如，一个滤波器寻找特定颜色，另一个寻找特定物体的特定形状。卷积层滤波器的数量被称为滤波器深度。</p>
<p><strong>图像的最大池化（Max Pooling）</strong></p>
<p>最大池化是基于样本的离散化过程。目的是对输入表示（图像，隐藏层输出矩阵等）进行下采样，以减小其尺寸，并允许对合并的子区域中包含的特征进行假设.</p>
<p>通过提供表示形式的抽象形式来帮助过度拟合。同样，它通过减少学习参数的数量来减少计算成本，并为内部表示提供基本的平移不变性 。下图为步长为2的最大池化：</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/5.PNG" alt="5"></p>
<p><strong>CNN整体结构</strong></p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/6.PNG" alt="6"></p>
<h6 id="循环神经网络（RNN"><a href="#循环神经网络（RNN" class="headerlink" title="循环神经网络（RNN)"></a>循环神经网络（RNN)</h6><p><strong>插槽填充</strong></p>
<p>输入序列向量化，将每一个输入的单词用向量表示，可以使用 One-of-N Encoding 或者是 Word hashing 等编码方法，输出预测槽位的概率分布</p>
<p><strong>1.1-of-N encoding</strong></p>
<p>向量是词典大小；每个维度对应于词典中的一个单词；这个词的维数是1，其他的是0；为了表示一些不知道的词汇，加入other这个维度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">词典 &#x3D; &#123;apple, bag, cat, dog, elephant&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.Word hashing</strong>（字串比对）</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/8.PNG" alt="8"></p>
<p>不同的序列如：arrive Taipei和leave Taipei，此时Taipei应该被放入不同的slot</p>
<p>因此引入具有记忆属性的RNN</p>
<p><strong>3.RNN（Elman Network）</strong></p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/9.PNG" alt="9"></p>
<p>变式：深层、双向（可以考虑整个sequence的input）、Jordan Network</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/10.PNG" alt="10"></p>
<p>输出是有目标的，因此Jordan Network表现更好</p>
<p><strong>4.LSTM（长短期记忆）</strong></p>
<p>一种特殊神经元机构：4 inputs，1 output，memory cell</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/11.PNG" alt="11"></p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/12.PNG" alt="12"></p>
<p>图中c′=g(z)f(zi)+cf(zf)c′=g(z)f(zi)+cf(zf),为memory cell的记忆更新值，激活函数使用sigmoid function，输出表示门的打开和关闭。输入向量点乘相应的权重向量得到输入、输出、以及遗忘“门”的输入通过激活函数的输出来决定“门”的开闭。</p>
<p><strong>5.Multiple-layer LSTM</strong></p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/13.png" alt="img"></p>
<p>一般的LSTM还靖上一层LSTM的memory cell的值、output与当前时刻的input合并为一个新的向量，再点乘相应权重向量，来控制该层LSTM。</p>
<p>Keras 支持LSTM、GRU（Gated Recurrent Unit、two gates、参数量少1/3、旧的不去新的不来）、SimpleRNN（memory不断被洗掉）</p>
<p><strong>6.RNN 训练技巧</strong></p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/14.PNG" alt="img"></p>
<p>原因：memory cell不断与权重乘积</p>
<p>导致的问题：</p>
<ol>
<li>当∂L/∂w∂L/∂w非常大时，梯度下降的参数更新会将参数抛出很远，导致lost异常增大，因此应选择衰减速度足够慢的学习率，避免上坡运动。</li>
<li>会出现梯度消失</li>
</ol>
<p><strong>解决方法：</strong></p>
<p><strong>截断梯度</strong>：在参数更新前，逐元素地截断<strong>小批量产生的参数梯度</strong>或<strong>截断梯度gg的范数</strong></p>
<p> if ∥g∥&gt;vg←gv∥g∥ if ‖g‖&gt;vg←gv‖g‖</p>
<p><strong>LSTM</strong>:可以解决梯度消失 (不能解决梯度爆炸)</p>
<ol>
<li>当forget gate打开时梯度永远不会消失</li>
</ol>
<p>GRU可将input gate与forget gate联动，只有一个gate可打开，只有将memory cell清掉，才能输入；或者没有输入时，memory cell才能更新</p>
<p><strong>clockwise RNN、Structurally Constrained Recurrent Network (SCRN)</strong></p>
<p><strong>7.应用</strong></p>
<ol>
<li><p>many to one :setiment analysis(情感分析)</p>
</li>
<li><p>many to many（output is shorter）:语音识别，通过Connectionist Temporal Classification (CTC)来剔除重复的声音vector对应的输出（添加null来隔开相同的输出）</p>
</li>
<li><p>many to many（No limition、sequence to sequence):机器翻译，EX：根据中文声音信号转成英文文字</p>
</li>
<li><p>beyond sequence: syntactic parsing(语法分析)</p>
</li>
<li><p>auto-encoder:<strong>Text</strong>:考虑文件或语句的顺序将其变为向量 <strong>Speech</strong>：将声音信号编码为向量</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/16.PNG" alt="img"></p>
<p>此时编码器和解码器同时工作，目标是使经过编码和解码后的输出与输入尽量相似。</p>
</li>
</ol>
<h6 id="注意力集中模型"><a href="#注意力集中模型" class="headerlink" title="注意力集中模型"></a>注意力集中模型</h6><p>Attention-based Model、Neural Turing machine</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/17.PNG" alt="img"></p>
<p><strong>应用</strong></p>
<p>Reading Comprehension、Visual Question Answering</p>
<p>EX：Speech Question Answering</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/18.png" alt="image-20191119214456154"></p>
<h4 id="RNN-vs-Structured-Learning"><a href="#RNN-vs-Structured-Learning" class="headerlink" title="RNN vs Structured Learning"></a>RNN vs Structured Learning</h4><h3 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h3><p>theano: 蒙特利尔大学蒙特利尔学习算法研究所开发</p>
<p>caffe: CAFFE是一个深度学习框架，最初开发于加利福尼亚大学伯克利分校。Caffe在BSD许可下开源，使用C++编写，带有Python接口</p>
<p>tensorflow: TensorFlow是一个开源软件库，用于各种感知和语言理解任务的机器学习</p>
<p>keras: Keras是一个用Python编写的开源神经网络库，能够在TensorFlow、Microsoft Cognitive Toolkit、Theano或PlaidML之上运行</p>
<p><img src="https://perfectism13.github.io/2019/11/16/Notes%20of%20Machine%20Learning/image-20191208211006443.png" alt="image-20191208211006443"></p>
<p>API风格：上方为命令式，趋于统一；下方为符号式</p>
<h3 id="深度学习与计算机视觉"><a href="#深度学习与计算机视觉" class="headerlink" title="深度学习与计算机视觉"></a>深度学习与计算机视觉</h3><p>图片分类（二分类、多分类），图像的目标识别，图像的语义分割、风格迁移</p>
]]></content>
  </entry>
  <entry>
    <title>Numpy 笔记</title>
    <url>/2020/07/24/Numpy%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Numpy-笔记"><a href="#Numpy-笔记" class="headerlink" title="Numpy 笔记"></a>Numpy 笔记</h1><h2 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numpy.transpose(a, axes&#x3D;None)</span><br><span class="line">#修改张量的维度</span><br><span class="line">&gt;&gt;&gt; x &#x3D; np.arange(4).reshape((2,2))</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">array([[0, 1],</span><br><span class="line">       [2, 3]])</span><br><span class="line">&gt;&gt;&gt; np.transpose(x)</span><br><span class="line">array([[0, 2],</span><br><span class="line">       [1, 3]])</span><br><span class="line">&gt;&gt;&gt; x &#x3D; np.ones((1, 2, 3))</span><br><span class="line">&gt;&gt;&gt; np.transpose(x, (1, 0, 2)).shape</span><br><span class="line">(2, 1, 3)</span><br></pre></td></tr></table></figure>
<h2 id="nonzero"><a href="#nonzero" class="headerlink" title="nonzero"></a>nonzero</h2><p>找到非零元素的下标</p>
<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.where(x&lt;0,0,x) #分段函数</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>PyTorch笔记</title>
    <url>/2020/07/24/PyTorch%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="PyTorch笔记"><a href="#PyTorch笔记" class="headerlink" title="PyTorch笔记"></a>PyTorch笔记</h1><p>PyTorch 1.3.0</p>
<h2 id="数据类型Tensor"><a href="#数据类型Tensor" class="headerlink" title="数据类型Tensor"></a>数据类型Tensor</h2><h3 id="浮点型、整型"><a href="#浮点型、整型" class="headerlink" title="浮点型、整型"></a>浮点型、整型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">a &#x3D; torch.FloatTensor(2,3) #按照指定维度随机生成浮点型tensor</span><br><span class="line">b &#x3D; torch.FloatTensor([2,3,4,5]) #按照给定列表生成浮点型tensor</span><br><span class="line">a &#x3D; torch.IntTensor(2,3) #整型同上</span><br><span class="line">b &#x3D; torch.IntTensor([2,3,4,5])</span><br></pre></td></tr></table></figure>
<h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; torch.rand(2,3) #生成0到1之间的随机浮点型tensor</span><br><span class="line">a &#x3D; torch.randn(2,3) #生成0到1之间的随机浮点型tensor，满足均值为0，方差为1</span><br><span class="line">a &#x3D; torch.arange(1,20,1) #生成一个等差数组，输入为起始值、结束值、步长</span><br><span class="line">a &#x3D; torch.zeros(2,3) #生成全0 tesnor</span><br><span class="line">x &#x3D; torch.zeros(5, 3, dtype&#x3D;torch.long)</span><br><span class="line">x &#x3D; torch.empty(5, 3) #创建一个5x3的未初始化的Tensor</span><br><span class="line">print(x.size()) #获取tensor的形状，torch.size为一个tuple</span><br><span class="line">print(x.shape)</span><br></pre></td></tr></table></figure>
<h2 id="tensor运算"><a href="#tensor运算" class="headerlink" title="tensor运算"></a>tensor运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &#x3D; torch.abs(a) #取绝对值</span><br><span class="line">c &#x3D; torch.add(a,b) #两tensor相加</span><br><span class="line">e &#x3D; torch.add(c,10) #tensor与scalar相加</span><br><span class="line">b &#x3D; torch.clamp(a, -0.1, 0.1) #以-0.1为下边界，0.1为上边界将a截断</span><br><span class="line">c &#x3D; torch.div(a,b) #两tensor的元素相除。a&#x2F;b</span><br><span class="line">e &#x3D; torch.div(d,10) #tensor与scalar相除</span><br><span class="line">c &#x3D; torch.mul(a,b) #两tensor的元素求积，同上</span><br><span class="line">e &#x3D; torch.mul(d,10)</span><br><span class="line">b &#x3D; torch.pow(a, 2) #tesnor元素指数运算</span><br><span class="line">c &#x3D; torch.mm(a, b) #两tenssor进行矩阵乘法运算</span><br><span class="line">c &#x3D; torch.mv(a, b) #a tensor与b向量乘积</span><br></pre></td></tr></table></figure>
<h2 id="第一个神经网络"><a href="#第一个神经网络" class="headerlink" title="第一个神经网络"></a>第一个神经网络</h2><p>【输入层100x1000】x【权重w1矩阵1000x100】= 【隐藏层输出100x100】</p>
<p>【隐藏层输出100x100】x 【权重w2矩阵100x10】= 【输出层输出100x10】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">batch_n &#x3D; 100</span><br><span class="line">hidden_layer &#x3D; 100</span><br><span class="line">input_data &#x3D; 1000</span><br><span class="line">output_data &#x3D; 10</span><br><span class="line"></span><br><span class="line">x &#x3D; torch.randn(batch_n, input_data)</span><br><span class="line">y &#x3D; torch.randn(batch_n, output_data)</span><br><span class="line">w1 &#x3D; torch.randn(input_data, hidden_layer)</span><br><span class="line">w2 &#x3D; torch.randn(hidden_layer, output_data)</span><br><span class="line"></span><br><span class="line">epoch_n &#x3D; 30</span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    h1 &#x3D; x.mm(w1) #100*1000</span><br><span class="line">    h1 &#x3D; h1.clamp(min &#x3D; 0) #加上ReLU激活函数</span><br><span class="line">    y_pred &#x3D; h1.mm(w2) #100*10</span><br><span class="line">    loss &#x3D; (y_pred - y).pow(2).sum()</span><br><span class="line">    print(&quot;Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;&quot;.format(epoch,loss))</span><br><span class="line">    grad_y_pred &#x3D; 2*(y_pred - y)</span><br><span class="line">    grad_w2 &#x3D; h1.t().mm(grad_y_pred) #链式求导</span><br><span class="line">    grad_h &#x3D; grad_y_pred.clone()</span><br><span class="line">    grad_h &#x3D; grad_h.mm(w2.t())</span><br><span class="line">    grad_h.clamp_(min&#x3D;0)</span><br><span class="line">    grad_w1 &#x3D; x.t().mm(grad_h)</span><br><span class="line">    w1 -&#x3D; learning_rate*grad_w1</span><br><span class="line">    w2 -&#x3D; learning_rate*grad_w2</span><br></pre></td></tr></table></figure>
<p>w1=h1,h1w2=ypw1=h1,h1w2=yp</p>
<p>∂L∂w2=∂(yp−y)2∂ypypw2=2(y2−y)[h1]T∂L∂w2=∂(yp−y)2∂ypypw2=2(y2−y)[h1]T</p>
<p>通过前向传播和后向传播实现了对模型的训练和对权重参数的优化</p>
<h2 id="自动梯度"><a href="#自动梯度" class="headerlink" title="自动梯度"></a>自动梯度</h2><h3 id="autograd与自定义传播函数"><a href="#autograd与自定义传播函数" class="headerlink" title="autograd与自定义传播函数"></a>autograd与自定义传播函数</h3><p>计算图：每一个节点表示一个变量，变量可以是任何类型，只是将计算形式化为图形的方法之一</p>
<p>操作：一个或多个变量的简单函数</p>
<p>解决∂L/∂W∂L/∂W的复杂链式求解问题，<strong>最新版已不需要使用<code>torch.autograd</code>包中的<code>Variabale</code>类对输入的tensor数据进行封装</strong>。用X 来代表我们选中的节点，那么<code>X.data</code>代表Tensor 数据类型的变量， <code>X.grad</code>也是一个Variable 对象，不过它表示的是X 的梯度，访问梯度值时需要使用<code>X.grad.data</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">#from torch.autograd import Variable</span><br><span class="line">batch_n &#x3D; 100</span><br><span class="line">hidden_layer &#x3D; 100</span><br><span class="line">input_data &#x3D; 1000</span><br><span class="line">output_data &#x3D; 10</span><br><span class="line"></span><br><span class="line">class Model(torch.nn.Module): #继承torch.nn.Module类</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">    </span><br><span class="line">    def forward(self, input, w1, w2): #实现前向传播的矩阵运算</span><br><span class="line">        x &#x3D; torch.mm(input, w1)</span><br><span class="line">        x &#x3D; torch.clamp(x, min &#x3D; 0)</span><br><span class="line">        x &#x3D;torch.mm(x, w2)</span><br><span class="line">        return x</span><br><span class="line">    </span><br><span class="line">    def backward(self): #实现后向传播的自动梯度计算</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">model &#x3D; Model()</span><br><span class="line"></span><br><span class="line">#x &#x3D; Variable(torch.randn(batch_n, input_data), requires_grad &#x3D; False)</span><br><span class="line">#y &#x3D; Variable(torch.randn(batch_n, output_data), requires_grad &#x3D; False)</span><br><span class="line">x &#x3D; torch.randn((batch_n, input_data), requires_grad &#x3D; False) #autograd不会保留梯度值</span><br><span class="line">y &#x3D; torch.randn((batch_n, output_data), requires_grad &#x3D; False)</span><br><span class="line"></span><br><span class="line">#w1 &#x3D; Variable(torch.randn(input_data, hidden_layer), requires_grad &#x3D; True)</span><br><span class="line">#w2 &#x3D; Variable(torch.randn(hidden_layer, output_data), requires_grad &#x3D; True)</span><br><span class="line">w1 &#x3D; torch.randn((input_data, hidden_layer), requires_grad &#x3D; True) #autograd保留梯度值</span><br><span class="line">w2 &#x3D; torch.randn((hidden_layer, output_data), requires_grad &#x3D; True)</span><br><span class="line"></span><br><span class="line">epoch_n &#x3D; 20</span><br><span class="line">learning_rate &#x3D; 1e-6</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    #y_pred &#x3D; model(x,w1,w2) #完成神经网络的搭建</span><br><span class="line">    y_pred &#x3D; x.mm(w1).clamp(min &#x3D; 0).mm(w2)</span><br><span class="line">    loss &#x3D; (y_pred - y).pow(2).sum()</span><br><span class="line">    print(&quot;Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;&quot;.format(epoch,loss.data))</span><br><span class="line">    </span><br><span class="line">    loss.backward() #根据设定求loss对各计算节点的梯度</span><br><span class="line">    </span><br><span class="line">    w1.data -&#x3D; learning_rate*w1.grad.data</span><br><span class="line">    w2.data -&#x3D; learning_rate*w2.grad.data</span><br><span class="line">    </span><br><span class="line">    w1.grad.data.zero_() #将梯度清零，否则计算的梯度会累加</span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure>
<p><img src="https://perfectism13.github.io/2019/11/23/PyTorch%E7%AC%94%E8%AE%B0/1.png" alt="image-20191124170522501"></p>
<h2 id="模型搭建和参数优化"><a href="#模型搭建和参数优化" class="headerlink" title="模型搭建和参数优化"></a>模型搭建和参数优化</h2><h3 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h3><p>torch.nn 包提供了很多与实现神经网络中的具体功能相关的类,比如神经网络中的卷积层、池化层、全连接层这类层次构造的方法、防止过拟合的参数归一化方法、Dropout 方法，还有激活函数部分的线性激活函数、非线性激活函数相关的方法等</p>
<p>实现自动前向传播、后向传播、生成权重和偏置、损失函数的自动计算。</p>
<h4 id="torch-nn中模型搭建的常用类"><a href="#torch-nn中模型搭建的常用类" class="headerlink" title="torch.nn中模型搭建的常用类"></a>torch.nn中模型搭建的常用类</h4><p>1.<code>torch.nn.Sequential</code></p>
<p>一种序列容器，通过在容器中嵌套各种实现神经网络中具体功能相关的类，来完成对神经网络模型的搭建</p>
<p>模块加入的两种方式：1.按照代码顺序直接嵌套，默认使用从零开始的数字序列作为每个模块的名字。2.以<code>orderdict</code>有序字典的方式传入，模型的每个模块都有我们自定义的名字</p>
<p>2.<code>torch.nn.Linear</code></p>
<p>输入：输入特征数、输出特征数、是否使用偏置，一般输入前两个会自动生成权重参数和偏置.</p>
<p>3.<code>torch.nn.ReLU</code>非线性激活函数类，<code>Sigmoid</code>,<code>Softmax</code>,<code>PReLU</code>,<code>LeakyRLU</code>,<code>Tanh</code>等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hidden_layer &#x3D; 100</span><br><span class="line">input_data &#x3D; 1000</span><br><span class="line">output_data &#x3D; 10</span><br><span class="line">#按照代码顺序直接嵌套</span><br><span class="line">models &#x3D; torch.nn.Sequential(</span><br><span class="line">torch.nn.Linear(input_data, hidden_layer),</span><br><span class="line">torch.nn.ReLU(),</span><br><span class="line">torch.nn.Linear(hidden_layer, output_data)</span><br><span class="line">)</span><br><span class="line">#以有序字典的方式传入</span><br><span class="line">from collections import OrderedDict</span><br><span class="line">models &#x3D; torch.nn.Sequential(OrderedDict([</span><br><span class="line">(&quot;Line1&quot;,torch.nn.Linear(input_data, hidden_layer)),</span><br><span class="line">(&quot;Relu1&quot;,torch.nn.ReLU()),</span><br><span class="line">(&quot;Line2&quot;,torch.nn.Linear(hidden_layer, output_data))])</span><br><span class="line">)</span><br><span class="line">print(models)</span><br></pre></td></tr></table></figure>
<h4 id="torch-nn中损失函数计算的常用类"><a href="#torch-nn中损失函数计算的常用类" class="headerlink" title="torch.nn中损失函数计算的常用类"></a>torch.nn中损失函数计算的常用类</h4><p>1.<code>torch.nn.MSELoss</code>均方误差函数，Mean Square Error，预测值与真实值之差的平方的期望值</p>
<p><code>torch.nn.L1Loss</code>平均绝对误差函数，预测值与真实值之差的绝对值的平均值</p>
<p><code>torch.nn.CrossEntropyLoss</code>交叉熵</p>
<p>C=−1n∑x∑j[yjlnaLj+(1−yj)ln(1−aLj)]C=−1n∑x∑j[yjln⁡ajL+(1−yj)ln⁡(1−ajL)]</p>
<p>其中aa是输出，yy是真实的标签</p>
<h4 id="使用torch-nn搭建模型"><a href="#使用torch-nn搭建模型" class="headerlink" title="使用torch.nn搭建模型"></a>使用torch.nn搭建模型</h4><p>通过对<code>models.parameters()</code>的遍历来实现每个参数的更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">#from torch.autograd import Variable</span><br><span class="line">batch_n &#x3D; 100</span><br><span class="line">hidden_layer &#x3D; 100</span><br><span class="line">input_data &#x3D; 1000</span><br><span class="line">output_data &#x3D; 10</span><br><span class="line">x &#x3D; torch.randn((batch_n, input_data), requires_grad &#x3D; False)</span><br><span class="line">#x &#x3D; Variable(torch.randn(batch_n, input_data), requires_grad &#x3D; False)</span><br><span class="line">y &#x3D; Variable(torch.randn(batch_n, output_data), requires_grad &#x3D; False)</span><br><span class="line"></span><br><span class="line">models &#x3D; torch.nn.Sequential(</span><br><span class="line">torch.nn.Linear(input_data, hidden_layer),</span><br><span class="line">torch.nn.ReLU(),</span><br><span class="line">torch.nn.Linear(hidden_layer, output_data)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">epoch_n &#x3D; 10000</span><br><span class="line">learning_rate &#x3D; 1e-4</span><br><span class="line">loss_fn &#x3D; torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    y_pred &#x3D; models(x)</span><br><span class="line">    loss &#x3D; loss_fn(y_pred, y)</span><br><span class="line">    if epoch%1000 &#x3D;&#x3D; 0:</span><br><span class="line">        print(&quot;Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;&quot;.format(epoch,loss.data))</span><br><span class="line">    models.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    for param in models.parameters():</span><br><span class="line">        param.data -&#x3D; param.grad.data*learning_rate</span><br></pre></td></tr></table></figure>
<h3 id="参数自动优化—torch-optim"><a href="#参数自动优化—torch-optim" class="headerlink" title="参数自动优化—torch.optim"></a>参数自动优化—torch.optim</h3><p>固定的学习速率—参数优化更新没有自动化导致的问题，学习率是难以设置的超参数之一</p>
<p>解决方案：1.动量算法—引入另一超参数</p>
<p> 2.自适应学习率算法：SGD、AdaGrad、RMSProp、Adam等</p>
<p> 3.二阶近似算法</p>
<p> 4.元算法</p>
<p><code>torch.optim.Adam</code>类的输入:被优化的参数、学习速率的初始值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">batch_n &#x3D; 100</span><br><span class="line">hidden_layer &#x3D; 100</span><br><span class="line">input_data &#x3D; 1000</span><br><span class="line">output_data &#x3D; 10</span><br><span class="line"></span><br><span class="line">x &#x3D; torch.randn((batch_n, input_data), requires_grad &#x3D; False)</span><br><span class="line">y &#x3D; torch.randn((batch_n, output_data), requires_grad&#x3D;False)</span><br><span class="line"></span><br><span class="line">models &#x3D; torch.nn.Sequential(</span><br><span class="line">torch.nn.Linear(input_data, hidden_layer), #w1</span><br><span class="line">torch.nn.ReLU(), #激活函数</span><br><span class="line">torch.nn.Linear(hidden_layer, output_data) #w2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">epoch_n &#x3D; 300</span><br><span class="line">learning_rate &#x3D; 1e-4</span><br><span class="line">loss_fn &#x3D; torch.nn.MSELoss() #损失函数计算</span><br><span class="line">optimzer &#x3D; torch.optim.Adam(models.parameters(), lr &#x3D; learning_rate) #定义学习速率自动调节类</span><br><span class="line"></span><br><span class="line">for epoch in range(epoch_n):</span><br><span class="line">    y_pred &#x3D; models(x)</span><br><span class="line">    loss &#x3D; loss_fn(y_pred, y)</span><br><span class="line">    print(&quot;Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;&quot;.format(epoch,loss.data))</span><br><span class="line">    optimzer.zero_grad() #参数梯度归零</span><br><span class="line">    loss.backward() #自动求解梯度</span><br><span class="line">    optimzer.step() #各个参数进行梯度更新</span><br></pre></td></tr></table></figure>
<h2 id="向计算机视觉出击—MNIST"><a href="#向计算机视觉出击—MNIST" class="headerlink" title="向计算机视觉出击—MNIST"></a>向计算机视觉出击—MNIST</h2><p><code>torchvision</code>包可以实现数据的处理、导入和预览</p>
<h3 id="torchvision-datasets—数据集的准备"><a href="#torchvision-datasets—数据集的准备" class="headerlink" title="torchvision.datasets—数据集的准备"></a>torchvision.datasets—数据集的准备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform&#x3D;transforms.Compose([transforms.ToTensor(),</span><br><span class="line">                              transforms.Normalize(mean&#x3D;[0.5],std&#x3D;[0.5])])</span><br><span class="line"></span><br><span class="line">data_train &#x3D; datasets.MNIST(root &#x3D; &quot;D:&#x2F;learning program&#x2F;source_data_MNIST&#x2F;&quot;,</span><br><span class="line">                            transform&#x3D;transform, #需提前定义对于数据的变换操作</span><br><span class="line">                            train &#x3D; True, #设置为true表示训练集，设置为false表示测试集</span><br><span class="line">                            download &#x3D; True)</span><br><span class="line"></span><br><span class="line">data_test &#x3D; datasets.MNIST(root&#x3D;&quot;D:&#x2F;learning program&#x2F;source_data_MNIST&#x2F;&quot;,</span><br><span class="line">                           transform&#x3D;transform,</span><br><span class="line">                           train &#x3D; False)</span><br></pre></td></tr></table></figure>
<h3 id="torchvision-transforms—数据的变换"><a href="#torchvision-transforms—数据的变换" class="headerlink" title="torchvision.transforms—数据的变换"></a>torchvision.transforms—数据的变换</h3><p>图片类型转换成tensor类型、图片数据有限时可通过变换生成训练集（缩小放大、水平垂直反转）</p>
<p><code>torch.transforms.Compose</code>类是一种容器，可将对数据的变换进行组合，传入的参数是一个列表，列表中的元素就是对载入的数据进行的各种变换操作</p>
<ol>
<li><code>torch.transforms.ToTensor</code>将数据转换为tensor类型</li>
<li><code>transforms.ToTensor</code>标准差转换，使用原始数据的均值和标准差进行标准化，即概率论中的一般正态分布的标准化x=x−meanstdx=x−meanstd</li>
<li><code>transforms.Resize</code>缩放，输入<code>(h,w)</code>序列或<code>int</code>, i.e, if height &gt; width, then image will be rescaled to (size * height / width, size) ,<code>transforms.Scale</code>与其类似</li>
<li><code>transforms.CenterCrop</code>图片以中心为参考点进行裁剪，输入同上，<code>transforms.RandomCrop</code>与其类似</li>
<li><code>transforms.RandomHorizontalFlip</code>自定义随机概率水平翻转，默认0.5，<code>.transforms.RandomVerticalFlip</code>类似</li>
<li><code>transforms. ToPILlmage</code>将tensor转换成PIL图片，便于显示</li>
</ol>
<h3 id="数据预览和装载"><a href="#数据预览和装载" class="headerlink" title="数据预览和装载"></a>数据预览和装载</h3><h4 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h4><p>将图片处理之后打包,使用<code>torch.utils.data.DataLoader</code>类进行数据装载，<code>dataset</code>指定载入的数据集名称 <code>batch_size</code>是每个包的大小，<code>shuffle</code>是否在装载时打乱图片的顺序</p>
<p>每个批次的装载数据是四维的？<code>(batch_size,channel,height,width)</code> labels?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_loader_train &#x3D; torch.utils.data.DataLoader(dataset&#x3D;data_train,</span><br><span class="line">                                                batch_size &#x3D; 64,</span><br><span class="line">                                                shuffle &#x3D; True,</span><br><span class="line">                                               )</span><br><span class="line"></span><br><span class="line">data_loader_test &#x3D; torch.utils.data.DataLoader(dataset&#x3D;data_test,</span><br><span class="line">                                               batch_size &#x3D; 64,</span><br><span class="line">                                               shuffle &#x3D; True)</span><br></pre></td></tr></table></figure>
<h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">images, labels &#x3D; next(iter(data_loader_train)) #迭代</span><br><span class="line"></span><br><span class="line">img &#x3D; torchvision.utils.make_grid(images) #将一个批次的图像构造成网络模式，图片维度为（channel,height,width）</span><br><span class="line">img &#x3D; img.numpy().transpose(1,2,0) #将维度变为（height,width，channel），matplotlib只支持这种格式</span><br><span class="line"># np.transpose(img,(1,2,0))</span><br><span class="line"></span><br><span class="line">std &#x3D; [0.5]</span><br><span class="line">mean &#x3D; [0.5]</span><br><span class="line">img &#x3D; img*std+mean</span><br><span class="line">print([labels[i] for i in range(64)])</span><br><span class="line">plt.imshow(img)</span><br></pre></td></tr></table></figure>
<h3 id="模型搭建和参数优化-1"><a href="#模型搭建和参数优化-1" class="headerlink" title="模型搭建和参数优化"></a>模型搭建和参数优化</h3><h4 id="卷积层的搭建"><a href="#卷积层的搭建" class="headerlink" title="卷积层的搭建"></a>卷积层的搭建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride&#x3D;1, padding&#x3D;0, dilation&#x3D;1, groups&#x3D;1, bias&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>输入：输入通道数、输出通道数、卷积核大小、卷积核移动步长、padding值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel_size&#96;, &#96;stride&#96;, &#96;padding&#96;, &#96;dilation&#96;均支持&#96;int&#96;或&#96;tuple&#96;输入形式其中 &#96;tuple&#96;为&#96;(h,w)</span><br></pre></td></tr></table></figure>
<p>i.e,<code>torch.nn.Conv2d(64,128,kernel_size=3,stride=1,padding=1)</code>,即用128个3x3x64的卷积核对输入的64个通道进行卷积操作，最后输出128个通道的图像。</p>
<h4 id="池化层的搭建"><a href="#池化层的搭建" class="headerlink" title="池化层的搭建"></a>池化层的搭建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">torch.nn.MaxPool2d(kernel_size, stride&#x3D;None, padding&#x3D;0, dilation&#x3D;1, return_indices&#x3D;False, ceil_mode&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>输入：池化窗口大小、移动步长、padding值</p>
<h4 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">torch.nn.Dropout(p&#x3D;0.5, inplace&#x3D;False)</span><br></pre></td></tr></table></figure>
<p>可使在每轮模型训练过程中，以一定概率将部分参数归零来减少相邻两层神经连接使最后训练出的模型对各部分权重参数不产生过度依赖，防止过拟合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Model(torch.nn.Module):</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        self.conv1&#x3D;torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(1,64,kernel_size&#x3D;3,stride&#x3D;1,padding&#x3D;1),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Conv2d(64,128,kernel_size&#x3D;3,stride&#x3D;1,padding&#x3D;1),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride&#x3D;2,kernel_size&#x3D;2))</span><br><span class="line">        self.dense&#x3D;torch.nn.Sequential(</span><br><span class="line">            torch.nn.Linear(14*14*128,1024),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Dropout(p&#x3D;0.5),</span><br><span class="line">            torch.nn.Linear(1024, 10))</span><br><span class="line">        </span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x &#x3D; self.conv1(x)</span><br><span class="line">        x &#x3D; x.view(-1, 14*14*128) #输入全连接层前，将数据扁平化</span><br><span class="line">        x &#x3D; self.dense(x)</span><br><span class="line">        return x</span><br><span class="line">model &#x3D; Model()</span><br><span class="line">cost &#x3D; torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(model.parameters())</span><br></pre></td></tr></table></figure>
<h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n_epochs &#x3D; 1</span><br><span class="line"></span><br><span class="line">for epoch in range(n_epochs):</span><br><span class="line">    running_loss &#x3D; 0.0</span><br><span class="line">    running_correct &#x3D; 0</span><br><span class="line">    print(&quot;Epoch &#123;&#125;&#x2F;&#123;&#125;&quot;.format(epoch, n_epochs))</span><br><span class="line">    print(&quot;-&quot;*10)</span><br><span class="line">    </span><br><span class="line">    for data in data_loader_train:</span><br><span class="line">        X_train, y_train &#x3D; data</span><br><span class="line">        X_train, y_train &#x3D; Variable(X_train), Variable(y_train)</span><br><span class="line">        outputs &#x3D; model(X_train)</span><br><span class="line">        _,pred &#x3D; torch.max(outputs.data, 1)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss &#x3D; cost(outputs, y_train)</span><br><span class="line">        </span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()     </span><br><span class="line">        running_loss +&#x3D; loss.data</span><br><span class="line">        running_correct +&#x3D; torch.sum(pred &#x3D;&#x3D; y_train.data)</span><br><span class="line"></span><br><span class="line">    testing_correct &#x3D; 0    </span><br><span class="line">    for data in data_loader_test:</span><br><span class="line">        X_test, y_test &#x3D; data</span><br><span class="line">        X_test, y_test &#x3D; Variable(X_test), Variable(y_test)</span><br><span class="line">        outputs &#x3D; model(X_test)</span><br><span class="line">        _, pred &#x3D; torch.max(outputs.data, 1)</span><br><span class="line">        testing_correct +&#x3D; torch.sum(pred &#x3D;&#x3D; y_test.data)</span><br><span class="line">    print(&quot;Loss is:&#123;:.4f&#125;, Train Accuracy is:&#123;:.4f&#125;%, Test Accuracy is:&#123;:.4f&#125;&quot;.format(running_loss&#x2F;len(data_train),100*running_correct&#x2F;len(data_train),</span><br><span class="line">                 100*testing_correct&#x2F;len(data_test)))</span><br></pre></td></tr></table></figure>
<h4 id="随机选取测试集数据测试"><a href="#随机选取测试集数据测试" class="headerlink" title="随机选取测试集数据测试"></a>随机选取测试集数据测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_loader_test &#x3D; torch.utils.data.DataLoader(dataset&#x3D;data_test,</span><br><span class="line">                                               batch_size &#x3D; 4,</span><br><span class="line">                                               shuffle &#x3D; True)</span><br><span class="line"></span><br><span class="line">X_test, y_test &#x3D; next(iter(data_loader_test))</span><br><span class="line">inputs &#x3D; Variable(X_test)</span><br><span class="line">pred &#x3D; model(inputs)</span><br><span class="line">_,pred &#x3D; torch.max(pred, 1)</span><br><span class="line">print(&quot;Predict Label is:&quot;, [ i for i in pred.data])</span><br><span class="line">print(&quot;Real Label is:&quot;,[i for i in y_test])</span><br><span class="line"></span><br><span class="line">img &#x3D; torchvision.utils.make_grid(X_test)</span><br><span class="line">img &#x3D; img.numpy().transpose(1,2,0)</span><br><span class="line"></span><br><span class="line">std &#x3D; [0.5,0.5,0.5]</span><br><span class="line">mean &#x3D; [0.5,0.5,0.5]</span><br><span class="line">img &#x3D; img*std+mean</span><br><span class="line">plt.imshow(img)</span><br></pre></td></tr></table></figure>
<h2 id="动态图还是静态图"><a href="#动态图还是静态图" class="headerlink" title="动态图还是静态图"></a>动态图还是静态图</h2><p>对于使用者来说，两种形式的计算图有着非常大的区别，同时静态图和动态图都有他们各自的优点，比如动态图比较方便debug，使用者能够用任何他们喜欢的方式进行debug，同时非常直观，而静态图是通过先定义后运行的方式，之后再次运行的时候就不再需要重新构建计算图，所以速度会比动态图更快。</p>
]]></content>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2020/07/24/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Python学习笔记"><a href="#Python学习笔记" class="headerlink" title="Python学习笔记"></a>Python学习笔记</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">print(&quot;-&quot;*10)</span><br><span class="line">print(&quot;hello&quot;,&quot;world&quot;)</span><br><span class="line">#打印变量值</span><br><span class="line">print(&quot;width : %s, height : %s channels : %s&quot; % (width, height, channels))</span><br><span class="line">#打印矩阵</span><br><span class="line">print(image)</span><br></pre></td></tr></table></figure>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>代码缩进：python对代码缩进的要求非常严格</p>
<h3 id="多行语句的分割"><a href="#多行语句的分割" class="headerlink" title="多行语句的分割"></a>多行语句的分割</h3><p>使用<code>\</code>将代码分割成多行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;Hello,World.Hello,World.\</span><br><span class="line">Hello,World.Hello,World.&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string1 &#x3D; string2 &#x3D; string3 &#x3D; &quot;Hello,World&quot;</span><br><span class="line">string1, string2, string3 &#x3D; &quot;Hello&quot;, &quot;World&quot;,&quot;Hello,World&quot;</span><br></pre></td></tr></table></figure>
<h3 id="数据类型及其索引"><a href="#数据类型及其索引" class="headerlink" title="数据类型及其索引"></a>数据类型及其索引</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float_num &#x3D; 10.000</span><br><span class="line"></span><br><span class="line">print(float_num)</span><br><span class="line">print(&quot;%f&quot; % float_num)</span><br><span class="line">print(&quot;%.2f&quot; % float_num)</span><br><span class="line">print(&quot;%.4f&quot; % float_num)</span><br><span class="line">#ouput</span><br><span class="line">10.0</span><br><span class="line">10.000000</span><br><span class="line">10.00</span><br><span class="line">10.0000</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string &#x3D; &#39;Hello,World&#39; #双引号也可以</span><br><span class="line">string1 &#x3D; string[0:11]</span><br><span class="line">string2 &#x3D; string[0:5]</span><br><span class="line">string6 &#x3D; string[:5] #注意第五个字符不显示</span><br><span class="line">string3 &#x3D; string[-1]</span><br><span class="line">string4 &#x3D; string[-5:-1]</span><br><span class="line">#ouput</span><br><span class="line">Hello,World</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">d</span><br><span class="line">worl</span><br></pre></td></tr></table></figure>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是一种容器型数据类型，可以实现多种数据类型的嵌套，元素可重新赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [ &quot;Hello,World&quot;, 100 , 10.00 ]</span><br><span class="line">list2 &#x3D; [123, &#39;Hi&#39;]</span><br><span class="line"></span><br><span class="line">print(list1) # 输出整个list1 列表元素</span><br><span class="line">print(list1[0]) # 输出列表的第1 个元素</span><br><span class="line">print(list1[1:]) # 输出从第1 个索引开始至列表末尾的所有元素</span><br><span class="line">print(list1[-1]) # 输出列表的最后一个元素</span><br><span class="line">print(list1 + list2) # 输出列表的组合</span><br><span class="line">list1[0] &#x3D; &quot;0&quot;</span><br><span class="line">print(list1)</span><br><span class="line">#output</span><br><span class="line">[&#39;Hello,World&#39;, 100, 10.0]</span><br><span class="line">Hello,World</span><br><span class="line">[100, 10.0]</span><br><span class="line">10.0</span><br><span class="line">[&#39;Hello,World&#39;, 100, 10.0, 123, &#39;Hi&#39;]</span><br><span class="line">[&#39;0&#39;, 100, 10.0]</span><br></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>另一种容器型数据类型，基本性质、索引值操作与列表相同，但其元素不能重新赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple1 &#x3D; ( &quot;Hello,World&quot;, 100 , 10.00 )</span><br><span class="line">tuple2 &#x3D; (123, &#39;Hi&#39;)</span><br><span class="line">print(list1) # 输出整个tuple1 列表元素</span><br></pre></td></tr></table></figure>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>列表与元组为有序的元素组合，字典通过键值来操控元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_info &#x3D; &#123;&quot;name&quot;: &quot;Tang&quot;, &quot;num&quot;:7272, &quot;city&quot;: &quot;GL&quot;&#125;</span><br><span class="line">dict_info[&quot;city&quot;] &#x3D; &quot;changsha&quot;</span><br><span class="line"></span><br><span class="line">print (dict_info) # 输出整个dict_info 字典</span><br><span class="line">print(dict_info[&quot;city&quot;])</span><br><span class="line">print (dict_info.keys()) # 输出dict_info 的所有键值</span><br><span class="line">print (dict_info.values()) # 输出dict_info 的所有值</span><br><span class="line"></span><br><span class="line">#output</span><br><span class="line">&#123;&#39;name&#39;: &#39;Tang&#39;, &#39;num&#39;: 7272, &#39;city&#39;: &#39;changsha&#39;&#125;</span><br><span class="line">changsha</span><br><span class="line">dict_keys([&#39;name&#39;, &#39;num&#39;, &#39;city&#39;])</span><br><span class="line">dict_values([&#39;Tang&#39;, 7272, &#39;changsha&#39;])</span><br></pre></td></tr></table></figure>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>构造一个元组</p>
<h2 id="面向对象的方法-类"><a href="#面向对象的方法-类" class="headerlink" title="面向对象的方法-类"></a>面向对象的方法-类</h2><p>类是用来描述具有相同属性和方法的对象的集合，定义了该集合中每个对象的共有属性和方法，对象是类的实例</p>
<h3 id="类的创建、继承与重写"><a href="#类的创建、继承与重写" class="headerlink" title="类的创建、继承与重写"></a>类的创建、继承与重写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class People:</span><br><span class="line">    </span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        </span><br><span class="line">    def dis_name(self):</span><br><span class="line">        print(&quot;name is:&quot;,self.name)</span><br><span class="line"></span><br><span class="line">    def set_age(self, age):</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        </span><br><span class="line">    def dis_age(self):</span><br><span class="line">        print(&quot;age is:&quot;,self.age)</span><br><span class="line">        </span><br><span class="line">class Student(People): #继承父类</span><br><span class="line">    def __init__(self, name, age, school_name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        self.school_name &#x3D; school_name</span><br><span class="line"></span><br><span class="line">    def dis_student(self):</span><br><span class="line">        print(&quot;school name is:&quot;,self.school_name)</span><br><span class="line">    </span><br><span class="line">    def dis_name(self): #子类中对父类进行重写</span><br><span class="line">        print(&quot;名字：&quot;,self.name)</span><br><span class="line">        </span><br><span class="line">student &#x3D; Student(&quot;Wu&quot;, &quot;20&quot;, &quot;GLDZ&quot;) #创建一个Student 对象</span><br><span class="line">student.dis_student() #调用子类的方法</span><br><span class="line">student.dis_name() #调用子类的方法，已重写</span><br><span class="line">student.dis_age() #调用父类的方法</span><br><span class="line">student.set_age(22) #调用父类的方法</span><br><span class="line">student.dis_age() #调用父类的方法</span><br></pre></td></tr></table></figure>
<p><code>next()</code>返回迭代器的下一个值</p>
<p><code>iter()</code>生成迭代器</p>
<h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><h3 id="画函数图像"><a href="#画函数图像" class="headerlink" title="画函数图像"></a>画函数图像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as nps</span><br><span class="line">%matplotlib inline</span><br><span class="line">x &#x3D; np.arange(-10,10,0.01)</span><br><span class="line"># y &#x3D; (np.exp(x)-np.exp(-x))&#x2F;(np.exp(x)+np.exp(-x))</span><br><span class="line">y &#x3D; np.where(x&lt;0,0,x)</span><br><span class="line"># y &#x3D; np.sin(x)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.title(&quot;ReLU&quot;,fontsize &#x3D; 10)</span><br><span class="line"># plt.xlabel(&quot;horizontal axis&quot;, fontsize &#x3D; 10)</span><br><span class="line"># plt.ylabel(&quot;vertical axis&quot;,fontsize &#x3D; 10)</span><br><span class="line">plt.tick_params(axis&#x3D;&quot;both&quot;, labelsize &#x3D; 10)</span><br><span class="line">ax &#x3D; plt.gca()                                            # get current axis 获得坐标轴对象</span><br><span class="line">ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) </span><br><span class="line">ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)         # 将右边 上边的两条边颜色设置为空 其实就相当于抹掉这两条边</span><br><span class="line">ax.xaxis.set_ticks_position(&#39;bottom&#39;)   </span><br><span class="line">ax.yaxis.set_ticks_position(&#39;left&#39;)          # 指定下边的边作为 x 轴   指定左边的边为 y 轴</span><br><span class="line">ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0))   #指定 data  设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上</span><br><span class="line">ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="显示图像报错"><a href="#显示图像报错" class="headerlink" title="显示图像报错"></a>显示图像报错</h3><p>pyplot显示图像报错：Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers)</p>
<p>原因：用cv2.imread读进来的图片是uint8格式的，每个点的像素值在[0,255]之间，之前定义的图片占位符是float32，所以会直接将0-255之间的整数变成小数，但是并没有归一化！ 要显示float32格式的图片，还需要一步操作：</p>
<p>image = image/255.<br>原文链接：<a href="https://blog.csdn.net/aaon22357/article/details/82736792" target="_blank" rel="noopener">https://blog.csdn.net/aaon22357/article/details/82736792</a></p>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2.cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">def get_image_info(image):</span><br><span class="line">    print(type(image))  # &lt;class &#39;numpy.ndarray&#39;&gt;</span><br><span class="line">    print(image.shape[1:3])  # 显示高，宽，通道数</span><br><span class="line">    # print(image.size)  # 总的像素数据大小&#x3D;高*宽*通道数</span><br><span class="line">    # print(image.dtype)  # 显示像素数据类型</span><br><span class="line">    # pixel_data &#x3D; np.array(image)  # 通过numpy获取像素值</span><br><span class="line">    # # print(pixel_data)</span><br><span class="line">    # print(image)</span><br><span class="line">print(&quot;hi,python&quot;)</span><br><span class="line">src &#x3D; cv.imread(&quot;D:&#x2F;IMG_20161227_154705.jpg&quot;)</span><br><span class="line">plt.imshow(src)</span><br><span class="line">plt.show()</span><br><span class="line">edit &#x3D; cv.resize(src, (224, 224)).astype(&quot;float32&quot;)</span><br><span class="line">edit &#x3D; cv.cvtColor(edit, cv.COLOR_BGR2RGB)</span><br><span class="line">edit &#x3D; edit&#x2F;255.</span><br><span class="line">#plt.imshow(edit.astype(&#39;uint8&#39;))，用此句不用上一句</span><br><span class="line">plt.imshow(edit)</span><br><span class="line">get_image_info(edit)</span><br></pre></td></tr></table></figure>
<h2 id="pickle块"><a href="#pickle块" class="headerlink" title="pickle块"></a>pickle块</h2><p>模块 <a href="https://docs.python.org/zh-cn/3/library/pickle.html?highlight=pickle#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 实现了对一个 Python 对象结构的二进制序列化和反序列化。</p>
<p>json也是一种序列化格式。</p>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><h3 id="deque双向队列"><a href="#deque双向队列" class="headerlink" title="deque双向队列"></a>deque双向队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; d &#x3D; deque(&#39;ghi&#39;)                 # make a new deque with three items</span><br><span class="line">&gt;&gt;&gt; for elem in d:                   # iterate over the deque&#39;s elements</span><br><span class="line">...     print(elem.upper())</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">I</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d.append(&#39;j&#39;)                    # add a new entry to the right side</span><br><span class="line">&gt;&gt;&gt; d.appendleft(&#39;f&#39;)                # add a new entry to the left side</span><br><span class="line">&gt;&gt;&gt; d                                # show the representation of the deque</span><br><span class="line">deque([&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])</span><br></pre></td></tr></table></figure>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束</p>
<p>在深度学习中批量生成数据时经常yield（x,y)</p>
<p>其中x为数据，y代表数据标签</p>
<h2 id="找到字符串中的数字"><a href="#找到字符串中的数字" class="headerlink" title="找到字符串中的数字"></a>找到字符串中的数字</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">'zs10nj23kl'</span></span><br><span class="line">f1=re.findall(<span class="string">'(\d+)'</span>,s)</span><br><span class="line">print(f1)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Tricks of Training Deep Neural Works</title>
    <url>/2020/07/24/Tricks%20of%20Training%20Deep%20Neural%20Works/</url>
    <content><![CDATA[<h1 id="Tricks-of-Training-Deep-Neural-Works"><a href="#Tricks-of-Training-Deep-Neural-Works" class="headerlink" title="Tricks of Training Deep Neural Works"></a>Tricks of Training Deep Neural Works</h1><h2 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h2><p>训练数据包含<strong>抽样误差</strong>，训练时，复杂的模型将抽样误差也考虑在内，将抽样误差也进行了很好的拟合。最终模型在训练集上效果好；在测试集上效果差。模型泛化能力弱</p>
<p><img src="https://perfectism13.github.io/2020/02/13/Tricks%20of%20Training%20Deep%20Neural%20Works/v2-953f6e7ce85ac1856764572e1c855705_hd.jpg" alt="img"></p>
<p>过拟合的表现：</p>
<ul>
<li>train loss不断下降，test loss趋于不变</li>
<li>训练集和测试集准确率相差过大 15%以上</li>
</ul>
<h3 id="减少模型的复杂程度（容量）"><a href="#减少模型的复杂程度（容量）" class="headerlink" title="减少模型的复杂程度（容量）"></a>减少模型的复杂程度（容量）</h3><p><strong>L2正则化</strong></p>
<p><strong>Dropout</strong>：提高dropout的rate</p>
<p><strong>减少预训练的锁定层数</strong></p>
<h3 id="更多的数据"><a href="#更多的数据" class="headerlink" title="更多的数据"></a>更多的数据</h3><p>让模型感受更多的数据，逼迫模型泛化</p>
<p><strong>数据增强</strong></p>
<p><strong>采集更多的数据</strong></p>
<p><strong>查看数据集的分割是否合适</strong></p>
<h3 id="学习率的调整"><a href="#学习率的调整" class="headerlink" title="学习率的调整"></a>学习率的调整</h3><p>trick是 <strong>warm up（热身），就是先采用小的学习率（0.01）进行训练，</strong>训练了400iterations之后将学习率调整至0.1开始正式训练</p>
<p>在学习遇到瓶颈，即训练和验证损失均趋于不变时，适当调小batch_size,用更细的笔来画画</p>
<h3 id="进行交叉验证"><a href="#进行交叉验证" class="headerlink" title="进行交叉验证"></a>进行交叉验证</h3><p>当数据集比较小的时候，交叉验证可以“充分利用”有限的数据找到合适的模型参数，防止过度拟合</p>
<p>做法：就是把样本集S分成k份，分别使用其中的(k-1)份作为训练集，剩下的1份作为交叉验证集，最后取最后的平均误差，来评估这个模型</p>
<p>最后对k个模型的结果取平均</p>
<h3 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h3><h2 id="Owe-fitting"><a href="#Owe-fitting" class="headerlink" title="Owe fitting"></a>Owe fitting</h2><p>若准确率很低，检查数据和标签的对应关系，或者损失函数是否导致无法梯度下降</p>
<p>1、观察数据中是否有异常样本或异常label导致数据读取异常<br>2、调小初始化权重，以便使softmax输入的feature尽可能变小<br>3、降低学习率，这样就能减小权重参数的波动范围，从而减小权重变大的可能性。这条也是网上出现较多的方法。</p>
<p>4、调大batch_size<br>5、如果有BN（batch normalization）层，finetune时最好不要冻结BN的参数，否则数据分布不一致时很容易使输出值变的很大。</p>
<p>6、神经网络不够深。</p>
<p>7、训练的epoch不够。</p>
<h2 id="训练和验证集loss相差不大，验证集准确率为1或者0"><a href="#训练和验证集loss相差不大，验证集准确率为1或者0" class="headerlink" title="训练和验证集loss相差不大，验证集准确率为1或者0"></a>训练和验证集loss相差不大，验证集准确率为1或者0</h2><h2 id="检查数据集是否存在inf或者NaN"><a href="#检查数据集是否存在inf或者NaN" class="headerlink" title="检查数据集是否存在inf或者NaN"></a>检查数据集是否存在inf或者NaN</h2><h2 id="有时在第一代打乱数据，后续不再打乱，可能会有意想不到的好结果"><a href="#有时在第一代打乱数据，后续不再打乱，可能会有意想不到的好结果" class="headerlink" title="有时在第一代打乱数据，后续不再打乱，可能会有意想不到的好结果"></a><strong>有时在第一代打乱数据，后续不再打乱，可能会有意想不到的好结果</strong></h2><h2 id="References"><a href="#References" class="headerlink" title="References"></a><strong>Referenc</strong>es</h2>]]></content>
  </entry>
  <entry>
    <title>VS2013+OpenCV4.2.0安装与配置</title>
    <url>/2020/07/24/VS2013+OpenCV4.2.0%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="VS2013-OpenCV4-2-0安装与配置"><a href="#VS2013-OpenCV4-2-0安装与配置" class="headerlink" title="VS2013+OpenCV4.2.0安装与配置"></a>VS2013+OpenCV4.2.0安装与配置</h1><h2 id="VS2013"><a href="#VS2013" class="headerlink" title="VS2013"></a>VS2013</h2><p>下载链接：ed2k://|file|cn_visual_studio_ultimate_2013_with_update_5_x86_dvd_6816649.iso|5567336448|641555AD6472A98923B29CC5E371461E|/</p>
<p>安装教程：<a href="https://mp.weixin.qq.com/s/2Luj8FxXY6wYY2nhDe4SGw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2Luj8FxXY6wYY2nhDe4SGw</a></p>
<p>密匙：BWG7X-J98B3-W34RT-33B3R-JVYW9</p>
<h2 id="OpenCV4-2-0"><a href="#OpenCV4-2-0" class="headerlink" title="OpenCV4.2.0"></a>OpenCV4.2.0</h2><p>下载链接：<a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><a href="https://blog.csdn.net/qq_32717603/article/details/89234512" target="_blank" rel="noopener">https://blog.csdn.net/qq_32717603/article/details/89234512</a></p>
]]></content>
  </entry>
  <entry>
    <title>Note of Opencv2Python</title>
    <url>/2019/11/10/note%20of%20opencv2python/</url>
    <content><![CDATA[<h3 id="Note-of-Opencv-to-Python"><a href="#Note-of-Opencv-to-Python" class="headerlink" title="Note of Opencv to Python"></a>Note of Opencv to Python</h3><h4 id="Opencv-在Pycharm中的配置"><a href="#Opencv-在Pycharm中的配置" class="headerlink" title="Opencv 在Pycharm中的配置"></a>Opencv 在Pycharm中的配置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br><span class="line">pip install opencv-contrib-python <span class="comment">#扩展库</span></span><br><span class="line">pip install pytesseract</span><br></pre></td></tr></table></figure>
<p>新建python项目，注意解释器正确配置应该如下：</p>
<p><img src="note of opencv2python/1571710989690.png" alt="1571710989690" style="zoom:80%;" /></p>
<h4 id="常见图像坐标系"><a href="#常见图像坐标系" class="headerlink" title="常见图像坐标系"></a>常见图像坐标系</h4><p>Opencv：</p>
<p><img src="note of opencv2python/coordinate.PNG" style="zoom:50%;" /></p>
<p>Matlab：</p>
<p><img src="note of opencv2python/coordinate2.PNG" style="zoom:50%;" /></p>
<a id="more"></a>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="将照片读入到矩阵中，并显示"><a href="#将照片读入到矩阵中，并显示" class="headerlink" title="将照片读入到矩阵中，并显示"></a>将照片读入到矩阵中，并显示</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src = cv.imread(<span class="string">"D:/IMG_20161227_154705.jpg"</span>)</span><br><span class="line">cv.imshow(<span class="string">"input"</span>, src) <span class="comment">#input为窗口名</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>) 必须要有</span><br><span class="line">cv.imwrite(<span class="string">"D:/result.jpg"</span>, gray)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>cv.IMREAD_COLOR：读入一副彩色图像，将其转换为BGR模式，图像的透明度会被忽略，这是默认参数。</p>
<p>cv.IMREAD_GRAYSCALE：以灰度模式读入图像</p>
<p>cv.IMREAD_UNCHANGED：读入一幅图像，并且包括图像的alpha 通道</p>
<p> cv.IMREAD_ANYDEPTH ： 若设置返回相应深度图像（16位/32位），否则将其转换为8位</p>
<p> IMREAD_LOAD_GDAL  ：使用gda驱动载入图像</p>
<p>可使用python自带的Matplotlib显示图像。但注意opencv为BGR，Matplotlib为RGB，被opencv的imread读入后，不能被Matplotlib显示.</p>
<p>imwrite要求图像为BGR或灰度格式，并且每个通道有一定的位，BMP每通道8位，PNG每通道8位/16位</p>
<h4 id="图像与原始字节之间的转换"><a href="#图像与原始字节之间的转换" class="headerlink" title="图像与原始字节之间的转换"></a>图像与原始字节之间的转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">randombytearray = bytearray(os.urandom(<span class="number">120000</span>))  <span class="comment">#生成含有随机字节的bytearray数组</span></span><br><span class="line">nparray = np.array(randombytearray) <span class="comment">#将其转换为numpy数组</span></span><br><span class="line">grayimage = nparray.reshape((<span class="number">300</span>, <span class="number">400</span>)) <span class="comment">#生成单通道数组</span></span><br><span class="line">bgrimage = nparray.reshape([<span class="number">100</span>, <span class="number">400</span>, <span class="number">3</span>]) <span class="comment">#生成三通道数组</span></span><br><span class="line">src = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, <span class="number">120000</span>).reshape(<span class="number">300</span>, <span class="number">400</span>)  <span class="comment">#可随机生成numpy数组</span></span><br><span class="line">print(src)</span><br></pre></td></tr></table></figure>
<h4 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.namedWindow(<span class="string">"input"</span>, cv.WINDOW_AUTOSIZE) 适应图片大小</span><br><span class="line">cv.WINDOW_NORMAL 窗口大小可调节</span><br><span class="line">CV_WINDOW_OPENGL 支持OpenGL</span><br><span class="line">namedWindow()创建一个窗口。imshow可以直接指定窗口名，可以省去此函数（默认调用），但如果显示图像之前需要其他窗口操作时，需要调用此函数</span><br><span class="line">destroyWindow() 关闭特定窗口 <span class="comment"># cv.destroyWindow("video")</span></span><br><span class="line">destroyAllWindows()关闭所有的HighGUI窗口</span><br><span class="line">cv.startWindowThread()</span><br></pre></td></tr></table></figure>
<p>在调用cv.startWindowThread();后，即使没有调用waitKey()函数，图片也依然实时刷新。opencv的imshow()函数调用以后，并不立即刷新显示图片，而是等到waitKey()后才会刷新图片显示，所以cv.startWindowThread();是新开一个线程实时刷新图片显示。</p>
<h4 id="waitKey函数"><a href="#waitKey函数" class="headerlink" title="waitKey函数"></a>waitKey函数</h4><p>1.waitKey()返回的为-1(没有键被按下）或ASCII码值，</p>
<p>2.使用OpenCV的imshow函数显示图片，必须配合waitKey 函数使用，才能将图片显示在windows窗体上。否则，imshow 函数单独使用只能弹出空白窗体，而无法显示图片。</p>
<p>3.waitKey的时间延迟，只对Windows窗体有效，而且是 namedWindow 函数创造的OpenCV窗体，对于MFC或者Qt这种GUI窗体是否有效是一种未知结果,</p>
<p><u>不设置参数</u>：特定的几毫秒之内，如果按下任意键，这个函数会返回按键的ASCII 码值，程序将会继续运行。如果没有键盘输入，返回值为-1</p>
<p><u>ASCII码值</u>：0~127，共128个</p>
<p><img src="note of opencv2python/asciifull.png" style="zoom:150%;" /></p>
<p><img src="note of opencv2python/extend_ascii.png" style="zoom:150%;" /></p>
<p><u>设置参数</u>：使用waitKey(0) （无限等待）来判断相应按键操作，若为64位电脑，则需设置为k=cv2.waitKey(0)&amp;0xFF。</p>
<p>3.真正能起到程序暂停的作用的是我们熟悉的Windows API函数Sleep</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k = cv2.waitKey(<span class="number">0</span>)&amp;<span class="number">0xFF</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">27</span>: <span class="comment"># wait for ESC key to exit</span></span><br><span class="line">	cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>): <span class="comment"># wait for 's' key to save and exit</span></span><br><span class="line">	cv2.imwrite(<span class="string">'messigray.png'</span>,img)</span><br><span class="line">	cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h4 id="视频与电脑摄像头输入、存储"><a href="#视频与电脑摄像头输入、存储" class="headerlink" title="视频与电脑摄像头输入、存储"></a>视频与电脑摄像头输入、存储</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">video_demo</span><span class="params">()</span>:</span> <span class="comment">#无输入值</span></span><br><span class="line">	<span class="comment">#capture = cv.VideoCapture("D:/IMG_9764.MP4") #0为读取电脑摄像头，读取的视频无声音，大小有限制</span></span><br><span class="line">	capture = cv.VideoCapture(<span class="number">0</span>) <span class="comment">#0为设备索引号，自带摄像头一般为0</span></span><br><span class="line">	<span class="comment"># Define the codec and create VideoWriter object</span></span><br><span class="line">	fourcc = cv.VideoWriter_fourcc(*<span class="string">'XVID'</span>)</span><br><span class="line">	out = cv2.VideoWriter(<span class="string">'output.avi'</span>,fourcc, <span class="number">20.0</span>, (<span class="number">640</span>,<span class="number">480</span>)) <span class="comment">#编码类型，帧速率，帧大小</span></span><br><span class="line">    <span class="keyword">if</span> capture.isOpened() == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"camera has been initialized correctly"</span>)</span><br><span class="line">    <span class="keyword">elif</span> capture.isOpened() == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"camera has not been initialized correctly"</span>)</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">		ret, frame = capture.read() <span class="comment">#返回一个布尔值，若帧读取正确，则为True，每一帧</span></span><br><span class="line">		frame1 = cv.flip(frame, <span class="number">1</span>) <span class="comment">#镜像变换 1为左右 -1为上下</span></span><br><span class="line">		frame2 = cv.transpose(frame) <span class="comment">#顺时针旋转90°</span></span><br><span class="line">		cv.imshow(<span class="string">"video"</span>, frame) <span class="comment">#每一帧循环显示</span></span><br><span class="line">		cv.imshow(<span class="string">"video1"</span>, frame1)</span><br><span class="line">    	out.write(frame1)</span><br><span class="line">    	print(capture.get(<span class="number">3</span>)) <span class="comment">#获取每一帧的宽度</span></span><br><span class="line">		cv.imshow(<span class="string">"video2"</span>, frame2)</span><br><span class="line">		c = cv.waitKey(<span class="number">1</span>) <span class="comment">#响应用户操作</span></span><br><span class="line">		<span class="comment">#if c == 27:</span></span><br><span class="line">			<span class="comment">#break</span></span><br><span class="line">    	<span class="comment">#capture.release() #Closes video file or capturing device</span></span><br><span class="line">    	<span class="keyword">if</span> c &amp; oxFF ==ord(<span class="string">'q'</span>)</span><br><span class="line">        	capture.release()</span><br><span class="line">    		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>cv.VideoCapture为一个类,get(CV_CAP_PROP_FPS)可返回视频帧速率的准确值，但不能返回摄像头帧速率的准确值（总是返回0），可使用计时器来测量</p>
<p>视频写入时FourCC码以cv.FOURCC(‘M’,’J’,’P’,’G’) 或者cv.FOURCC(*’MJPG’）传给fourcc，编码格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;): This option is an</span><br><span class="line">uncompressed YUV encoding, 4:2:0 chroma subsampled. This encoding is</span><br><span class="line">widely compatible but produces large files. The file extension should be .avi.</span><br><span class="line">• cv2.VideoWriter_fourcc(&#39;P&#39;,&#39;I&#39;,&#39;M&#39;,&#39;1&#39;): This option is MPEG-1. The</span><br><span class="line">file extension should be .avi.</span><br><span class="line">• cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;V&#39;,&#39;I&#39;,&#39;D&#39;): This option is MPEG-4 and</span><br><span class="line">a preferred option if you want the resulting video size to be average. The file</span><br><span class="line">extension should be .avi.</span><br><span class="line">• cv2.VideoWriter_fourcc(&#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;): This option is Ogg Vorbis.</span><br><span class="line">The file extension should be .ogv.</span><br><span class="line">• cv2.VideoWriter_fourcc(&#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;): This option is a Flash video.</span><br><span class="line">The file extension should be .flv.</span><br></pre></td></tr></table></figure>
<p>从文件播放视频时，使用cv.waiKey() 设置适当的持续时间，一般25ms合适，设置地高的话，视频播放地慢</p>
<p><u>cap.read()</u>：若帧读取正确，返回True，检查其返回值判断视频文件是否到结尾</p>
<p><u>cap.isOpened()</u>：摄像头成功初始化，返回True，否则使用cap.open()</p>
<p><u>cap.get(propId)</u>：获得视频的参数信息，propId 可以是0 到18 之间的任何整数,见下表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">• CV_CAP_PROP_POS_MSEC <span class="comment">#Current position of the video file in milliseconds.</span></span><br><span class="line">• CV_CAP_PROP_POS_FRAMES <span class="comment">#0-based index of the frame to be decoded/captured next.</span></span><br><span class="line">• CV_CAP_PROP_POS_AVI_RATIO <span class="comment">#Relative position of the video file: 0 - start of the film, 1 - end of the film.</span></span><br><span class="line">• CV_CAP_PROP_FRAME_WIDTH <span class="comment">#Width of the frames in the video stream.</span></span><br><span class="line">• CV_CAP_PROP_FRAME_HEIGHT <span class="comment">#Height of the frames in the video stream.</span></span><br><span class="line">• CV_CAP_PROP_FPS <span class="comment">#Frame rate. 每秒帧数/帧速率/FPS</span></span><br><span class="line">• CV_CAP_PROP_FOURCC <span class="comment">#4-character code of codec.</span></span><br><span class="line">• CV_CAP_PROP_FRAME_COUNT <span class="comment">#Number of frames in the video file.</span></span><br><span class="line">• CV_CAP_PROP_FORMAT <span class="comment">#Format of the Mat objects returned by retrieve() .</span></span><br><span class="line">• CV_CAP_PROP_MODE <span class="comment">#Backend-specific value indicating the current capture mode.</span></span><br><span class="line">• CV_CAP_PROP_BRIGHTNESS <span class="comment">#Brightness of the image (only for cameras).</span></span><br><span class="line">• CV_CAP_PROP_CONTRAST <span class="comment">#Contrast of the image (only for cameras).</span></span><br><span class="line">• CV_CAP_PROP_SATURATION <span class="comment">#Saturation of the image (only for cameras).</span></span><br><span class="line">• CV_CAP_PROP_HUE <span class="comment">#Hue of the image (only for cameras).</span></span><br><span class="line">• CV_CAP_PROP_GAIN <span class="comment">#Gain of the image (only for cameras).</span></span><br><span class="line">• CV_CAP_PROP_EXPOSURE <span class="comment">#Exposure (only for cameras).</span></span><br><span class="line">• CV_CAP_PROP_CONVERT_RGB <span class="comment">#Boolean flags indicating whether images should be converted to RGB.</span></span><br><span class="line">• CV_CAP_PROP_WHITE_BALANCE <span class="comment">#Currently unsupported</span></span><br><span class="line">• CV_CAP_PROP_RECTIFICATION <span class="comment">#Rectification flag for stereocameras (note: only supported by DC1394 v 2.x backend currently)</span></span><br></pre></td></tr></table></figure>
<p>cap.set(propId,value)：修改视频参数，value为新值</p>
<p>3—width，4—hight</p>
<p>使用一组摄像头时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">success0 = cameraCapture0.grab()</span><br><span class="line">success1 = cameraCapture1.grab()</span><br><span class="line"><span class="keyword">if</span> success0 <span class="keyword">and</span> success1:</span><br><span class="line">	frame0 = cameraCapture0.retrieve()</span><br><span class="line">	frame1 = cameraCapture1.retrieve()</span><br></pre></td></tr></table></figure>
<h4 id="获取图片的信息"><a href="#获取图片的信息" class="headerlink" title="获取图片的信息"></a>获取图片的信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image_info</span><span class="params">(image)</span>:</span></span><br><span class="line">	print(type(image)) <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line">	print(image.shape) <span class="comment">#显示高，宽，通道数</span></span><br><span class="line">	print(image.size)  <span class="comment">#总的像素数据大小=高*宽*通道数</span></span><br><span class="line">	print(image.dtype)  <span class="comment">#显示像素数据类型</span></span><br><span class="line">	pixel_data = np.array(image)  <span class="comment">#通过numpy获取像素值</span></span><br><span class="line">	<span class="comment"># print(pixel_data)</span></span><br><span class="line">	print(image) 可以直接打印</span><br></pre></td></tr></table></figure>
<h4 id="绘图功能"><a href="#绘图功能" class="headerlink" title="绘图功能"></a>绘图功能</h4><p>img：想要绘图的图像</p>
<p>color：BGR模式输入</p>
<p>thickness:默认为1，对于封闭图形设置为-1可实现填充</p>
<p>lineType：8连接，抗锯齿型连接（平滑性好，cv2.LINE_AA）</p>
<p>shift:坐标点与数轴的精度，默认为0</p>
<p>后五个参数的顺序一般如上</p>
<p>Drawing Line：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">img = cv2.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>) <span class="comment">#指定直线的起点和终点，画多条线时可用cv.polylines()</span></span><br><span class="line">img = cv2.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>) <span class="comment">#指定矩形的左上顶点和右下顶点</span></span><br><span class="line">img = cv2.circle(img,(<span class="number">447</span>,<span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">-1</span>) <span class="comment">#指定圆心，半径</span></span><br><span class="line">img = cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#img	=	cv.ellipse(	img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]	)</span></span><br><span class="line"></span><br><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">pts = pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">#reshape 的第一个参数为-1, 表明这一维的长度是根据后面的维度的计算出来的。</span></span><br><span class="line">img = cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>)) <span class="comment">#若为第三个参数为False，则该多边形不封闭，首尾不想连</span></span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv2.putText(img,<span class="string">'OpenCV'</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>,cv2.LINE_AA) <span class="comment">#位置，字体类型，字体大小，颜色，粗细，线条的类型</span></span><br></pre></td></tr></table></figure>
<p><img src="note of opencv2python/ellipse.png" style="zoom:150%;" /></p>
<h4 id="鼠标操作响应"><a href="#鼠标操作响应" class="headerlink" title="鼠标操作响应"></a>鼠标操作响应</h4><p>事件列表：</p>
<p><img src="note of opencv2python/event.png" style="zoom:80%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags, param)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDBLCLK:</span><br><span class="line">        cv.circle(img, [x, y], <span class="number">10</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a black image, a window and bind the function to window</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">'image'</span>, draw_circle)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">20</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>通过按键来控制不同的鼠标事件响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当鼠标按下时变为True</span></span><br><span class="line">drawing = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 如果mode 为true 绘制矩形。按下'm' 变成绘制曲线。</span></span><br><span class="line">mode = <span class="literal">True</span></span><br><span class="line">ix, iy = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建鼠标事件回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ix, iy, drawing, mode</span><br><span class="line"><span class="comment"># 当按下左键是返回起始位置坐标</span></span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing=<span class="literal">True</span></span><br><span class="line">        ix, iy = x, y</span><br><span class="line"><span class="comment"># 当鼠标左键按下并移动是绘制图形。event 可以查看移动，flag 查看是否按下</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_MOUSEMOVE <span class="keyword">and</span> flags == cv.EVENT_FLAG_LBUTTON:</span><br><span class="line">        <span class="keyword">if</span> drawing == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">                cv.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#cv.circle(img,(x,y),10,(0,0,255),-1) # 绘制圆圈，小圆点连在一起就成了线，3 代表了笔画的粗细</span></span><br><span class="line">                <span class="comment"># 下面注释掉的代码是起始点为圆心，起点到终点为半径的</span></span><br><span class="line">                r=int(np.sqrt((x-ix)**<span class="number">2</span>+(y-iy)**<span class="number">2</span>))</span><br><span class="line">                cv.circle(img,(ix,iy),r,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)</span><br><span class="line">                <span class="comment"># 当鼠标松开停止绘画。</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        drawing=<span class="literal">False</span></span><br><span class="line">        <span class="comment"># if mode==True:</span></span><br><span class="line">        <span class="comment">#     cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     cv.circle(img,(x,y),5,(0,0,255),-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == ord(<span class="string">'m'</span>): <span class="comment">#ord()可将字符转换为ASCII码</span></span><br><span class="line">        mode = <span class="keyword">not</span> mode</span><br><span class="line">    <span class="keyword">elif</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>opencv有限的事件处理能力与GUI处理能力，将其集成到其他应用程序框架更受欢迎</p>
<h4 id="滑动条的实现"><a href="#滑动条的实现" class="headerlink" title="滑动条的实现"></a>滑动条的实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 创建一副黑色图像</span></span><br><span class="line">img=np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">switch=<span class="string">'0:OFF\n1:ON'</span></span><br><span class="line">cv2.createTrackbar(switch,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span><br><span class="line">    k=cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k==<span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    r=cv2.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span><br><span class="line">    g=cv2.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span><br><span class="line">    b=cv2.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span><br><span class="line">    s=cv2.getTrackbarPos(switch,<span class="string">'image'</span>)</span><br><span class="line">    <span class="keyword">if</span> s==<span class="number">0</span>:</span><br><span class="line">        img[:]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:]=[b,g,r]</span><br><span class="line">        <span class="comment">#img = cv2.merge([b, g, r])</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h3><h4 id="色彩空间转换"><a href="#色彩空间转换" class="headerlink" title="色彩空间转换"></a>色彩空间转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY) <span class="comment">#获取灰度图像</span></span><br><span class="line">dst = cv.bitwise_not(image) <span class="comment"># 通过逻辑非运算来获得负片</span></span><br><span class="line">gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line">back_rgb = cv.cvtColor(gray, cv.COLOR_GRAY2BGR)</span><br></pre></td></tr></table></figure>
<p>灰度：去除彩色信息将其转换成灰阶，对人脸检测等中间处理特别有效</p>
<p>HSV：H（Hue）色调，S(Saturation)饱和度，V（Value）表示黑暗程度或光谱另一端的明亮程度，便于色彩区分 ，opencv中将hue值设为0-180，便于用uint8表示</p>
<h4 id="Print函数Tips"><a href="#Print函数Tips" class="headerlink" title="Print函数Tips"></a>Print函数Tips</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">打印变量值</span><br><span class="line">print(<span class="string">"width : %s, height : %s channels : %s"</span> % (width, height, channels))</span><br><span class="line">打印矩阵</span><br><span class="line">print(image)</span><br></pre></td></tr></table></figure>
<h4 id="遍历像素点"><a href="#遍历像素点" class="headerlink" title="遍历像素点"></a>遍历像素点</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">access_pixels</span><span class="params">(image)</span>:</span></span><br><span class="line">	height = image.shape[<span class="number">0</span>]</span><br><span class="line">	width = image.shape[<span class="number">1</span>]</span><br><span class="line">	channels = image.shape[<span class="number">2</span>]</span><br><span class="line">	print(<span class="string">"width : %s, height : %s channels : %s"</span> % (width, height, channels))</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> range(height):</span><br><span class="line">		<span class="keyword">for</span> col <span class="keyword">in</span> range(width):</span><br><span class="line">			<span class="keyword">for</span> c <span class="keyword">in</span> range(channels):</span><br><span class="line">				pv = image[row, col, c]</span><br><span class="line">				image[row, col, c] = <span class="number">255</span> – pv        </span><br><span class="line">	cv.imshow(<span class="string">"demo"</span>, image)</span><br></pre></td></tr></table></figure>
<p>优先使用索引等方法对像素点、面进行操作，使用循环会使得效率低下，尤其对于视频处理</p>
<h4 id="矩阵操纵（创建一幅图像"><a href="#矩阵操纵（创建一幅图像" class="headerlink" title="矩阵操纵（创建一幅图像)"></a>矩阵操纵（创建一幅图像)</h4><p>ones创建任意维度和元素个数的数组，其元素值均为1<br>empty一样，只是它所常见的数组内所有元素均为空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zeros([m,n…],int8) 创建任意维度和元素个数的数组，其元素值均为<span class="number">0</span></span><br><span class="line">img = np.zeros([<span class="number">400</span>, <span class="number">400</span>, <span class="number">3</span>], np.uint8)</span><br><span class="line"><span class="comment">#img = np.ones([400, 400, 3]) * 255</span></span><br><span class="line"><span class="comment"># img[:, :, 2] = np.ones([400, 400])*255 #对2通道像素平面进行操作</span></span><br><span class="line"><span class="comment"># cv.imshow("new image", img)</span></span><br><span class="line">matrix = np.ones([<span class="number">6</span>, <span class="number">6</span>], np.float32) <span class="comment"># 有浮点数计算一定选float</span></span><br></pre></td></tr></table></figure>
<p>fill用来填充矩阵，<br>reshape可以进行矩阵重组，元素数相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix.fill(<span class="number">1625.35</span>)</span><br></pre></td></tr></table></figure>
<p>cv.convertScaleAbs() 可以将浮点数转化为uint8 ，负数转换为绝对值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m2 = matrix.reshape([<span class="number">3</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure>
<p>array生成任意矩阵，可以作为算子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m3 &#x3D; np.array([[1,2,3], [4,5,6], [7,8,9]],np.int32)</span><br></pre></td></tr></table></figure>
<p><img src="note of opencv2python/1571711690470-1571720785213.png" alt="1571711690470" style="zoom:150%;" /></p>
<h4 id="获取程序执行时间"><a href="#获取程序执行时间" class="headerlink" title="获取程序执行时间"></a>获取程序执行时间</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = cv.getTickCount()</span><br><span class="line">create_image() <span class="comment">#程序</span></span><br><span class="line">t2 = cv.getTickCount()</span><br><span class="line">time = (t2 - t1) / cv.getTickFrequency()</span><br><span class="line">print(<span class="string">"time = %s ms"</span> % (time * <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>可以通过调用opencv自带的API来减少程序执行时间</p>
<h4 id="提取某颜色对应的像素"><a href="#提取某颜色对应的像素" class="headerlink" title="提取某颜色对应的像素"></a>提取某颜色对应的像素</h4><p>思路：转换到HSV空间，再参考下表设置inRange函数的参数(红色设置为第二列较佳)</p>
<p><img src="note of opencv2python/1571711906767.png" alt="1571711906767" style="zoom:150%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_object_demo</span><span class="params">()</span>:</span></span><br><span class="line">	capture = cv.VideoCapture(<span class="string">"D:/IMG_9764.MP4"</span>)</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">		ret, frame = capture.read() <span class="comment"># 先将每一帧读入</span></span><br><span class="line">	<span class="keyword">if</span> ret == <span class="literal">False</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)  </span><br><span class="line">	lower_hsv = np.array([<span class="number">0</span>, <span class="number">43</span>, <span class="number">46</span>]) <span class="comment"># 找出白色</span></span><br><span class="line">	upper_hsv = np.array([<span class="number">10</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">	mask = cv.inRange(hsv, lowerb=lower_hsv, upperb=upper_hsv)</span><br><span class="line">	dst = cv.bitwise_and(frame, frame, mask=mask)</span><br><span class="line">	cv.imshow(<span class="string">"video"</span>, frame)</span><br><span class="line">	cv.imshow(<span class="string">"mask"</span>, dst) <span class="comment">#将含有红色的像素提取以红色在黑色视频中显示 </span></span><br><span class="line">	c = cv.waitKey(<span class="number">50</span>)</span><br><span class="line">	<span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">		<span class="keyword">break</span>  <span class="comment"># escape</span></span><br></pre></td></tr></table></figure>
<h4 id="图像通道的合并、分离、单通道操作、单像素操作"><a href="#图像通道的合并、分离、单通道操作、单像素操作" class="headerlink" title="图像通道的合并、分离、单通道操作、单像素操作"></a>图像通道的合并、分离、单通道操作、单像素操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b, g, r = cv.split(src)</span><br><span class="line">cv.imshow(<span class="string">"blue"</span>, b)</span><br><span class="line">cv.imshow(<span class="string">"green"</span>, g)</span><br><span class="line">cv.imshow(<span class="string">"red"</span>, r)</span><br><span class="line">src = cv.merge([b, g, r]) <span class="comment"># 注意此处的输入</span></span><br><span class="line">src[:, :, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">src.itemset((<span class="number">150</span>, <span class="number">120</span>, <span class="number">0</span>), <span class="number">255</span>) <span class="comment">#将蓝色通道值变为255</span></span><br><span class="line">print(src.itemset((<span class="number">150</span>, <span class="number">120</span>, <span class="number">0</span>)))</span><br><span class="line">cv.imshow(<span class="string">"changed image"</span>, src)</span><br><span class="line">h, w = src.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">#获取图像的高与宽，0可以不输入</span></span><br><span class="line">print(src[<span class="number">30</span>, <span class="number">30</span>, :]) <span class="comment">#打印某位置上的三个像素值</span></span><br></pre></td></tr></table></figure>
<h4 id="图像算术运算、逻辑运算"><a href="#图像算术运算、逻辑运算" class="headerlink" title="图像算术运算、逻辑运算"></a>图像算术运算、逻辑运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv.add(m1, m2) <span class="comment">#相加</span></span><br><span class="line">dst = cv.subtract(m1, m2) <span class="comment">#相减</span></span><br><span class="line">dst = cv.divide(m1, m2) <span class="comment">#除</span></span><br><span class="line">dst = cv.multiply(m1, m2) <span class="comment">#乘</span></span><br><span class="line">M1 = cv.mean(m1) <span class="comment">#获取均值</span></span><br><span class="line">M2, dev2 = cv.meanStdDev(m2) <span class="comment">#获取均值和方差</span></span><br><span class="line">Tips：方差越小，则该图片包含的信息越少，可设置阈值来过滤无意义的图片</span><br><span class="line">dst1 = cv.bitwise_or(m1, m2)</span><br><span class="line">dst2 = cv.bitwise_and(m1, m2) <span class="comment"># 可以作为一个“遮罩”</span></span><br><span class="line">dst3 = cv.bitwise_not(m1) <span class="comment">#获得负片</span></span><br></pre></td></tr></table></figure>
<p><img src="note of opencv2python/1571712052313.png" alt="1571712052313" style="zoom:80%;" /></p>
<h4 id="调整对比度和亮度"><a href="#调整对比度和亮度" class="headerlink" title="调整对比度和亮度"></a>调整对比度和亮度</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contrast_brightness_demo</span><span class="params">(image, c, b)</span>:</span></span><br><span class="line">	h, w, ch = image.shape <span class="comment">#取出shape的前两位【：2】</span></span><br><span class="line">	blank = np.zeros([h, w, ch], image.dtype)</span><br><span class="line">	dst = cv.addWeighted(image, c, blank, <span class="number">1</span>-c, b) <span class="comment">#调整对比度和亮度,none的均可以接收，dst = 	src1*alpha + src2*beta + gamma</span></span><br><span class="line">	cv.imshow(<span class="string">"con_bri_demo"</span>, dst)</span><br><span class="line">像素运算式：dst = src1*alpha + src2*beta + gamma</span><br></pre></td></tr></table></figure>
<h4 id="ROI选择"><a href="#ROI选择" class="headerlink" title="ROI选择"></a>ROI选择</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face = src[<span class="number">50</span>:<span class="number">250</span>, <span class="number">100</span>:<span class="number">300</span>] <span class="comment"># [height, width]</span></span><br><span class="line">gray = cv.cvtColor(face, cv.COLOR_BGR2GRAY)</span><br><span class="line">backrgb = cv.cvtColor(gray, cv.COLOR_GRAY2BGR)</span><br><span class="line">src[<span class="number">50</span>:<span class="number">250</span>, <span class="number">100</span>:<span class="number">300</span>] = backrgb</span><br><span class="line">cv.imshow(<span class="string">"face"</span>, src)</span><br></pre></td></tr></table></figure>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><h4 id="泛洪填充"><a href="#泛洪填充" class="headerlink" title="泛洪填充"></a>泛洪填充</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_color_demo</span><span class="params">(image)</span>:</span></span><br><span class="line">	copyImg = image.copy()</span><br><span class="line">	h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">	mask = np.zeros([h+<span class="number">2</span>, w+<span class="number">2</span>], np.uint8) <span class="comment">#底层代码要求必须这么写</span></span><br><span class="line">	cv.floodFill(copyImg, mask, (<span class="number">30</span>, <span class="number">30</span>), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), (<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>), (<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>), 	cv.FLOODFILL_FIXED_RANGE)</span><br><span class="line">	cv.imshow(<span class="string">"fill_color_demo"</span>, copyImg)</span><br></pre></td></tr></table></figure>
<p><img src="note of opencv2python/1571712200414.png" alt="1571712200414" style="zoom:80%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_binary</span><span class="params">()</span>:</span></span><br><span class="line">	image = np.zeros([<span class="number">400</span>, <span class="number">400</span>, <span class="number">3</span>], np.uint8)</span><br><span class="line">	image[<span class="number">100</span>:<span class="number">300</span>, <span class="number">100</span>:<span class="number">300</span>, :] = <span class="number">255</span></span><br><span class="line">	cv.imshow(<span class="string">"fill_binary"</span>, image)</span><br><span class="line">	mask = np.ones([<span class="number">402</span>, <span class="number">402</span>, <span class="number">1</span>], np.uint8)</span><br><span class="line">	mask[<span class="number">100</span>:<span class="number">300</span>, <span class="number">100</span>:<span class="number">300</span>] = <span class="number">0</span></span><br><span class="line">	cv.floodFill(image, mask, (<span class="number">200</span>, <span class="number">200</span>), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), cv.FLOODFILL_MASK_ONLY)<span class="comment">#只填充mask标记为（0，0）的像素点</span></span><br><span class="line">	cv.imshow(<span class="string">"filled binary"</span>, image)</span><br></pre></td></tr></table></figure>
<h4 id="图像模糊（图像平滑）"><a href="#图像模糊（图像平滑）" class="headerlink" title="图像模糊（图像平滑）"></a>图像模糊（图像平滑）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>低通滤波：去噪，模糊图像，但去除了高频成分（噪声、边界）</p>
<p>高通滤波（图像梯度）：找到边缘</p>
<p>空间滤波的数学原理:二维空间卷积</p>
<h5 id="分类及应用场景"><a href="#分类及应用场景" class="headerlink" title="分类及应用场景"></a>分类及应用场景</h5><p>平均：卷积框覆盖区域所有像素的平均值来代替中心元素</p>
<p>高斯(低通滤波器之一）：方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包。原来的求平均数现在变成求加权平均数，权就是方框里的值，X与y方向的标准差相等，若设置为0，则函数根据核的大小自动计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0是指根据窗口大小（5,5）来计算高斯函数标准差</span></span><br><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>只考虑像素之间的空间关系，而不会考虑像素值之间的关系（像素的相似度）</p>
<p>中值：用与卷积框对应像素的中值来替代中心像素的值，去除椒盐噪声、数字化的视频噪声尤其是彩色图像的噪声，但对于较大ksize，代价较高</p>
<p>双边：保持边界清晰的情况下有效的去除噪音，使用空间高斯权重（位置差异越小权重越大）与灰度值相似性高斯权重（灰度值差异越小权重越大）,边缘处灰度值与中心像素灰度值相比变化大，权重小不会被模糊</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 9是邻域直径，两个75分别是空间高斯函数标准差，灰度值相似性高斯函数标准差</span></span><br><span class="line">blur = cv2.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>关于算子：元素个数为奇数（奇数行奇数列），<u>总和为0</u>：进行边缘和梯度计算，</p>
<p><u>总和为1</u>：进行增强锐化等，相当于将感兴趣像素与其邻近像素值间的差放大，图像的亮度没有改变<br>Tips：blurry模糊的，不清楚的，污脏的</p>
<p><img src="note of opencv2python/1571712321721.png" alt="1571712321721" style="zoom:80%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv.blur(image, (<span class="number">1</span>, <span class="number">15</span>)) <span class="comment">#均值模糊，模糊只是卷积的表象</span></span><br><span class="line">dst = cv.medianBlur(image, <span class="number">5</span>) <span class="comment">#中值模糊</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_blur_demo</span><span class="params">(image)</span>:</span> <span class="comment">#自定义卷积核来模糊</span></span><br><span class="line">	<span class="comment"># kernel = np.ones([5, 5], np.float32)/25 #最多25个255，防止溢出</span></span><br><span class="line">	kernel = np.array([[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>]], np.float32)</span><br><span class="line">	dst = cv.filter2D(image, <span class="number">-1</span>, kernel=kernel) <span class="comment">#-1表示目标图像与源图像的位深度相同</span></span><br><span class="line">	cv.imshow(<span class="string">"custom_blur_demo"</span> ,dst)</span><br></pre></td></tr></table></figure>
<p>filter2D()对每个通道使用相同的核，若要每个通道的核不同，则使用split分离通道，再用merge合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel_3x3 = np.array([[<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>],</span><br><span class="line">                   [<span class="number">-1</span>,  <span class="number">8</span>, <span class="number">-1</span>],</span><br><span class="line">                   [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]])</span><br><span class="line">k3 = ndimage.convolve(img, kernel_3x3) <span class="comment">#通过numpy的ndimage的convolve可以实现两个矩阵之间的卷积</span></span><br></pre></td></tr></table></figure>
<h4 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h4><p>二维函数的梯度定义为向量,其幅度即模如下：</p>
<script type="math/tex; mode=display">
\begin{array}{c}{\nabla \boldsymbol{f}=\left[\begin{array}{c}{g_{x}} \\ {g_{y}}\end{array}\right]=\left[\begin{array}{c}{\frac{\partial f}{\partial x}} \\ {\frac{\partial f}{\partial y}}\end{array}\right]} \\ {\nabla f=\operatorname{mag}(\nabla \boldsymbol{f})=\left[\begin{array}{c}{x_{x}^{2}+g_{y}^{2}}\end{array}\right]^{1 / 2}=\left[(\partial f / \partial x)^{2}+(\partial f / \partial y)^{2}\right]^{1 / 2}}\end{array}</script><p>可由绝对值来近似：</p>
<script type="math/tex; mode=display">
\nabla f \approx\left|g_{x}\right|+\left|g_{y}\right|</script><p>离散化表示：</p>
<script type="math/tex; mode=display">
\begin{aligned} g_{x} &=\frac{\partial f(x, y)}{\partial x}= f(x+1, y)-f(x, y) \\ g_{y} &=\frac{\partial f(x, y)}{\partial y}= f(x, y+1)-f(x, y) \end{aligned}</script><h5 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="Laplacian 算子"></a>Laplacian 算子</h5><p>可用来计算图像的二阶导数，推导在Matlab图像坐标系下进行：</p>
<script type="math/tex; mode=display">
\begin{array}{c}{\nabla^{2} f(x, y)=\frac{\partial^{2} f(x, y)}{\partial x^{2}}+\frac{\partial^{2} f(x, y)}{\partial y^{2}}} \\ {\frac{\partial^{2} f(x, y)}{\partial x^{2}}=f(x+1, y)+f(x-1, y)-2 f(x, y)} \\ {\frac{\partial^{2} f(x, y)}{\partial y^{2}}=f(x, y+1)+f(x, y-1)-2 f(x, y)}  \\{\nabla^{2} f(x, y)=[f(x+1, y)+f(x-1, y)+f(x, y+1)+f(x, y-1)]-4 f(x, y)}\end{array}</script><script type="math/tex; mode=display">
\begin{array}{ccc}{0} & {1} & {0} \\ {-1} & {-4} & {1} \\ {0} & {1} & {0} \\ \\ {1} & {1} & {1} \\ {1} & {-8} & {1} \\ {1} & {1} & {1}\end{array}</script><p>第二个算子为考虑了对角线元素的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cv2.CV_64F 输出图像的深度（数据类型），可以使用-1, 与原图像保持一致np.uint8</span><br><span class="line">laplacian&#x3D;cv2.Laplacian(img,cv2.CV_64F)</span><br></pre></td></tr></table></figure>
<h5 id="Prewitt算子"><a href="#Prewitt算子" class="headerlink" title="Prewitt算子"></a>Prewitt算子</h5><script type="math/tex; mode=display">
\begin{array}{l}{g_{x}=\frac{\partial f}{\partial x}=\left(z_{7}+z_{8}+z_{9}\right)-\left(z_{1}+z_{2}+z_{3}\right)} \\ {g_{y}=\frac{\partial f}{\partial y}=\left(z_{3}+z_{6}+z_{9}\right)-\left(z_{1}+z_{4}+z_{7}\right)}\end{array}</script><p>对角线方向：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{g_{x}^{\prime}=\left(z_{2}+z_{3}+z_{6}\right)-\left(z_{4}+z_{7}+z_{8}\right)} \\ {g_{y}^{\prime}=\left(z_{6}+z_{8}+z_{9}\right)-\left(z_{1}+z_{2}+z_{4}\right)}\end{array}</script><p><img src="note of opencv2python/prewitt.PNG" style="zoom:50%;" /></p>
<h5 id="Sobel算子和Scharr算子"><a href="#Sobel算子和Scharr算子" class="headerlink" title="Sobel算子和Scharr算子"></a>Sobel算子和Scharr算子</h5><p>Sobel 算子是高斯平滑与微分操作的结合体，所以它的抗噪声能力很好。你可以设定求导的方向（xorder 或yorder）。还可以设定使用的卷积核的大小（ksize）。如果ksize=-1，会使用3x3 的Scharr 滤波器，它的的效果要比3x3 的Sobel 滤波器好（而且速度相同，所以在使用3x3 滤波器时应该尽量使用Scharr 滤波器）。3x3 的</p>
<p>Sobel算子的卷积核：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{g_{x}=\frac{\partial f}{\partial x}=\left(z_{7}+2 z_{8}+z_{9}\right)-\left(z_{1}+2 z_{2}+z_{3}\right)} \\ {g_{y}=\frac{\partial f}{\partial y}=\left(z_{3}+2 z_{6}+z_{9}\right)-\left(z_{1}+2 z_{4}+z_{7}\right)}\end{array}</script><p><img src="note of opencv2python/sobel.PNG" style="zoom:50%;" /></p>
<p>Scharr 滤波器卷积核如下：</p>
<p>X方向：</p>
<script type="math/tex; mode=display">
\begin{array}{|c|c|c|}\hline-3 & {0} & {3} \\ \hline-10 & {0} & {10} \\ \hline-3 & {0} & {3} \\ \hline\end{array}</script><p>Y方向：</p>
<script type="math/tex; mode=display">
\begin{array}{|c|c|c|}\hline-3 & {-10} & {-3} \\ \hline 0 & {0} & {0} \\ \hline 3 & {10} & {3} \\ \hline\end{array}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数1,0 为只在x 方向求一阶导数，最大可以求2 阶导数。</span></span><br><span class="line">sobelx=cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 参数0,1 为只在y 方向求一阶导数，最大可以求2 阶导数。</span></span><br><span class="line">sobely=cv2.Sobel(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>当我们可以通过参数 -1 来设定输出图像的深度（数据类型）与原图像保持一致，但是我们在代码中使用的却是 cv2.CV_64F。这是为什么呢？想象一下一个从黑到白的边界的导数是正数，而一个从白到黑的边界点导数却是负数。如果原图像的深度是np.int8 时，所有的负值都会被截断变成 0，换句话说就是把把边界丢失掉。所以如果这两种边界你都想检测到，最好的的办法就是将输出的数据类型设置的更高，比如 cv2.CV_16S，cv2.CV_64F 等。取绝对值然后再把它转回到 cv2.CV_8U</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Output dtype = cv2.CV_8U</span></span><br><span class="line">sobelx8u = cv2.Sobel(img,cv2.CV_8U,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)<span class="comment"># 也可以将参数设为-1</span></span><br><span class="line"><span class="comment">#sobelx8u = cv2.Sobel(img,-1,1,0,ksize=5)</span></span><br><span class="line"><span class="comment"># Output dtype = cv2.CV_64F. Then take its absolute and convert to cv2.CV_8U</span></span><br><span class="line">sobelx64f = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span><br><span class="line">abs_sobel64f = np.absolute(sobelx64f)</span><br><span class="line">sobel_8u = np.uint8(abs_sobel64f)</span><br></pre></td></tr></table></figure>
<h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>Laplacian(),sobel,scharr等会将噪声错误地识别为边缘，故在此之前应进行中值滤波和灰度化</p>
<p>核的元素值之和为0，将边缘转为白色，非边缘转为黑色</p>
<h5 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h5><p>John F.Canny 在1986 年提出的，分为以下五步：</p>
<ol>
<li><p>使用高斯滤波器去噪</p>
</li>
<li><p>使用Sobel算子计算水平方向和垂直方向梯度，找到边界的梯度和方向</p>
<script type="math/tex; mode=display">
\begin{array}{c}{\text { Edge-Gradient }(G)=\sqrt{G_{x}^{2}+G_{y}^{2}}} \\ {\text { Angle }(\theta)=\tan ^{-1}\left(\frac{G_{x}}{G_{y}}\right)}\end{array}</script><p>梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线</p>
</li>
</ol>
<p>3.在边缘上使用非最大抑制（NMS）</p>
<p>在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</p>
<p>4.检测到的边缘上使用双阈值去除假阳性：</p>
<p>当图像的灰度梯度高于maxVal 时被认为是真的边界，那些低于minVal 的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃</p>
<p><img src="note of opencv2python/double_threshold.PNG" style="zoom:50%;" /></p>
<p>5.分析所有边缘及其间的连接，保留真正的边缘，消除不明显的边缘</p>
<p>函数实现:cv2.Canny()</p>
<p>第一个参数是输入图像。第二和第三个分别是minVal 和maxVal。第三个参数设置用来计算图像梯度的Sobel<br>卷积核的大小，默认值为3。最后一个参数是L2gradient，它可以用来设定求梯度大小的方程。若为True，平方和开根号，若为False，用绝对值之和来近似，默认为False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img=cv2.Canny(img, <span class="number">50</span>, <span class="number">150</span>, apertureSize=<span class="number">3</span>, L2gradient=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>用滑动条观看阈值对检测效果的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># something wrong</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../images/statue_small.jpg"</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">'canny'</span>)</span><br><span class="line">cv2.createTrackbar(<span class="string">'minval'</span>,<span class="string">'canny'</span>,<span class="number">0</span>,<span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'maxval'</span>,<span class="string">'canny'</span>,<span class="number">0</span>,<span class="number">255</span>, nothing)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    minval = cv2.getTrackbarPos(<span class="string">'minval'</span>,<span class="string">'canny'</span>)</span><br><span class="line">    maxval = cv2.getTrackbarPos(<span class="string">'maxval'</span>,<span class="string">'canny'</span>)</span><br><span class="line">    canny = cv2.Canny(img, minval, maxval)</span><br><span class="line">    cv2.imshow(<span class="string">"image"</span>, img)</span><br><span class="line">    cv2.imshow(<span class="string">"canny"</span>, canny)</span><br><span class="line">    k = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h4 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h4><p>轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同的<strong>颜色或者灰度</strong>。轮廓在形状分析和物体的检测和识别中很有用。注意：</p>
<ol>
<li>为更加准确，寻找轮廓前，进行阈值化或canny边缘检测</li>
<li><code>cv2.findContours()</code>会修改原始图像，若后续想使用原始图像，应使用<code>copyImg = image.copy()</code></li>
<li>查找轮廓是在黑色背景中找白色物体</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>计算多边形边界、形状逼近、计算感兴趣区域</p>
<p>在opencv4中<code>cv2.findContours</code><strong>输入</strong>：第一个是输入图像，第二个是轮廓检索模式，第三个是轮廓近似方法，<code>cv2.CHAIN_APPROX_NONE</code>所有边界点均被存储，<code>cv2.CHAIN_APPROX_SIMPLE</code>去掉轮廓上的冗余点。压缩轮廓，减少内存开支</p>
<p><strong>返回</strong>：只返回轮廓（python列表，每个元素为一个numpy数组）、轮廓的层析结构、不返回图像</p>
<h5 id="轮廓的绘制"><a href="#轮廓的绘制" class="headerlink" title="轮廓的绘制"></a>轮廓的绘制</h5><p><code>cv2.drawContours()</code>输入：原始图像、轮廓、轮廓的索引（设置为-1时绘制所有轮廓、轮廓的颜色、轮廓的厚度，输出：图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bugs:不能读取jpg、JPEG文件，文件路径采用/不要用\</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2.cv2</span><br><span class="line">im = cv2.imread(<span class="string">'D:/opencv_imagedata/data/shape_binary.png'</span>)</span><br><span class="line">imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret,thresh = cv2.threshold(imgray,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE)</span><br><span class="line">img1 = cv2.drawContours(im, contours, <span class="number">-1</span>, (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">img2 = cv2.drawContours(im, contours, <span class="number">3</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">cv2.imshow(<span class="string">"img2"</span>,img2)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h5 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h5><h6 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnt &#x3D; contours[0]</span><br><span class="line">M &#x3D; cv2.moments(cnt)</span><br><span class="line">print(M)</span><br><span class="line">cx &#x3D; int(M[&#39;m10&#39;]&#x2F;M[&#39;m00&#39;])</span><br><span class="line">cy &#x3D; int(M[&#39;m01&#39;]&#x2F;M[&#39;m00&#39;])</span><br></pre></td></tr></table></figure>
<p>根据这些矩的值，我们可以计算出对象的重心:</p>
<script type="math/tex; mode=display">
C_{x}=\frac{M_{10}}{M_{00}}, \quad C_{y}=\frac{M_{01}}{M_{00}}</script><h6 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">area &#x3D; M[&#39;m00&#39;]</span><br><span class="line">area &#x3D; cv2.contourArea(cnt)</span><br></pre></td></tr></table></figure>
<h6 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perimeter &#x3D; cv2.arcLength(cnt,True)</span><br></pre></td></tr></table></figure>
<h6 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epsilon = <span class="number">0.1</span>*cv2.arcLength(cnt,<span class="literal">True</span>)</span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>)</span><br><span class="line">img3 = cv2.drawContours(im, approx, <span class="number">0</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>cv2.approxPolyDP</code>输入：轮廓、原轮廓与近似多边形周长的最大差值，输出与输入曲线类型相同的曲线</p>
<h6 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h6><p>与轮廓近似相似凸性缺陷：一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去了就被叫做凸性缺陷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hull &#x3D; cv2.convexHull(points[, hull[, clockwise[, returnPoints]]</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">points 我们要传入的轮廓</span><br><span class="line">hull 输出，通常不需要</span><br><span class="line">clockwise 方向标志。如果设置为True，输出的凸包是顺时针方向的。</span><br><span class="line">否则为逆时针方向。</span><br><span class="line">returnPoints 默认值为True。它会返回凸包上点的坐标。如果设置</span><br><span class="line">为False，就会返回与凸包点对应的轮廓上的点。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hull &#x3D; cv2.convexHull(cnt)</span><br></pre></td></tr></table></figure>
<p>如<code>returnPoints</code>设置为<code>true</code>返回<code>[[[234 202]], [[ 51 202]], [[ 51 79]], [[234 79]]]</code>;设置为<code>False</code>返回<code>[[129],[ 67],[ 0],[142]]</code>,可认为是<code>cnt</code>这个列表的索引</p>
<h6 id="凸性检测"><a href="#凸性检测" class="headerlink" title="凸性检测"></a>凸性检测</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k = cv2.isContourConvex(cnt)</span><br></pre></td></tr></table></figure>
<p>返回一个布尔值</p>
<h6 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h6><p><strong>直边界矩形</strong>：没有旋转的矩形，矩形面积非最小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x,y,w,h &#x3D; cv2.boundingRect(cnt)</span><br><span class="line">img &#x3D; cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)</span><br></pre></td></tr></table></figure>
<p><strong>旋转的边界矩形</strong></p>
<p>考虑了对象的旋转，矩形面积最小，<code>cv2.minAreaRect()</code>返回的是一个Box2D 结构，其中包含矩形左上角角点的坐标（x，y），矩形的宽和高（w，h），以及旋转角度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for c in contours:</span><br><span class="line">  # find bounding box coordinates</span><br><span class="line">  x,y,w,h &#x3D; cv2.boundingRect(cnt)</span><br><span class="line">  cv2.rectangle(img, (x,y), (x+w, y+h), (0, 255, 0), 2)</span><br><span class="line">  # find minimum area</span><br><span class="line">  rect &#x3D; cv2.minAreaRect(cnt)</span><br><span class="line">  # calculate coordinates of the minimum area rectangle</span><br><span class="line">  box &#x3D; cv2.boxPoints(rect)</span><br><span class="line">  # normalize coordinates to integers</span><br><span class="line">  box &#x3D; np.int0(box)</span><br><span class="line">  # draw contours</span><br><span class="line">  cv2.drawContours(img, [box], 0, (0,0, 255), 3)</span><br></pre></td></tr></table></figure>
<h6 id="最小闭圆（最小外接圆）"><a href="#最小闭圆（最小外接圆）" class="headerlink" title="最小闭圆（最小外接圆）"></a>最小闭圆（最小外接圆）</h6><p>找到一个轮廓的外切圆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x,y),radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">center = (int(x),int(y))</span><br><span class="line">radius = int(radius)</span><br><span class="line">img = cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h6 id="椭圆拟合"><a href="#椭圆拟合" class="headerlink" title="椭圆拟合"></a>椭圆拟合</h6><p>返回旋转边界矩形的内切椭圆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ellipse &#x3D; cv2.fitEllipse(cnt)</span><br><span class="line">img &#x3D; cv2.ellipse(im,ellipse,(0,255,0),2)</span><br></pre></td></tr></table></figure>
<h6 id="直线拟合"><a href="#直线拟合" class="headerlink" title="直线拟合"></a>直线拟合</h6><p>根据轮廓上的点来拟合一条直线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[vx,vy,x,y] = cv2.fitLine(cnt, cv2.DIST_L2,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>)</span><br><span class="line">rows, cols = im.shape[:<span class="number">2</span>]</span><br><span class="line">lefty = int((-x*vy/vx) + y)</span><br><span class="line">righty = int(((cols-x)*vy/vx)+y)</span><br><span class="line">img4 = cv2.line(im,(cols<span class="number">-1</span>,righty),(<span class="number">0</span>,lefty),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h5 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#长宽比：边界矩形的宽高比</span></span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">aspect_ratio = float(w)/h</span><br><span class="line"><span class="comment">#Extent：轮廓面积与边界矩形面积的比</span></span><br><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">rect_area = w*h</span><br><span class="line">extent = float(area)/rect_area</span><br><span class="line"><span class="comment">#Solidity：轮廓面积与凸包面积的比</span></span><br><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line">hull_area = cv2.contourArea(hull)</span><br><span class="line">solidity = float(area)/hull_area</span><br><span class="line"><span class="comment">#Equivalent Diameter（当量直径）：与轮廓面积相等的圆形的直径</span></span><br><span class="line">equi_diameter = np.sqrt(<span class="number">4</span>*area/np.pi)</span><br><span class="line"><span class="comment">#方向：对象的方向，下面的方法还会返回长轴和短轴的长度</span></span><br><span class="line">(x,y),(MA,ma),angle = cv2.fitEllipse(cnt)</span><br><span class="line"><span class="comment">#获取以轮廓包围区域为掩模的方法1：</span></span><br><span class="line">mask = np.zeros(imgray.shape,np.uint8)</span><br><span class="line">cv2.drawContours(mask,[cnt],<span class="number">0</span>,<span class="number">255</span>,<span class="number">-1</span>) <span class="comment"># 这里一定要使用参数-1, 绘制填充的的轮廓</span></span><br><span class="line">pixelpoints = np.transpose(np.nonzero(mask)) <span class="comment">#找到非零元素的坐标再取对角</span></span><br><span class="line">pixelpoints = cv2.findNonZero(mask)</span><br><span class="line"><span class="comment">#原图像中轮廓对应的区域像素极值及其位置，以mask作为一个掩模</span></span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(im,mask = mask)</span><br><span class="line"><span class="comment">#平均颜色</span></span><br><span class="line">mean_color = cv2.mean(im,mask = mask)</span><br><span class="line"><span class="comment">#平均灰度</span></span><br><span class="line">mean_graylevel = cv2.mean(im,mask = mask)</span><br><span class="line"><span class="comment">#获取轮廓的极点</span></span><br><span class="line">leftmost = tuple(cnt[cnt[:,:,<span class="number">0</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">rightmost = tuple(cnt[cnt[:,:,<span class="number">0</span>].argmax()][<span class="number">0</span>])</span><br><span class="line">topmost = tuple(cnt[cnt[:,:,<span class="number">1</span>].argmin()][<span class="number">0</span>])</span><br><span class="line">bottommost = tuple(cnt[cnt[:,:,<span class="number">1</span>].argmax()][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h5 id="凸缺陷"><a href="#凸缺陷" class="headerlink" title="凸缺陷"></a>凸缺陷</h5><p><code>cv2.convexityDefects</code>返回每个凸缺陷的[起点，终点，最远的点，到最<br>远点的近似距离]，注意前三个值均为轮廓点的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv2.imread(<span class="string">'star.jpg'</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(img_gray, <span class="number">127</span>, <span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">hull = cv2.convexHull(cnt,returnPoints = <span class="literal">False</span>)</span><br><span class="line">defects = cv2.convexityDefects(cnt,hull)</span><br><span class="line"><span class="comment">#为何要这样索引？</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(defects.shape[<span class="number">0</span>]):</span><br><span class="line">	s,e,f,d = defects[i,<span class="number">0</span>]</span><br><span class="line">	start = tuple(cnt[s][<span class="number">0</span>])</span><br><span class="line">	end = tuple(cnt[e][<span class="number">0</span>])</span><br><span class="line">	far = tuple(cnt[f][<span class="number">0</span>])</span><br><span class="line">	cv2.line(img,start,end,[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],<span class="number">2</span>)</span><br><span class="line">	cv2.circle(img,far,<span class="number">5</span>,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],<span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="note of opencv2python/star_convex.png" alt="image-20191123134441066"></p>
<h5 id="点与轮廓间的距离"><a href="#点与轮廓间的距离" class="headerlink" title="点与轮廓间的距离"></a>点与轮廓间的距离</h5><p>求解图像中的一个点到一个对象轮廓的最短距离。如果点在轮廓的外部，返回值为负。如果在轮廓上，返回值为0。如果在轮廓内部，返回值为正。</p>
<p>第三个参数是measureDist。如果设置为True，就会计算最短距离。如果是False，只会判断这个点与轮廓之间的位置关系（返回值为+1，-1，0）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dist &#x3D; cv2.pointPolygonTest(cnt,(50,50),True)</span><br></pre></td></tr></table></figure>
<h5 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h5><p><code>cv2.matchShape()</code>比较两个形状或轮廓的相似度，返回值越小匹配越好</p>
<p>原理：Hu矩：Hu 矩是归一化中心矩的线性组合，之所以这样做是为了能够获取代表图像的某个特征的矩函数，这些矩函数对某些变化如缩放，旋转，镜像映射（除了h1）具有不变形</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret = cv2.matchShapes(cnt1,cnt2,<span class="number">1</span>,<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="轮廓的层次结构"><a href="#轮廓的层次结构" class="headerlink" title="轮廓的层次结构"></a>轮廓的层次结构</h5><p>一个形状在另外一个形状的内部，外部的形状为父，内部的形状为子</p>
<h6 id="opencv中的层次结构"><a href="#opencv中的层次结构" class="headerlink" title="opencv中的层次结构"></a>opencv中的层次结构</h6><p>使用一个数组表示：<code>[Next，Previous，First_Child，Parent]</code>，分别表示同级下一个轮廓、同级前一个轮廓、第一个子轮廓、父轮廓，没有时为-1，顺序：从上到下，从左到右</p>
<h6 id="轮廓检索方式"><a href="#轮廓检索方式" class="headerlink" title="轮廓检索方式"></a>轮廓检索方式</h6><ol>
<li><code>RETR_LIST</code>,只是提取所有的轮廓，而不去创建任何父子关系,所有轮廓在同一级别</li>
<li><code>RETR_EXTERNAL</code>,只会返回最外边的的轮廓，所有的子轮廓都会被忽略掉</li>
<li><code>RETR_CCOMP</code>返回所有轮廓，分为两极组织结构，一副黑底白字的图像，图像中是数字0。0 的外边界属于第一级组织结构，0 的内部属于第2 级组织结构</li>
<li><code>RETR_TREE</code>返回所有轮廓，创建完整的组织结构列表</li>
</ol>
<h4 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h4><h5 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h5><p>cv2.threshhold()：</p>
<ul>
<li><p>第一个参数就是原图像，原图像应该是灰度图</p>
</li>
<li><p>第二个参数就是用来对像素值进行分类的阈值</p>
</li>
<li><p>第三个参数就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值</p>
</li>
<li><p>第四个参数表示阈值方法</p>
<p>cv2.THRESH_BINARY：</p>
<script type="math/tex; mode=display">
\operatorname{dst}(x, y)=\left\{\begin{array}{c}{\text { maxval } i f \operatorname{src}(x, y)>\text { thresh }} \\ {0 \text { otherwise }}\end{array}\right.</script><p>cv2.THRESH_BINARY_INV：</p>
<script type="math/tex; mode=display">
\operatorname{dst}(x, y)=\left\{\begin{array}{c}{0 \text { if } \operatorname{src}(x, y)>\text { thresh }} \\ {\text { maxval otherwise }}\end{array}\right.</script><p>cv2.THRESH_TRUNC：</p>
<script type="math/tex; mode=display">
\operatorname{dst}(x, y)=\left\{\begin{array}{c}{\text { threshold } i f \operatorname{src}(x, y)>\text { thresh }} \\ {\operatorname{src}(x, y) \text { otherwise }}\end{array}\right.</script><p>cv2.THRESH_TOZERO：</p>
<script type="math/tex; mode=display">
\operatorname{dst}(x, y)=\left\{\begin{array}{c}{\operatorname{src}(x, y) \text { if } \operatorname{src}(x, y)>\text { thresh }} \\ {0 \text { otherwise }}\end{array}\right.</script><p>cv2.THRESH_TOZERO_INV：</p>
<script type="math/tex; mode=display">
\operatorname{dst}(x, y)=\left\{\begin{array}{c}{0 \text { if } \operatorname{src}(x, y)>\text { thresh }} \\ {\operatorname{src}(x, y) \text { otherwise }}\end{array}\right.</script></li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img=cv2.imread(<span class="string">'gradient.png'</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">ret,thresh2=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">ret,thresh4=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">ret,thresh5=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">6</span>):</span><br><span class="line">	plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span><br><span class="line">	plt.title(titles[i])</span><br><span class="line">	plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="使用git-Typora，github创建笔记"><a href="#使用git-Typora，github创建笔记" class="headerlink" title="使用git, Typora，github创建笔记"></a>使用git, Typora，github创建笔记</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot; #设置秘钥</span><br><span class="line">github上添加秘钥</span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git init #初始化该文件夹</span><br><span class="line">git status #获取当前git状态</span><br><span class="line">git diff #获取文件更改内容</span><br><span class="line">git log #查看修改记录</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:perfectism13&#x2F;learning.git #关联本地与远程仓库</span><br><span class="line">git push -u origin master</span><br><span class="line">git pull git@github.com:perfectism13&#x2F;learning.git</span><br><span class="line">git add . #ubantu中为.&#x2F;</span><br><span class="line">git commit -m &quot;information of update&quot;</span><br><span class="line">git push git@github.com:perfectism13&#x2F;learning.git</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/fanyong/p/3424501.html" target="_blank" rel="noopener"></a></p>
<p><a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/70544159" target="_blank" rel="noopener"></a></p>
<p>windows中的ssh key在c/users/闵晨阳1998/.ssh中</p>
<p>ubantu在home/.ssh中</p>
<h4 id="在matlab中使用hough变换检测圆"><a href="#在matlab中使用hough变换检测圆" class="headerlink" title="在matlab中使用hough变换检测圆"></a>在matlab中使用hough变换检测圆</h4><h5 id="1-编程思路"><a href="#1-编程思路" class="headerlink" title="1.编程思路"></a>1.编程思路</h5><p>1.读入图像，并将其灰度化</p>
<p>2.利用canny算子来检测边缘</p>
<p>3.设定检测时的半径与角度步长，预估被检测圆的半径范围</p>
<p>4.通过圆的参数方程将图像空间(x,y)对应到参数空间(a,b,r)</p>
<p>5.求解半径和圆心</p>
<p>6.合并圆心临近，半径差别不大的圆</p>
<p>7.标记出检测到的圆，并输出圆心坐标和半径</p>
<h5 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%author：minchenyang</span></span><br><span class="line">image = imread(<span class="string">'D:/opencv_imagedata/detect_blob.png'</span>);  </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>),imshow(image),title(<span class="string">'原图'</span>)</span><br><span class="line"><span class="comment">% 将原图灰度化</span></span><br><span class="line">image = rgb2gray(image); </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),imshow(image),title(<span class="string">'灰度化的原图'</span>)  </span><br><span class="line"><span class="comment">%采用canny算子来进行边缘检测</span></span><br><span class="line">edgeimage = edge(image, <span class="string">'Canny'</span>, [<span class="number">0.3</span>, <span class="number">0.35</span>]); </span><br><span class="line"><span class="comment">% 设定检测时的半径与角度步长</span></span><br><span class="line">step_r = <span class="number">1</span>;step_angle = <span class="number">0.1</span>; </span><br><span class="line"><span class="comment">%预估被检测圆的半径范围</span></span><br><span class="line">rmin = <span class="number">10</span>;  rmax = <span class="number">100</span>; </span><br><span class="line"><span class="comment">% 自动取最优的灰度阈值</span></span><br><span class="line">thresh = graythresh(image);  </span><br><span class="line">r_min = rmin;r_max = rmax;</span><br><span class="line">element=[];  para=[];  </span><br><span class="line">p=<span class="number">0.6</span>;<span class="comment">%p=thresh</span></span><br><span class="line">[h,w] = <span class="built_in">size</span>(edgeimage);  </span><br><span class="line">size_r = <span class="built_in">round</span>((rmax-rmin)/step_r)+<span class="number">1</span>; </span><br><span class="line">size_angle = <span class="built_in">round</span>(<span class="number">2</span>*<span class="built_in">pi</span>/step_angle);  </span><br><span class="line">hough_space = <span class="built_in">zeros</span>(h,w,size_r);  </span><br><span class="line"><span class="comment">%查找二值图像中非零元素的行列坐标  </span></span><br><span class="line">[row,col] = <span class="built_in">find</span>(edgeimage);</span><br><span class="line">count = <span class="built_in">size</span>(row);  </span><br><span class="line"><span class="comment">%通过圆的参数方程将图像空间(x,y)对应到参数空间(a,b,r)  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:count  </span><br><span class="line">    <span class="keyword">for</span> r=<span class="number">1</span>:size_r  </span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">1</span>:size_angle</span><br><span class="line">            a = <span class="built_in">round</span>(row(<span class="built_in">i</span>)-(r_min+(r<span class="number">-1</span>)*step_r)*<span class="built_in">cos</span>(k*step_angle)); <span class="comment">% a=x-r*cos(angle)  </span></span><br><span class="line">            b = <span class="built_in">round</span>(col(<span class="built_in">i</span>)-(r_min+(r<span class="number">-1</span>)*step_r)*<span class="built_in">sin</span>(k*step_angle)); <span class="comment">% b=y-r*sin(angle)   </span></span><br><span class="line">            <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;a&lt;=h&amp;&amp;b&gt;<span class="number">0</span>&amp;&amp;b&lt;w)  </span><br><span class="line">                hough_space(a,b,r) = hough_space(a,b,r)+<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% 搜索超过阈值的聚集点</span></span><br><span class="line">max_para = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(hough_space)));</span><br><span class="line">num = <span class="built_in">find</span>(hough_space&gt;=max_para*p);  </span><br><span class="line"><span class="built_in">length</span> = <span class="built_in">size</span>(num);  </span><br><span class="line"><span class="comment">%求解半径和圆心  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:count  </span><br><span class="line">    <span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">length</span>  </span><br><span class="line">        para3 = <span class="built_in">floor</span>(num(k)/(h*w))+<span class="number">1</span>; </span><br><span class="line">        para2 = <span class="built_in">floor</span>((num(k)-(para3<span class="number">-1</span>)*(h*w))/h)+<span class="number">1</span>; </span><br><span class="line">        para1 = num(k)-(para3<span class="number">-1</span>)*(h*w)-(para2<span class="number">-1</span>)*h;</span><br><span class="line">        <span class="keyword">if</span>((row(<span class="built_in">i</span>)-para1)^<span class="number">2</span>+(col(<span class="built_in">i</span>)-para2)^<span class="number">2</span>&lt;(r_min+(para3<span class="number">-1</span>)*step_r)^<span class="number">2</span>+<span class="number">5</span>&amp;&amp;...  </span><br><span class="line">                (row(<span class="built_in">i</span>)-para1)^<span class="number">2</span>+(col(<span class="built_in">i</span>)-para2)^<span class="number">2</span>&gt;(r_min+(para3<span class="number">-1</span>)*step_r)^<span class="number">2</span><span class="number">-5</span>)  </span><br><span class="line">            hough_circle(row(<span class="built_in">i</span>),col(<span class="built_in">i</span>)) = <span class="built_in">true</span>;  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">length</span>  </span><br><span class="line">    para3 = <span class="built_in">floor</span>(num(k)/(h*w))+<span class="number">1</span>;</span><br><span class="line">    para2 = <span class="built_in">floor</span>((num(k)-(para3<span class="number">-1</span>)*(h*w))/h)+<span class="number">1</span>;  </span><br><span class="line">    para1 = num(k)-(para3<span class="number">-1</span>)*(h*w)-(para2<span class="number">-1</span>)*h;  </span><br><span class="line">    element = [element;para1,para2,para3];  </span><br><span class="line">    hough_circle(para1,para2)= <span class="built_in">true</span>;  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">%合并圆心临近，半径差别不大的圆 </span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">size</span>(element,<span class="number">1</span>) &gt;= <span class="number">1</span>  </span><br><span class="line">    num=<span class="number">1</span>;  </span><br><span class="line">    xyr=[];  </span><br><span class="line">    temp1=element(<span class="number">1</span>,<span class="number">1</span>);temp2=element(<span class="number">1</span>,<span class="number">2</span>);temp3=element(<span class="number">1</span>,<span class="number">3</span>);  </span><br><span class="line">    c1=temp1;c2=temp2;c3=temp3;  </span><br><span class="line">    temp3= r_min+(temp3<span class="number">-1</span>)*step_r;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">size</span>(element,<span class="number">1</span>)&gt;<span class="number">1</span>       </span><br><span class="line">        <span class="keyword">for</span> k=<span class="number">2</span>:<span class="built_in">size</span>(element,<span class="number">1</span>)  </span><br><span class="line">          <span class="keyword">if</span> (element(k,<span class="number">1</span>)-temp1)^<span class="number">2</span>+(element(k,<span class="number">2</span>)-temp2)^<span class="number">2</span> &gt; temp3^<span class="number">2</span>  </span><br><span class="line">             xyr=[xyr;element(k,<span class="number">1</span>),element(k,<span class="number">2</span>),element(k,<span class="number">3</span>)];  <span class="comment">%保存剩下圆的圆心和半径位置  </span></span><br><span class="line">          <span class="keyword">else</span>    </span><br><span class="line">            c1=c1+element(k,<span class="number">1</span>);  </span><br><span class="line">            c2=c2+element(k,<span class="number">2</span>);  </span><br><span class="line">            c3=c3+element(k,<span class="number">3</span>);  </span><br><span class="line">            num=num+<span class="number">1</span>;  </span><br><span class="line">          <span class="keyword">end</span>   </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>   </span><br><span class="line">    c1=<span class="built_in">round</span>(c1/num);  </span><br><span class="line">    c2=<span class="built_in">round</span>(c2/num);  </span><br><span class="line">    c3=<span class="built_in">round</span>(c3/num);  </span><br><span class="line">    c3=r_min+(c3<span class="number">-1</span>)*step_r;      </span><br><span class="line">    para=[para;c1,c2,c3]; <span class="comment">%保存各个圆的圆心和半径的值  </span></span><br><span class="line">    element=xyr;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>),imshow(edgeimage),title(<span class="string">'边缘'</span>)  </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>),imshow(hough_circle),title(<span class="string">'检测出的圆上的像素点'</span>)  </span><br><span class="line">element=para;  </span><br><span class="line"><span class="comment">%标记出检测到的圆，并输出圆心坐标和半径  </span></span><br><span class="line">[r,~]=<span class="built_in">size</span>(element);  </span><br><span class="line">fprintf(<span class="number">1</span>,<span class="string">'  检测出%d个圆\n'</span>,r);  </span><br><span class="line">fprintf(<span class="number">1</span>,<span class="string">'  圆心     半径\n'</span>); </span><br><span class="line"><span class="keyword">for</span> w=<span class="number">1</span>:r  </span><br><span class="line">        fprintf(<span class="number">1</span>,<span class="string">'%d （%d，%d）  %d\n'</span>,w,<span class="built_in">floor</span>(element(w,<span class="number">1</span>)),<span class="built_in">floor</span>(element(w,<span class="number">2</span>)),<span class="built_in">floor</span>(element(w,<span class="number">3</span>))); </span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>),imshow(image),title(<span class="string">'检测出图中的圆'</span>)  </span><br><span class="line"><span class="built_in">hold</span> on;  </span><br><span class="line"><span class="built_in">plot</span>(element(:,<span class="number">2</span>), element(:,<span class="number">1</span>), <span class="string">'r+'</span>);  </span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : r   </span><br><span class="line">    t=<span class="number">0</span>:<span class="number">0.01</span>*<span class="built_in">pi</span>:<span class="number">2</span>*<span class="built_in">pi</span>;  </span><br><span class="line">    x=<span class="built_in">cos</span>(t).*element(k,<span class="number">3</span>)+element(k,<span class="number">2</span>);</span><br><span class="line">    y=<span class="built_in">sin</span>(t).*element(k,<span class="number">3</span>)+element(k,<span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">plot</span>(x,y,<span class="string">'.'</span>,<span class="string">'Markersize'</span>,<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="3-结果展示"><a href="#3-结果展示" class="headerlink" title="3.结果展示"></a>3.结果展示</h5><p><img src="note of opencv2python/1.png" style="zoom:80%;" /></p>
<p><img src="note of opencv2python/3.png" style="zoom:80%;" /></p>
<p><img src="note of opencv2python/5.png" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>opencv2python</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>python</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>交流思考</title>
    <url>/2020/07/24/%E4%BA%A4%E6%B5%81%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="交流思考"><a href="#交流思考" class="headerlink" title="交流思考"></a>交流思考</h1><h2 id="2019-12-19下午三点于中楼"><a href="#2019-12-19下午三点于中楼" class="headerlink" title="2019.12.19下午三点于中楼"></a>2019.12.19下午三点于中楼</h2><p>1.如何产生新的idea：</p>
<p>复现论文和阅读论文是一个循环的过程</p>
<p>可以将其他领域的方法移植到自己的问题上来，也就是要找到问题的本质，也要求自己的知识面要足够广，i.e:将NLP中的方法移植到CV中来？</p>
<p>2.要看好的大学的英文论文，要沉下心来，看看别人的想法是什么，最后一定要有自己的想法，找到论文之间的差异性，新颖点，不同点在哪里</p>
<p>3.图像领域重要的就是准确度的提升、工程应用的难易程度？</p>
<p>4.写小论文，申请专利，反复修改，论文框架？</p>
<h2 id="2019-12-19晚11点与天马公寓"><a href="#2019-12-19晚11点与天马公寓" class="headerlink" title="2019.12.19晚11点与天马公寓"></a>2019.12.19晚11点与天马公寓</h2><p>1.善于利用网络问别人问题<br>2.和师兄搞好关系<br>3.寻找每篇论文存在的问题，新颖点<br>4.每周报告认真写报告，越详细越好<br>5.大胆的假设结果，然后向目标求证<br>6.不同角度解读问题<br>7.必要时修改对结果的预判，甚至修改问题<br>8.不打迷糊仗，避免使用大概等词：有方法，有数据，有实验，有证明<br>10.现在每天工作14小时，以后8小时？<br>11.如何阅读论文<br>中国科学，机械工程学报<br>不要找含复杂数学知识的论文<br>重现论文<br>12.创新思维</p>
<p>来源-崔老师《如何做科研》</p>
]]></content>
  </entry>
  <entry>
    <title>使用Google Colab训练模型</title>
    <url>/2020/07/24/%E4%BD%BF%E7%94%A8Google%20Colab%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="使用Google-Colab训练模型"><a href="#使用Google-Colab训练模型" class="headerlink" title="使用Google Colab训练模型"></a>使用Google Colab训练模型</h1><h2 id="挂载Google-Drive并修改运行路径"><a href="#挂载Google-Drive并修改运行路径" class="headerlink" title="挂载Google Drive并修改运行路径"></a>挂载Google Drive并修改运行路径</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!apt-get install -y -qq software-properties-common python-software-properties module-init-tools</span><br><span class="line">!add-apt-repository -y ppa:alessandro-strada&#x2F;ppa 2&gt;&amp;1 &gt; &#x2F;dev&#x2F;null</span><br><span class="line">!apt-get update -qq 2&gt;&amp;1 &gt; &#x2F;dev&#x2F;null</span><br><span class="line">!apt-get -y install -qq google-drive-ocamlfuse fuse</span><br><span class="line">from google.colab import auth</span><br><span class="line">auth.authenticate_user()</span><br><span class="line">from oauth2client.client import GoogleCredentials</span><br><span class="line">creds &#x3D; GoogleCredentials.get_application_default()</span><br><span class="line">import getpass</span><br><span class="line">!google-drive-ocamlfuse -headless -id&#x3D;&#123;creds.client_id&#125; -secret&#x3D;&#123;creds.client_secret&#125; &lt; &#x2F;dev&#x2F;null 2&gt;&amp;1 | grep URL</span><br><span class="line">vcode &#x3D; getpass.getpass()</span><br><span class="line">!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id&#x3D;&#123;creds.client_id&#125; -secret&#x3D;&#123;creds.client_secret&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!mkdir -p drive</span><br><span class="line">!google-drive-ocamlfuse -o nonempty drive</span><br><span class="line">import os</span><br><span class="line">os.chdir(&quot;drive&#x2F;colab&#x2F;resnet_20191204&quot;) #修改此处来修改colab在google drive中的运行路径</span><br></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from google.colab import drive</span><br><span class="line">drive.mount(&#39;&#x2F;content&#x2F;drive&#39;)</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">os.chdir(r&#39;&#x2F;content&#x2F;drive&#x2F;My Drive&#x2F;colab&#x2F;resnet_20191204&#39;)</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure>
<h2 id="使用linux命令安装PyTorch"><a href="#使用linux命令安装PyTorch" class="headerlink" title="使用linux命令安装PyTorch"></a>使用linux命令安装PyTorch</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! pip3 install torch torchvision</span><br></pre></td></tr></table></figure>
<h2 id="用FashionMNIST训练ResNet"><a href="#用FashionMNIST训练ResNet" class="headerlink" title="用FashionMNIST训练ResNet"></a>用FashionMNIST训练ResNet</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">from torch import nn,optim</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(&quot;..&quot;)  #添加当前文件夹为python解释器的模块搜索目录，写成sys.path.append(&quot;d2lzh_pytorch&quot;)也行 </span><br><span class="line">device &#x3D; torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)</span><br><span class="line">print(torch.__version__)</span><br><span class="line">print(device)</span><br><span class="line"></span><br><span class="line">class Residual(nn.Module):  # 本类已保存在d2lzh_pytorch包中方便以后使用</span><br><span class="line">    def __init__(self, in_channels, out_channels, use_1x1conv&#x3D;False, stride&#x3D;1):</span><br><span class="line">        super(Residual, self).__init__()</span><br><span class="line">        self.conv1 &#x3D; nn.Conv2d(in_channels, out_channels, kernel_size&#x3D;3, padding&#x3D;1, stride&#x3D;stride)</span><br><span class="line">        self.conv2 &#x3D; nn.Conv2d(out_channels, out_channels, kernel_size&#x3D;3, padding&#x3D;1)</span><br><span class="line">        if use_1x1conv:</span><br><span class="line">            self.conv3 &#x3D; nn.Conv2d(in_channels, out_channels, kernel_size&#x3D;1, stride&#x3D;stride)</span><br><span class="line">        else:</span><br><span class="line">            self.conv3 &#x3D; None</span><br><span class="line">        self.bn1 &#x3D; nn.BatchNorm2d(out_channels)</span><br><span class="line">        self.bn2 &#x3D; nn.BatchNorm2d(out_channels)</span><br><span class="line"></span><br><span class="line">    def forward(self, X):</span><br><span class="line">        Y &#x3D; F.relu(self.bn1(self.conv1(X)))</span><br><span class="line">        Y &#x3D; self.bn2(self.conv2(Y))</span><br><span class="line">        if self.conv3:</span><br><span class="line">            X &#x3D; self.conv3(X)</span><br><span class="line">        return F.relu(Y + X)</span><br><span class="line"></span><br><span class="line">net &#x3D; nn.Sequential(</span><br><span class="line">        nn.Conv2d(1, 64, kernel_size&#x3D;7, stride&#x3D;2, padding&#x3D;3),</span><br><span class="line">        nn.BatchNorm2d(64), </span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.MaxPool2d(kernel_size&#x3D;3, stride&#x3D;2, padding&#x3D;1))</span><br><span class="line"></span><br><span class="line">def resnet_block(in_channels, out_channels, num_residuals, first_block&#x3D;False):</span><br><span class="line">    if first_block:</span><br><span class="line">        assert in_channels &#x3D;&#x3D; out_channels # 第一个模块的通道数同输入通道数一致</span><br><span class="line">    blk &#x3D; []</span><br><span class="line">    for i in range(num_residuals):</span><br><span class="line">        if i &#x3D;&#x3D; 0 and not first_block:</span><br><span class="line">            blk.append(Residual(in_channels, out_channels, use_1x1conv&#x3D;True, stride&#x3D;2))</span><br><span class="line">        else:</span><br><span class="line">            blk.append(Residual(out_channels, out_channels))</span><br><span class="line">    return nn.Sequential(*blk)</span><br><span class="line"></span><br><span class="line">class GlobalAvgPool2d(nn.Module):</span><br><span class="line">    # 全局平均池化层可通过将池化窗口形状设置成输入的高和宽实现</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(GlobalAvgPool2d, self).__init__()</span><br><span class="line">    def forward(self, x):</span><br><span class="line">        return F.avg_pool2d(x, kernel_size&#x3D;x.size()[2:])</span><br><span class="line"></span><br><span class="line">class FlattenLayer(torch.nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(FlattenLayer, self).__init__()</span><br><span class="line">    def forward(self, x): # x shape: (batch, *, *, ...)</span><br><span class="line">        return x.view(x.shape[0], -1)</span><br><span class="line"></span><br><span class="line">net.add_module(&quot;resnet_block1&quot;, resnet_block(64, 64, 2, first_block&#x3D;True))</span><br><span class="line">net.add_module(&quot;resnet_block2&quot;, resnet_block(64, 128, 2))</span><br><span class="line">net.add_module(&quot;resnet_block3&quot;, resnet_block(128, 256, 2))</span><br><span class="line">net.add_module(&quot;resnet_block4&quot;, resnet_block(256, 512, 2))</span><br><span class="line">net.add_module(&quot;global_avg_pool&quot;, GlobalAvgPool2d()) # GlobalAvgPool2d的输出: (Batch, 512, 1, 1)</span><br><span class="line">net.add_module(&quot;fc&quot;, nn.Sequential(FlattenLayer(), nn.Linear(512, 10))) </span><br><span class="line"></span><br><span class="line">X &#x3D; torch.rand((1, 1, 224, 224))</span><br><span class="line">for name, layer in net.named_children():</span><br><span class="line">    X &#x3D; layer(X)</span><br><span class="line">    print(name, &#39; output shape:\t&#39;, X.shape) #第二个通道数，最后两个为高和宽</span><br><span class="line"></span><br><span class="line">def load_data_fashion_mnist(batch_size, resize&#x3D;None, root&#x3D;&#39;~&#x2F;Datasets&#x2F;FashionMNIST&#39;):</span><br><span class="line">    &quot;&quot;&quot;Download the fashion mnist dataset and then load into memory.&quot;&quot;&quot;</span><br><span class="line">    trans &#x3D; []</span><br><span class="line">    if resize:</span><br><span class="line">        trans.append(torchvision.transforms.Resize(size&#x3D;resize))</span><br><span class="line">    trans.append(torchvision.transforms.ToTensor())</span><br><span class="line">    </span><br><span class="line">    transform &#x3D; torchvision.transforms.Compose(trans)</span><br><span class="line">    mnist_train &#x3D; torchvision.datasets.FashionMNIST(root&#x3D;root, train&#x3D;True, download&#x3D;True, transform&#x3D;transform)</span><br><span class="line">    mnist_test &#x3D; torchvision.datasets.FashionMNIST(root&#x3D;root, train&#x3D;False, download&#x3D;True, transform&#x3D;transform)</span><br><span class="line">    if sys.platform.startswith(&#39;win&#39;):</span><br><span class="line">        num_workers &#x3D; 0  # 0表示不用额外的进程来加速读取数据</span><br><span class="line">    else:</span><br><span class="line">        num_workers &#x3D; 4</span><br><span class="line">    train_iter &#x3D; torch.utils.data.DataLoader(mnist_train, batch_size&#x3D;batch_size, shuffle&#x3D;True, num_workers&#x3D;num_workers)</span><br><span class="line">    test_iter &#x3D; torch.utils.data.DataLoader(mnist_test, batch_size&#x3D;batch_size, shuffle&#x3D;False, num_workers&#x3D;num_workers)</span><br><span class="line"></span><br><span class="line">    return train_iter, test_iter</span><br><span class="line"></span><br><span class="line">def evaluate_accuracy(data_iter, net, device&#x3D;None):</span><br><span class="line">    if device is None and isinstance(net, torch.nn.Module):</span><br><span class="line">        # 如果没指定device就使用net的device</span><br><span class="line">        device &#x3D; list(net.parameters())[0].device </span><br><span class="line">    acc_sum, n &#x3D; 0.0, 0</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        for X, y in data_iter:</span><br><span class="line">            if isinstance(net, torch.nn.Module):</span><br><span class="line">                net.eval() # 评估模式, 这会关闭dropout</span><br><span class="line">                acc_sum +&#x3D; (net(X.to(device)).argmax(dim&#x3D;1) &#x3D;&#x3D; y.to(device)).float().sum().cpu().item()</span><br><span class="line">                net.train() # 改回训练模式</span><br><span class="line">            else: # 自定义的模型, 3.13节之后不会用到, 不考虑GPU</span><br><span class="line">                if(&#39;is_training&#39; in net.__code__.co_varnames): # 如果有is_training这个参数</span><br><span class="line">                    # 将is_training设置成False</span><br><span class="line">                    acc_sum +&#x3D; (net(X, is_training&#x3D;False).argmax(dim&#x3D;1) &#x3D;&#x3D; y).float().sum().item() </span><br><span class="line">                else:</span><br><span class="line">                    acc_sum +&#x3D; (net(X).argmax(dim&#x3D;1) &#x3D;&#x3D; y).float().sum().item() </span><br><span class="line">            n +&#x3D; y.shape[0]</span><br><span class="line">    return acc_sum &#x2F; n</span><br><span class="line"></span><br><span class="line">def train_ch5(net, train_iter, test_iter, batch_size, optimizer, device, num_epochs):</span><br><span class="line">    net &#x3D; net.to(device)</span><br><span class="line">    print(&quot;training on &quot;, device)</span><br><span class="line">    loss &#x3D; torch.nn.CrossEntropyLoss()</span><br><span class="line">    batch_count &#x3D; 0</span><br><span class="line">    for epoch in range(num_epochs):</span><br><span class="line">        train_l_sum, train_acc_sum, n, start &#x3D; 0.0, 0.0, 0, time.time()</span><br><span class="line">        for X, y in train_iter:</span><br><span class="line">            X &#x3D; X.to(device)</span><br><span class="line">            y &#x3D; y.to(device)</span><br><span class="line">            y_hat &#x3D; net(X)</span><br><span class="line">            l &#x3D; loss(y_hat, y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            train_l_sum +&#x3D; l.cpu().item()</span><br><span class="line">            train_acc_sum +&#x3D; (y_hat.argmax(dim&#x3D;1) &#x3D;&#x3D; y).sum().cpu().item()</span><br><span class="line">            n +&#x3D; y.shape[0]</span><br><span class="line">            batch_count +&#x3D; 1</span><br><span class="line">        test_acc &#x3D; evaluate_accuracy(test_iter, net)</span><br><span class="line">        print(&#39;epoch %d, loss %.4f, train acc %.3f, test acc %.3f, time %.1f sec&#39;</span><br><span class="line">              % (epoch + 1, train_l_sum &#x2F; batch_count, train_acc_sum &#x2F; n, test_acc, time.time() - start))</span><br><span class="line"></span><br><span class="line">batch_size &#x3D; 256</span><br><span class="line"># 如出现“out of memory”的报错信息，可减小batch_size或resize</span><br><span class="line">train_iter, test_iter &#x3D; load_data_fashion_mnist(batch_size, resize&#x3D;96)</span><br><span class="line"></span><br><span class="line">lr, num_epochs &#x3D; 0.001, 5</span><br><span class="line">optimizer &#x3D; torch.optim.Adam(net.parameters(), lr&#x3D;lr)</span><br><span class="line">train_ch5(net, train_iter, test_iter, batch_size, optimizer, device, num_epochs)</span><br><span class="line">1.3.1</span><br><span class="line">cuda</span><br><span class="line">0  output shape:     torch.Size([1, 64, 112, 112])</span><br><span class="line">1  output shape:     torch.Size([1, 64, 112, 112])</span><br><span class="line">2  output shape:     torch.Size([1, 64, 112, 112])</span><br><span class="line">3  output shape:     torch.Size([1, 64, 56, 56])</span><br><span class="line">resnet_block1  output shape:     torch.Size([1, 64, 56, 56])</span><br><span class="line">resnet_block2  output shape:     torch.Size([1, 128, 28, 28])</span><br><span class="line">resnet_block3  output shape:     torch.Size([1, 256, 14, 14])</span><br><span class="line">resnet_block4  output shape:     torch.Size([1, 512, 7, 7])</span><br><span class="line">global_avg_pool  output shape:     torch.Size([1, 512, 1, 1])</span><br><span class="line">fc  output shape:     torch.Size([1, 10])</span><br><span class="line">training on  cuda</span><br><span class="line">epoch 1, loss 0.4035, train acc 0.852, test acc 0.892, time 28.7 sec</span><br><span class="line">epoch 2, loss 0.1233, train acc 0.908, test acc 0.904, time 28.5 sec</span><br><span class="line">epoch 3, loss 0.0698, train acc 0.922, test acc 0.909, time 28.5 sec</span><br><span class="line">epoch 4, loss 0.0446, train acc 0.934, test acc 0.916, time 28.5 sec</span><br><span class="line">epoch 5, loss 0.0306, train acc 0.943, test acc 0.905, time 28.5 sec</span><br></pre></td></tr></table></figure>
<p>下面是在自己电脑（GTX-960M）上跑一个batch的数据，整整快了11倍多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">training on  cuda</span><br><span class="line">epoch 1, loss 0.3956, train acc 0.854, test acc 0.888, time 325.2 sec</span><br></pre></td></tr></table></figure>
<h2 id="免费的GPU算力"><a href="#免费的GPU算力" class="headerlink" title="免费的GPU算力"></a>免费的GPU算力</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!nvidia-smi</span><br><span class="line">Wed Dec  4 12:29:39 2019       </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 440.33.01    Driver Version: 418.67       CUDA Version: 10.1     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 |</span><br><span class="line">| N&#x2F;A   38C    P0    34W &#x2F; 250W |   2697MiB &#x2F; 16280MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>经过两次测验分别分配的是 Tesla K80 和 Tesla P100</p>
<h2 id="随机查看一个Batch的数据"><a href="#随机查看一个Batch的数据" class="headerlink" title="随机查看一个Batch的数据"></a>随机查看一个Batch的数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import torchvision</span><br><span class="line"></span><br><span class="line"># functions to show an image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def imshow(img):</span><br><span class="line">    img &#x3D; img &#x2F; 2 + 0.5     # unnormalize</span><br><span class="line">    npimg &#x3D; img.cpu().numpy()</span><br><span class="line">    plt.imshow(np.transpose(npimg, (1, 2, 0)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">classes &#x3D; (&#39;T-shirt&#x2F;top&#39;, &#39;Trouser&#39;, &#39;Pullover&#39;, &#39;Dress&#39;,</span><br><span class="line">           &#39;Coat&#39;, &#39;Sandal&#39;, &#39;Shirt&#39;, &#39;Sneaker&#39;, &#39;Bag&#39;, &#39;Ankle boot&#39;)</span><br><span class="line"># get some random training images</span><br><span class="line">dataiter &#x3D; iter(train_iter)</span><br><span class="line">images, labels &#x3D; dataiter.next()</span><br><span class="line"></span><br><span class="line"># show images</span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"># print labels</span><br><span class="line">print(&#39; &#39;.join(&#39;%5s&#39; % classes[labels[j]] for j in range(4)))</span><br></pre></td></tr></table></figure>
<h2 id="随机选取一个Batch的数据测试"><a href="#随机选取一个Batch的数据测试" class="headerlink" title="随机选取一个Batch的数据测试"></a>随机选取一个Batch的数据测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH &#x3D; &#39;.&#x2F;resnet_20191204.pth&#39;</span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br><span class="line"></span><br><span class="line">dataiter &#x3D; iter(test_iter)</span><br><span class="line">images, labels &#x3D; dataiter.next() #通过next和iter迭代来获取一个批次的装载数据</span><br><span class="line">images, labels &#x3D; images.to(device), labels.to(device)</span><br><span class="line"></span><br><span class="line"># print images</span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line">print(&#39;GroundTruth: &#39;, &#39; &#39;.join(&#39;%5s&#39; % classes[labels[j]] for j in range(4)))</span><br><span class="line">#net &#x3D; Net()</span><br><span class="line">net.load_state_dict(torch.load(PATH))</span><br><span class="line">outputs &#x3D; net(images)</span><br><span class="line">_, predicted &#x3D; torch.max(outputs, 1)</span><br><span class="line"></span><br><span class="line">print(&#39;Predicted: &#39;, &#39; &#39;.join(&#39;%5s&#39; % classes[predicted[j]]</span><br><span class="line">                              for j in range(4)))</span><br><span class="line">GroundTruth:  Ankle boot Pullover Trouser Trouser</span><br><span class="line">Predicted:  Ankle boot Pullover Trouser Trouser</span><br></pre></td></tr></table></figure>
<h2 id="在kaggle中使用tensorboardcolab"><a href="#在kaggle中使用tensorboardcolab" class="headerlink" title="在kaggle中使用tensorboardcolab"></a>在kaggle中使用tensorboardcolab</h2><h3 id="Tensorboardcolab使用笔记"><a href="#Tensorboardcolab使用笔记" class="headerlink" title="Tensorboardcolab使用笔记"></a>Tensorboardcolab使用笔记</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!pip install tensorboardcolab</span><br><span class="line">from tensorboardcolab import TensorBoardColab</span><br><span class="line"></span><br><span class="line">tb &#x3D; TensorBoardColab() #初始化类</span><br><span class="line"></span><br><span class="line">#训练循环里写明</span><br><span class="line">writer.save_value(&#39;Train Loss&#39;, &#39;train_loss&#39;, epoch, epoch_loss)</span><br><span class="line">writer.save_value(&#39;Train Accuracy&#39;, &#39;train_loss&#39;, epoch, epoch_acc)</span><br><span class="line">tb.flush_line(&#39;train_loss&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="core-of-Tensorboardcolab"><a href="#core-of-Tensorboardcolab" class="headerlink" title="core of Tensorboardcolab"></a>core of Tensorboardcolab</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">from keras.callbacks import TensorBoard</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">class TensorBoardColab:</span><br><span class="line">    def __init__(self, port&#x3D;6006, graph_path&#x3D;&#39;.&#x2F;Graph&#39;, startup_waiting_time&#x3D;8):</span><br><span class="line">        self.port &#x3D; port</span><br><span class="line">        self.graph_path &#x3D; graph_path</span><br><span class="line">        self.writer &#x3D; None</span><br><span class="line">        self.deep_writers &#x3D; &#123;&#125;</span><br><span class="line">        self.eager_execution &#x3D; None</span><br><span class="line">        get_ipython().system_raw(&#39;npm i -s -q --unsafe-perm -g ngrok&#39;)  # sudo npm i -s -q --unsafe-perm -g ngrok</span><br><span class="line"></span><br><span class="line">        setup_passed &#x3D; False</span><br><span class="line">        retry_count &#x3D; 0</span><br><span class="line">        sleep_time &#x3D; startup_waiting_time &#x2F; 3.0</span><br><span class="line">        while not setup_passed:</span><br><span class="line">            get_ipython().system_raw(&#39;kill -9 $(sudo lsof -t -i:%d)&#39; % port)</span><br><span class="line">            get_ipython().system_raw(&#39;rm -Rf &#39; + graph_path)</span><br><span class="line">            print(&#39;Wait for %d seconds...&#39; % startup_waiting_time)</span><br><span class="line">            time.sleep(sleep_time)</span><br><span class="line">            get_ipython().system_raw(&#39;tensorboard --logdir %s --host 0.0.0.0 --port %d &amp;&#39; % (graph_path, port))</span><br><span class="line">            time.sleep(sleep_time)</span><br><span class="line">            get_ipython().system_raw(&#39;ngrok http %d &amp;&#39; % port)</span><br><span class="line">            time.sleep(sleep_time)</span><br><span class="line">            try:</span><br><span class="line">                tensorboard_link &#x3D; get_ipython().getoutput(</span><br><span class="line">                    &#39;curl -s http:&#x2F;&#x2F;localhost:4040&#x2F;api&#x2F;tunnels | python3 -c &quot;import sys, json; print(json.load(sys.stdin))&quot;&#39;)[</span><br><span class="line">                    0]</span><br><span class="line">                tensorboard_link &#x3D; eval(tensorboard_link)[&#39;tunnels&#39;][0][&#39;public_url&#39;]</span><br><span class="line">                setup_passed &#x3D; True</span><br><span class="line">            except:</span><br><span class="line">                setup_passed &#x3D; False</span><br><span class="line">                retry_count +&#x3D; 1</span><br><span class="line">                print(&#39;Initialization failed, retry again (%d)&#39; % retry_count)</span><br><span class="line">                print(&#39;\n&#39;)</span><br><span class="line"></span><br><span class="line">        print(&quot;TensorBoard link:&quot;)</span><br><span class="line">        print(tensorboard_link)</span><br><span class="line"></span><br><span class="line">    def get_graph_path(self):</span><br><span class="line">        return self.graph_path</span><br><span class="line"></span><br><span class="line">    def is_eager_execution(self):</span><br><span class="line">        if self.eager_execution is None:</span><br><span class="line">            try:</span><br><span class="line">                tf.summary.FileWriter(self.graph_path)</span><br><span class="line">                self.eager_execution &#x3D; False</span><br><span class="line">            except Exception as err:</span><br><span class="line">                self.eager_execution &#x3D; str(</span><br><span class="line">                    err) &#x3D;&#x3D; &#39;tf.summary.FileWriter is not compatible with eager execution. Use tf.contrib.summary instead.&#39;</span><br><span class="line">        return self.eager_execution</span><br><span class="line"></span><br><span class="line">    def get_writer(self):</span><br><span class="line">        if self.writer is None:</span><br><span class="line">            if self.is_eager_execution():</span><br><span class="line">                self.writer &#x3D; tf.contrib.summary.create_file_writer(self.graph_path)</span><br><span class="line">            else:</span><br><span class="line">                self.writer &#x3D; tf.summary.FileWriter(self.graph_path)</span><br><span class="line"></span><br><span class="line">        return self.writer</span><br><span class="line"></span><br><span class="line">    def get_deep_writers(self, name):</span><br><span class="line">        if not (name in self.deep_writers):</span><br><span class="line">            log_path &#x3D; os.path.join(self.graph_path, name)</span><br><span class="line">            if self.is_eager_execution():</span><br><span class="line">                self.deep_writers[name] &#x3D; tf.contrib.summary.create_file_writer(log_path)</span><br><span class="line">            else:</span><br><span class="line">                self.deep_writers[name] &#x3D; tf.summary.FileWriter(log_path)</span><br><span class="line">        return self.deep_writers[name]</span><br><span class="line"></span><br><span class="line">    def save_image(self, title, image):</span><br><span class="line">        image_path &#x3D; os.path.join(self.graph_path, &#39;images&#39;)</span><br><span class="line">        if self.is_eager_execution():</span><br><span class="line">            print(&#39;Warning: save_image() is not supported in eager execution mode&#39;)</span><br><span class="line">        #           writer &#x3D; tf.contrib.summary.create_file_writer(image_path)</span><br><span class="line">        #           writer.set_as_default()</span><br><span class="line">        #           with tf.contrib.summary.always_record_summaries():</span><br><span class="line">        #               tf.contrib.summary.image(</span><br><span class="line">        #                   title,</span><br><span class="line">        #                   image_tensor</span><br><span class="line">        #               )</span><br><span class="line">        else:</span><br><span class="line">            summary_op &#x3D; tf.summary.image(title, image)</span><br><span class="line">            with tf.Session() as sess:</span><br><span class="line">                summary &#x3D; sess.run(summary_op)</span><br><span class="line">                writer &#x3D; tf.summary.FileWriter(image_path)</span><br><span class="line">                writer.add_summary(summary)</span><br><span class="line">                writer.close()</span><br><span class="line"></span><br><span class="line">    def save_value(self, graph_name, line_name, epoch, value):</span><br><span class="line">        if self.is_eager_execution():</span><br><span class="line">            self.get_deep_writers(line_name).set_as_default()</span><br><span class="line">            global_step &#x3D; tf.train.get_or_create_global_step()</span><br><span class="line">            global_step.assign(epoch)</span><br><span class="line">            with tf.contrib.summary.always_record_summaries():</span><br><span class="line">                tf.contrib.summary.scalar(graph_name, value)</span><br><span class="line">        else:</span><br><span class="line">            summary &#x3D; tf.Summary()</span><br><span class="line">            summary_value &#x3D; summary.value.add()</span><br><span class="line">            summary_value.simple_value &#x3D; value</span><br><span class="line">            summary_value.tag &#x3D; graph_name</span><br><span class="line">            self.get_deep_writers(line_name).add_summary(summary, epoch)</span><br><span class="line"></span><br><span class="line">    def flush_line(self, line_name):</span><br><span class="line">        self.get_deep_writers(line_name).flush()</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        if self.writer is not None:</span><br><span class="line">            self.writer.close()</span><br><span class="line">            self.writer &#x3D; None</span><br><span class="line">        for key in self.deep_writers:</span><br><span class="line">            self.deep_writers[key].close()</span><br><span class="line">        self.deep_writers &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cv2-imshow碰到cannot-connect-to-X-server"><a href="#cv2-imshow碰到cannot-connect-to-X-server" class="headerlink" title="cv2.imshow碰到cannot connect to X server"></a>cv2.imshow碰到cannot connect to X server</h2><p>X server是Linux系统上提供图形用户界面的服务程序。当客户端主机Client访问服务器Server上的图形程序时，需要Server对该Client赋能访问图形程序的权限</p>
<p>OpenCV采用highgui，而命令行下无法产生图形界面</p>
<p>改用matplotlib</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">original_image &#x3D; &#39;a.jpg&#39;</span><br><span class="line">image &#x3D; cv2.imread(original_image)</span><br><span class="line">show_img &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line">plt.imshow(show_img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="在线编辑py文件"><a href="#在线编辑py文件" class="headerlink" title="在线编辑py文件"></a>在线编辑py文件</h2><p>anyfile-notepad</p>
]]></content>
  </entry>
  <entry>
    <title>动作（行为）识别与分类</title>
    <url>/2020/07/24/%E5%8A%A8%E4%BD%9C%EF%BC%88%E8%A1%8C%E4%B8%BA%EF%BC%89%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="动作（行为）识别与分类"><a href="#动作（行为）识别与分类" class="headerlink" title="动作（行为）识别与分类"></a>动作（行为）识别与分类</h1><p>闵晨阳 2019年12月</p>
<h2 id="视频理解"><a href="#视频理解" class="headerlink" title="视频理解"></a>视频理解</h2><p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/VideoUnderstanding.png" alt="img"></p>
<p>长期动作和短期动作的区别</p>
<h2 id="图像分类的传统方法"><a href="#图像分类的传统方法" class="headerlink" title="图像分类的传统方法"></a>图像分类的传统方法</h2><p>传统方法：特征提取与特征分类两个过程进行的。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/image-20191211151744336.png" alt="image-20191211151744336"></p>
<h3 id="特征提取概述"><a href="#特征提取概述" class="headerlink" title="特征提取概述"></a>特征提取概述</h3><p><strong>视频本身时间维度上的特征</strong>:</p>
<p><strong>每一帧图像二维空间上的特征</strong>：根据像素<strong>梯度变化</strong>，如一阶、二阶导数与几何特征来进行角点、边缘、区域的检测，<strong>边缘</strong>是图像亮度变化不连续或突变的位置，<strong>角点</strong>是边缘发生不连续或突变的位置，即边缘曲线的曲率极大值的地方。</p>
<ul>
<li><strong>角点检测</strong>：Harris、Kitchen-Rosenfeld角、Shi-Tomasi和FAST角点检测方法</li>
<li><strong>边缘检测</strong>：Sobel、Lapacian、Canny边缘检测方法</li>
<li><strong>局部特征</strong>：如SIFT、SURF、STAR、BRISK、BRIEF、ORB、SimpleBlob方法</li>
<li><strong>针对图像内人体的特征提取办法</strong>：HoG、HoF、MBH等</li>
</ul>
<p>(1). Harris角点检测是通过设置好的窗口在图像上进行滑动来计算局部信号的自相关函数的矩阵特征值与迹，获得极值后从而确定角点位置，具有旋转不变性、尺度不变性和光照不变性特征，算法介绍详见 <a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/ronny/p/4009425.html">Harris角点</a>，算法实现详见corner.cpp的cv::cornerHarris()函数。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-2b14ef871ea0c07cbbcd6cc26766970f_hd.jpg" alt="img">小窗口在图像中的平移(光滑区、边缘区与角点区)</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-521fd66f5e5f65592be01f496da4342c_hd.jpg" alt="img"></p>
<p> 自相关二项函数的椭圆曲线扁率及尺寸，由本征值决定</p>
<p>(2). Kitchen-Rosenfeld角点检测是通过计算边缘曲线曲率和梯度幅度的乘积来获得响应极值(人工设置阈值)从而确定角点位置，算法实现详见corner.cpp的cv::preCornerDetect()函数。</p>
<p>(3). Shi-Tomasi角点检测通过设置好的窗口在图像上进行滑动来计算局部信号的自相关函数的矩阵特征值的大小来判断是否是角点，是对Harris角点算法进行了改进，对非极大值进行了抑制，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/tostq/article/details/49178601">Shi_Tomasi角点</a>，在OpenCV中又称GFTT(GoodFeatureToTrack)特征点检测算法，算法实现详见featureselect.cpp的cv::goodFeaturesToTrack()函数。</p>
<p>(4). FAST角点检测通过圆周和圆心的像素点亮度情况，来判断圆心是否为角点，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ronny/p/4078710.html">FAST特征点检测</a>，算法实现详见fast.cpp。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-991bebbb04201340457fb524174c2c7f_hd.jpg" alt="img"></p>
<p> FAST角点的圆周检测</p>
<p>边缘检测包括Sobel、Lapacian、Canny边缘检测方法。</p>
<p>(1). Sobel边缘检测，通过高斯平滑滤波和一阶微分求导，对图像灰度函数的近似梯度进行计算，从而判断边缘，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/xiaqunfeng123/article/details/17302003">Sobel 边缘检测算子</a>，算法实现详见Deriv.cpp的cv::Sobel函数。</p>
<p>(2). Lapacian边缘检测，通过高斯平滑滤波和二阶微分求导，对图像灰度函数的近似梯度进行计算，从而判断边缘，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/xiaowei_cqu/article/details/7829481">拉普拉斯算子</a>。</p>
<p>(3). Canny边缘检测是通过对图像进行二维高斯平滑滤波、Sobel算子的梯度检测、求取水平方向与垂直方向梯度的L2/L1范数、非极大值抑制和滞后阈值处理五个过程从而确定边缘位置，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/dcrmg/article/details/52344902">Canny边缘检</a>测，算法详见canny.cpp的cv::Canny()函数。</p>
<p>除了角点和边缘，还可以提取图像的某种局部特征，如SIFT、SURF、STAR、BRISK、BRIEF、ORB、SimpleBlob方法</p>
<p>(1). SIFT即尺度不变特征变换，该算法通过不同尺度空间内的极值检测、特征点定位、梯度方向(梯度的幅值和幅角)确定、描述符生成四个过程，实现了局部特征的提取，该特征具有尺度不变性，且对亮度变化、噪声、视角变化下有一定的稳定性和抗干扰性，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/wangguchangqing/p/4853263.html">SIFT特征详解</a>，算法实现详见sift.cpp。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-3d4b45b999c08402d288aee3689fa128_hd.jpg" alt="img"></p>
<p> SIFT中的尺度空间金字塔</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-addfdaf72392dcc70833d5cd47d66460_hd.jpg" alt="img">SIFT中16个Keypoint生成的128维向量</p>
<p>(2). SURF即加速鲁棒性特征，该算法通过Hessian矩阵和LoG方法对特征点进行检测、积分图像的尺度空间建立、特征点定位、梯度方向(梯度的幅值和幅角)确定、描述符生成五个过程，实现了局部特征的提取，该算法与SIFT的过程类似也具有尺度不变性，但计算效率和鲁棒性优于SIFT，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/dcrmg/article/details/52601010">Surf算法特征点检测与匹配</a>，算法实现详见surf.cpp。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-b79ab065fb0e9de19de41999af376646_hd.jpg" alt="img">SURF的主方向</p>
<p>(3). STAR算法通过星型滤波器计算图像中每个像素点的响应值，再对响应值进行非极大抑制与直线抑制(提取边缘判断)，从而确定特征点位置，算法详见StarDetector.cpp。</p>
<p>(4). BRISK即二进制鲁棒不变尺度关键点，该算法是通过尺度空间建立、特征点检测、非极大值抑制、特征点信息提取四个过程，比较特征点邻域采样像素之间的灰度值形成二进制字符串，进行汉明距离匹配得到特征描述符，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/hujingshuang/article/details/47045497">BRISK特征提取算法</a>，算法实现详见Brisk.cpp。</p>
<p>(5). BRIEF即二进制鲁棒独立元素特征，该算法通过patch区域建立、像素点灰度值比较，从而确定特征点位置，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/hujingshuang/article/details/46910259">BRIEF特征点描述算法</a>，算法实现详见Brief.cpp。</p>
<p>(6). ORB即面向FAST和旋转BRIEF特征，该算法通过patch区域建立、强度质心搜索，从而确定特征点位置，该特征点有旋转不变性，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/wangyaning/p/7854017.html">ORB特征</a>，算法实现详见Orb.cpp。</p>
<p>(7). SimpleBlob算法通过灰度图像二值化转换(连续阈值一转多)，连同区域提取、斑点分类、斑点位置尺寸确定四个过程，检测斑点类的特征点，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhaocj/article/details/44886475">SimpleBlobDetector</a>，算法实现详见BlobDetecot.cpp。</p>
<p>(8). MSER即最大稳定极值区域检测，该算法通过改进的分水岭方法，进而判断图像的斑点区域，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhaocj/article/details/40742191">MSER</a>，算法实现详见Mser.cpp。</p>
<p>除了通用的上述特征外，还有针对图像内人体的一些特征的提取方法，如HoG、HoF、MBH等方法。</p>
<p>(1). HoG特征用来表达局部目标外观形状的梯度方向分布密度，或称梯度统计信息，通过将图像分成小的连通区域(细胞单元)，并将单元内的各项度点梯度或边缘计算其方向与横轴的夹角，根据圆内划分区域内梯度方向的数量分布构建成直方图，最后组合起来形成特征描述，论文见《Histograms of Oriented Gradients for Human Detection》，算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/kuweicai/article/details/78981150">HOG特征检测</a>，算法实现详见HoG.cpp。早期的行人检测算法都是HoG+SVM来实现的。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-378f90fb6afb7533685ee0c1e7860523_hd.jpg" alt="img">基本HoG特征</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-d4b05234a58d4e4cc945c707997a5412_hd.jpg" alt="img">HoG的平均梯度(a)、正负SVM(b、c)、测试图像(d)、矩形HoG描述符(e)、带SVM正负权重的HoG描述符(f、g)</p>
<p>(2). HoF特征类似于HoG特征，只是用光流来代替梯度，即计算光流方向与横轴的夹角，根据圆内划分区域内光流方向的数量分布构建成直方图，最后组合起来形成特征描述。HoF算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013089961/article/details/44981815">HOF特征</a>，光流算法介绍详见<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/carson2005/article/details/7581642">光流法简单介绍</a>。</p>
<p>(3). MBH特征也是通过计算光流获得，但它是将x方向和y方向上光流图像看作为两张灰度图像，然后提取灰度图像的梯度直方图，即再图像的x、y方向光流图像上计算HoG特征。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-d10b14b25101eaeea60c8785d1fc99bc_hd.jpg" alt="img">相邻两帧(a、b)、光流及边界(c、d)、光流场强度(e、f)、MBH描述符(g、h)</p>
<p>在特征分类上，基本方法是使用kNN或SVM分类器对提取的图片特征进行分类，这两种算法的介绍比较多在此不详细展开。</p>
<p><strong>特征分类</strong>：KNN,SVM</p>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>传统方法一般依据人体行为的构成方式，分为整体表示方式和局部表示方式。</p>
<h4 id="整体表示方式"><a href="#整体表示方式" class="headerlink" title="整体表示方式"></a>整体表示方式</h4><p>将视频帧看作一个整体，通过人体定位-&gt;背景提取追踪-&gt;ROI编码一系列过程，自上而下的提取出全局特征。</p>
<p><strong>优点</strong>：编码信息比较丰富</p>
<p><strong>缺点</strong>：过于依赖准确的定位、精确的背景提取追踪</p>
<p> 对摄像机视点、噪声、遮挡极其敏感</p>
<h5 id="ROI提取表示"><a href="#ROI提取表示" class="headerlink" title="ROI提取表示"></a>ROI提取表示</h5><p>用到的方法有背景剪除法、差分法和光流法，轮廓边缘特征包括运动能量图像(Motion Energy Image, MEI)、运动历史图像(Motion History Image, MHI)、形状上下文(Shape Context, SC)等</p>
<p><strong>优点</strong>：算法相对简单</p>
<p><strong>缺点</strong>：背景剪除可能带来很多噪声，导致人体行为特征很难精确描述，即准确率大大受限于人体行为轮廓提取及帧序列中轮廓的跟踪</p>
<h5 id="时空体积-Space-time-volume-表示"><a href="#时空体积-Space-time-volume-表示" class="headerlink" title="时空体积(Space-time volume)表示"></a>时空体积(Space-time volume)表示</h5><p>将给定序列的帧进行堆叠，但是也需要精确的定位、对齐以及背景剪除。</p>
<h5 id="网络切分-Grid-based-表示"><a href="#网络切分-Grid-based-表示" class="headerlink" title="网络切分(Grid-based)表示"></a>网络切分(Grid-based)表示</h5><p>将待识别的人体区域ROI分割成若干时间空间网格，每个网格代表视频帧的一部分特征，网格的组合才代表ROI的整体特征</p>
<p><strong>优点</strong>：减少ROI中存在的噪声，降低了视角变化带来的细微差异，平滑了自身遮挡产生区分度较差的特征空间</p>
<h4 id="局部表示方式"><a href="#局部表示方式" class="headerlink" title="局部表示方式"></a>局部表示方式</h4><p>将视频段落作为一个整体，通过时空兴趣点检测-&gt;邻域特征点计算-&gt;特征整合与表达一系列过程，自下而上的提取特征</p>
<p><strong>优点</strong>：编码信息比较丰富</p>
<p> 不依赖背景提取、追踪算法</p>
<p><strong>缺点</strong>：依赖兴趣点提取的数量和预处理方法</p>
<p> 摄像机运动产生的误差也会对兴趣点采集造成影响</p>
<h5 id="时空兴趣点检测"><a href="#时空兴趣点检测" class="headerlink" title="时空兴趣点检测"></a>时空兴趣点检测</h5><p>在时空域内提取出兴趣点，该兴趣点是空域时域均变化显著的邻域点，如3D Harris。</p>
<p>有时候多个时空兴趣点的组合也称为局部描述符，描述符已经不再仅仅关注于某些点，而是更上层的关注并描述视频中人体特征的局部，比如3D-HOG(Histogram of Gradien) 《A spatio-temporal descriptor based on 3D-gradients》、3D-SIFT(Scale Invariangt Feature Transform)《A 3-dimensional SIFT descriptor and its application to action recognition》、3D SURF(Speeded-Up Robust Features)《An Efficient Dense and Scale-Invariant Spatio-Temporal Interest Point Detector》。</p>
<h6 id="STIP"><a href="#STIP" class="headerlink" title="STIP"></a>STIP</h6><p>《On space-time interest points》</p>
<ol>
<li>首先对视频进行时间和空间上的尺度变换，即通过不同尺度的高斯滤波函数将视频转为线性尺度空间表示，得到了3D Harris的时空域表达形式</li>
<li>进行时空尺度自适应调整，通过尺度归一化来去除尺度因子对兴趣点的影响，归一化时空尺度的极大值(拉普拉斯极大值:拉普拉斯方程解处的函数值)就是角点函数的极大值，需要类似于EM的算法一面计算能达到极大值的尺度，一面计算在该尺度下重新计算兴趣点的位置，直到位置与尺度收敛</li>
<li>要对这些时空兴趣点将噪声去除，进行分类并用分别向量表示，用马氏距离的k-means进行聚类</li>
</ol>
<p>时空兴趣点本质是通过映射函数把视频这个三维的函数映射到一维空间中，再求此一维空间的局部极大值的点。尺度因子对兴趣点的影响较大，时间尺度因子越大更能检测出动作时间较长的兴趣点，时间尺度因子越小更能检测出动作时间较短的兴趣点，空间尺度越大更能检测出动作幅度较大的兴趣点，作者采用能够表征运动和动作外观信息的局部描述算子，最终组合成34维特征向量。</p>
<h6 id="Cuboid"><a href="#Cuboid" class="headerlink" title="Cuboid"></a>Cuboid</h6><p>《Behavior Recognition via Sparse Spatio-Temporal Features》</p>
<p>STIP的缺点：</p>
<p>使用的是Harris角点，但是对于<strong>动作幅度很小的情形(如面部的表情变化)，或是动作幅度有周期性的情形(如车轮旋转)Harris角点很少</strong>，这一时空角点所产生的特征过于稀疏无法去描述反映特征。</p>
<p>作者提出的Cuboid时空特征点检测器基于时域Gabor滤波器的检测器，能够弥补Harris检测器的不足，检测出很多动作幅度小或是周期性运动的特征。</p>
<p>算法过程：</p>
<ol>
<li>通过特征点检测器检测出兴趣点，再扩展成一个Cuboid(长和宽是检测尺度的6倍)</li>
<li>进行简单变换，特征向量统计处理进行相似度比较</li>
<li>对于Cuboid原型使用k-means进行聚类，对于聚类后的行为描述符可以用卡方距离或SVM来进行分类</li>
</ol>
<p>由于没有尺度变换过程，所以该特征不是尺度不变的，简单变换方法作者尝试了3种，分别是归一化像素值、亮度梯度、加窗光流，特征向量统计处理方法作者尝试了3种，分别是直接使用、全局直方图、局部直方图，最后得出结果是求亮度梯度+局部直方图分类误差最小。</p>
<h6 id="MEI-MHI"><a href="#MEI-MHI" class="headerlink" title="MEI+MHI"></a>MEI+MHI</h6><p>《The recognition of human movement using temporal templates》</p>
<p>作者独特的把行为识别分成了基于人体模型重建的、基于表观模板的和基于运动的三类方法。</p>
<p>人体三维结构重建过于复杂，表观模板有的仅仅是二维的剪影、轮廓或边缘，运动模板主要是光流。</p>
<p>算法过程：</p>
<ol>
<li>先在T时间内通过帧差法检查像素点运动</li>
<li>二值化成MEI，灰度化成MHI</li>
<li>利用马氏距离进行目标匹配</li>
</ol>
<p>帧间差分法是<a href="https://blog.csdn.net/yangleo1987/article/details/79745279" target="_blank" rel="noopener">背景提取算法</a>的一种：将视频流中相邻两帧或相隔几帧图像的两幅图像像素值相减，并对相减后的图像进行阈值化来提取图像中的运动区域</p>
<h6 id="HoG-HoF"><a href="#HoG-HoF" class="headerlink" title="HoG+HoF"></a>HoG+HoF</h6><p>《Learning realistic human actions from movies》</p>
<p>作者结合了Cuboid的思路和HoG、HoF的特征描述，将视频中多尺度Harris角点特征提取后将兴趣点周围的提及划分成若干个Cuboid，并计算每个Cuboid的HoG和HoF特征，最后将归一化后的方向直方图向量串联构成描述符。</p>
<h5 id="局部网格表示"><a href="#局部网格表示" class="headerlink" title="局部网格表示"></a>局部网格表示</h5><p>类似于整体网格表示，只不过是将局部的patch放入了网格单元中</p>
<h3 id="特征融合"><a href="#特征融合" class="headerlink" title="特征融合"></a>特征融合</h3><p>在特征融合方面，人体的轮廓、边缘、运动特征等方面<strong>不具备通用性</strong>，只有将其组合起来，才能构建出更好鲁棒性和有效性的特征。在特征提取之后，为了使特征具有较高的区分能力，去掉冗余信息，提高目标识别的计算效率，需要对所提取的特征进行融合，这一过程也称为<strong>特征编码</strong>，主流的特征编码方式有Bag of Feature和Fisher Vector两种。有些文献中，特征提取后的结果(如纹理、轮廓、角点、边缘、光流)称为<strong>低级特征</strong>，特征融合后的结果称为<strong>中级特征(或中级语义)</strong>，特征分类后的结果称为<strong>高级特征(或高级语义)</strong>。</p>
<h4 id="Bag-of-Feature-词袋-，Bag-of-Visual"><a href="#Bag-of-Feature-词袋-，Bag-of-Visual" class="headerlink" title="Bag of Feature(词袋)，Bag of Visual"></a>Bag of Feature(词袋)，Bag of Visual</h4><p>《Beyond Bags of Features: Spatial Pyramid Matching for Recognizing Natural Scene Categories》</p>
<p>概念起源于文本分类里的词袋模型（Bag of Words)。特征提取由于都是底层特征，<strong>或多或少会受到光照、遮挡、背景等干扰</strong>，而融合之后的特征能够提炼出局部关键点不变特征，所以需要进行融合表达。</p>
<p>视觉词袋从<strong>时空兴趣点生成的特征描述子进行聚类</strong>获得，每一个聚类的中心就可以看做是一个视觉单词，由于和文本有所差异，故还需要解决<strong>局部特征抽样策略、词典大小、可视化单词的权重计算以及全局词典的构建</strong>等问题。</p>
<p>算法过程：</p>
<ol>
<li><p>提取图像视频特征，其次对特征进行聚类得到一部字典(Visual Vocabulary，或Code Book)</p>
</li>
<li><p>提取图像视频特征，其次对特征进行聚类得到一部字典(Visual Vocabulary，或Code Book)，通过区分度高的特征来寻找聚类中心</p>
</li>
<li><p>最后作为特征分类器的输入对分类器进行训练</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-1c5477dd52d4e32c9d97058045f0b942_hd.jpg" alt="img"></p>
</li>
</ol>
<h4 id="Fisher-Vector"><a href="#Fisher-Vector" class="headerlink" title="Fisher Vector"></a>Fisher Vector</h4><p>《Fisher Kernels on Visual Vocabularies for Image Categorization》</p>
<p>概率与似然性的区别：</p>
<p>概率，用于在已知一些参数的情况下，预测接下来在观测上所得到的结果；似然性，则是用于在已知某些观测所得到的结果时，对有关事物之性质的参数进行估值。——摘自维基百科</p>
<p>Bag of Feature的缺点：</p>
<p>融合图像底层特征分布时没有考虑这些特征在图像中的相对或绝对位置，且频率直方图的计算量较大，每加入一个类别需要重新进行训练，所以不具备特征的普遍性和紧凑性</p>
<p>Fisher Vector通过似然函数的梯度向量来表达一幅图像，由于图像的概率密度函数是由图像中所有SIFT描述子的概率密度组成的，且每个描述子本质上是由K个高斯模型加权得到的，故整个图像就是由大量高斯模型生成出来的，对每个高斯模型参数求偏导得到的特征向量可以反映该高斯模型在图像中的分布情况。</p>
<p>Fisher Vector通过模型化信号的产生过程，通过EM算法训练SIFT描述子得到每个视觉单词(视觉单词和前文Visual Word不同，并不是词汇描述而是K组高斯模型参数)的权重、均值和协方差矩阵，<strong>图像表示向量维数比Bag of Feature要高，但开销不大</strong>。</p>
<h3 id="特征分类"><a href="#特征分类" class="headerlink" title="特征分类"></a>特征分类</h3><h4 id="直接分类法"><a href="#直接分类法" class="headerlink" title="直接分类法"></a>直接分类法</h4><p>直接分类法需要对提取出来或编码后的行为特征进行降维处理(如PCA)来减少计算复杂度、去除噪声，再用KNN、SVM等传统分类器进行分类，不同特征之间距离的计算可以通过欧式距离、马氏距离等进行度量。</p>
<h4 id="时域状态空间融合模型"><a href="#时域状态空间融合模型" class="headerlink" title="时域状态空间融合模型"></a>时域状态空间融合模型</h4><p>利用动态时间规划(Dynamic Time Warping, DTW)或动态时空规划(Dynamic Space-Time Warping, DSTW)，对不同尺度的时间维度进行对齐，或利用生成模型(如HMM)判别模型(如CRF、MEMM)进行分类判断。</p>
<p>DTW本质上是一个优化问题，用<strong>满足一定条件的时间规整函数来描述输入模板和参考模板的时间对应关系</strong>，进而求解两<strong>模板匹配时累计距离最小</strong>所对应的规整函数。</p>
<h5 id="动态时间规划"><a href="#动态时间规划" class="headerlink" title="动态时间规划"></a>动态时间规划</h5><p>来源于语音识别的方法。和语音信号的随机性类似，视频中的动作行为对于不同的人不同场景下结果是不同的，不可能具有完全相同的时间长度，故<strong>在与已存储模板相匹配时，未知的时间轴要不均匀地扭曲或弯折</strong>，以使其特征与模板特征对正。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-ca8dbeb420bbab322d90e7fbe7615be3_hd.jpg" alt="img"></p>
<p>如上图所示，两个相同的动作行为时间序列上表征可能有所差异，需要把时间序列进行延伸和缩短来计算两个时间序列性之间的相关性。方法是用代价矩阵来表示归整路径(Warp Path)，用动态规划的算法来对距离最短路径进行求解.</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-127ad4b77abd30747036d527a8a4e83d_hd.jpg" alt="img"></p>
<h3 id="以iDT算法为例看传统方法的出理过程"><a href="#以iDT算法为例看传统方法的出理过程" class="headerlink" title="以iDT算法为例看传统方法的出理过程"></a>以iDT算法为例看传统方法的出理过程</h3><p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-bdaa9a162be9f337364b6d40b585476c_hd.jpg" alt="img"></p>
<p>《Dense Trajectories and Motion Boundary Descriptors for Action Recognition》和《Action Recognition with Improved Trajectories》</p>
<p>iDT算法再特征提取上采用了上文中的整体表示方法的时空体积方法，特征融合上采用了Fisher Vector方法，特征分类方面采用了<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Radial_basis_function_kernel">RBF-SVM</a>方法，并采用one-versus-rest策略训练多类分类器</p>
<p>(1). 摄像机预处理</p>
<p>这个过程的目的在于对摄像机的抖动进行消除，因为摄像机的运动会对光流的计算以及轨迹分布有较大影响，要消除这种干扰就要对摄像机的运动有所估计，从而消除背景区域的光流。由于前提设定为相邻两帧图像变化较小，故摄像机运动估计算法本质上是求解前后帧图像计算投影变换矩阵来实现的，而计算投影变换矩阵需要使用<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Random_sample_consensus">RANSAC算法</a>来估计，该算法需要对两幅图像进行匹配，iDT中选择了SURF特征与光流特征作为匹配特征。有了投影变换矩阵，从而可以获得假定摄像机不运动的校正后图像，从而计算出优化过的光流。</p>
<p>但是如果视频中人体所占比例较大，可能也会被误认为运动的背景，导致投影矩阵估计不准确，iDT使用了一个human detector并对检测到的人体用矩形框标注出来，框中的匹配点不进行计算。</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-7488d31a771f1e82d46a6fc424cd9304_hd.jpg" alt="img">图14 未经过人体矩形框处理的摄像机校正和经过人体矩形框处理后的摄像机校正</p>
<p>(2). 帧间特征提取</p>
<p>首先构建出多尺度空间，在空间中进行密集特征点采样，帧间特征体现的是一个运动的过程，所以需要对这种特征进行跟踪。每个图像都能的到坐标，并可以通过密集光流场与中值滤波器的乘积计算出该特征点下一帧图像的位置，进而得到了该特征点的一段轨迹。再将轨迹正则化后转为一种特征描述子，包括水平和垂直两个方向。</p>
<p>此外对于不重要的特征点需要设置阈值去除，是通过计算特征点的自相关矩阵的特征值(eigenvalue，不是feature)来和阈值进行比较，并合理去除。</p>
<p>iDT选择尺度数为8，特征点采样间隔为5，连续采集帧数为15，轨迹特征描述子维度为30。</p>
<p>(3). 帧内特征提取</p>
<p>帧内主要提取HoG特征、HoF特征与MBH特征，具体描述可见上一节课。这里的帧内更准确的说是特征点周围N<em>N这个时空体内进行特征提取，空间每个方向分为a份，时间上分为b份，则HoG特征维度为a</em>a<em>b</em>直方图bin数量，HoF特征维度为a<em>a</em>b<em>(直方图bin数量+1)，MBH特征是N</em>b*2。计算后再对三种特征进行L1正则化后再对特征的每个维度开平方。</p>
<p>i一般N为23，a为2，b为3，直方图bin数量为8，故HoG特征、HoF特征与MBH特征维度分别 96、108、192。</p>
<p>(4). 特征编码</p>
<p>iDT中，先进行了一次PCA降维，再进行Fisher Vector编码。PCA的介绍比较多在此不详细展开。Fisher特征即用似然函数的梯度向量来表达。首先各个维度的分布看成独立同分布高斯分布，则图像上的概率分布就是各个特征维度概率分布的乘积，其次对这个乘积(或是取对数后的和)对权重、均值、方差求偏导，再次，用Fisher matrix进行归一化，最后得出融合后的特征数。如果输入特征有d维，用k个高斯分布去拟合，则输出特征有(2<em>d+1)</em>k-1维。通常使用机器学习中的EM来求解GMM的各项参数。论文参见《Image Classification with the Fisher Vector: Theory and Practice》。</p>
<p>iDT中，原始维度d=426(30+96+108+192)，PCA后降为1/2，输入维度d=213，k=256，输出维度为109311.</p>
<p>(5). 特征分类</p>
<p>使用RBF-SVM进行分类。</p>
<p>one-versus-all即训练时依次把某个类别的样本归为一类,其他剩余的样本归为另一类，k个类别的样本就构造出了k个SVM。</p>
<p>该算法代码为<a href="https://link.zhihu.com/?target=http%3A//lear.inrialpes.fr/people/wang/dense_trajectories">http://lear.inrialpes.fr/people/wang/dense_trajectories</a></p>
<p>(6). 结论</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-1c6a850848f44f2ba3f9d3772b36723b_hd.jpg" alt="img">图15 iDT各特征描述子和不同光流运算方式结合的准确率对比</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-00111eeecd61b9ffde93ff06e2617916_hd.jpg" alt="img">图16 iDT不同特征融合方式准确率对比</p>
<p>iDT所选的特征描述子以及它们的组合，结合各种不同光流运算方式在四大数据集中的分类准确率表明，将所有特征描述子都用上，并且去除掉背景轨迹的光流结合方式，最终分类准确率最高。在特征融合上Fisher vector+iDT比BoF\FV+DT\iDT的其他组合都要优异。</p>
<h2 id="图像分类的深度学习方法"><a href="#图像分类的深度学习方法" class="headerlink" title="图像分类的深度学习方法"></a>图像分类的深度学习方法</h2><p>深度学习网络本质上就是自动编码器、受限玻尔兹曼机、深度置信网络、卷积神经网络、循环神经网络、对抗生成网络这些网络以及它们的组合、变体或演进网络。</p>
<p>ResNet-152已经以3.5%的错误率超越了人类视觉5.1%的错误率.CNN加以利用仅仅是2维空间的特征提取与分类，在时间方面的特征如何提取并与空间特征进行融合，根据这些不同的问题解决思路可以清晰的分成了三个流派分支，分别是two-stream(双流)方法，C3D方法(三维卷积核法)以及CNN-LSTM方法(卷积循环神经网络)</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-b7b5591415d249e7d1c219f46a532e82_hd.jpg" alt="img"></p>
<h3 id="深度学习方法具体流程"><a href="#深度学习方法具体流程" class="headerlink" title="深度学习方法具体流程"></a>深度学习方法具体流程</h3><p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-ca3dac97b3ae014f88c969ad7bbe1f80_hd.jpg" alt="img"></p>
<h4 id="数据载入和数据预处理"><a href="#数据载入和数据预处理" class="headerlink" title="数据载入和数据预处理"></a>数据载入和数据预处理</h4><p><strong>数据载入</strong>包括将数据集划分为training set、validate set与test set，并将数据打乱次序，设置数据并行方式。</p>
<p>验证集与训练集不必分开，但测试集需要完全分开</p>
<p><strong>并行计算</strong>：单核CPU的SIMD、多核CPU的多线程、多GPU、多主机等各种方式</p>
<p>瓶颈：指令集版本、CPU核数于主频、PCIe带宽以及网络开销</p>
<p>数据并行：将一个mini batch的数据放在不同设备上进行计算，实现梯度计算的并行化</p>
<p>模型并行：将一个神经网络的不同部分放在不同设备上进行计算，从而减少每一轮训练迭代的时间，不过对神经网络不同区域间的依赖程度有所要求</p>
<p><strong>数据预处理</strong>：归一化、中心化、白化、数据增强（扩张）</p>
<p>归一化：不必进行归一化(像素尺度范围一致)</p>
<p>中心化：改变数据的分布中心</p>
<p>白化：使每一层的输出规范到<code>0~1</code>,改变数据的分布范围</p>
<p>数据增强：</p>
<ul>
<li><p>翻转(Flip)</p>
</li>
<li><p>颜色变换(Color Jittering)：可以改变HSV色彩空间的对比度，或RGB经过PCA之后主分量进行随机因子调整，或对每个RGB像素进行盐噪声/高斯噪声扰动</p>
</li>
<li><p>随机剪裁/缩放/平移(Random Crops/Scale/Shfit)</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-d77ebeb3e1dbacdd4ead48410790209f_hd.jpg" alt="img"></p>
</li>
</ul>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-96d1f36ed4dcf167387dde11368f7f5d_hd.jpg" alt="img"></p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/v2-1c1780b115e54914babd614263e870eb_hd.jpg" alt="img"></p>
<h4 id="网络构建"><a href="#网络构建" class="headerlink" title="网络构建"></a>网络构建</h4><p>网络设计、网络参数初始化及防止过拟合设计</p>
<p><strong>网络设计</strong>：考虑因素：</p>
<ul>
<li>需要几层卷积层、池化层、正规化层和全连接层</li>
<li>每一个卷积层的卷积核尺寸、步长、个数是多少</li>
<li>每一个池化层的尺寸、步长是多少，池化层是平均池化还是最大池化，是否允许有重叠</li>
<li>在哪些层之后做正则化，全连接层维度是多少</li>
<li>全连接层维度是多少，数据在每层之间流转的张量各个维度分别是多少，是否需要网中网，是否需要1x1的卷积核进行降维等等</li>
</ul>
<p>对于视频识别来说，主要研究精力在于如何添加时间维度并实现于网络之中，故对于基础卷积神经网络的设计一般会沿用经典图像识别网络设计，如VGG、GoogLeNet和ResNet，网络设计中的参数皆为超参数，不随着训练而发生改变</p>
<p><strong>网络参数初始化及与训练</strong>：可以小随机数初始化，如果要对方差大小进行规范化可以采用<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/victoriaw/article/details/73000632">Xavier初始化</a>或<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/VictoriaW/article/details/73166752">Kaming初始化</a>，也可以将之前的模型训练结果(pre-trained models，或称为模型载入)进行初始化</p>
<p><strong>防止过拟合设计</strong>：增强模型的泛化能力，即需要进行正则化(regularization)和随机失活(dropout)</p>
<h4 id="分类函数与loss定义"><a href="#分类函数与loss定义" class="headerlink" title="分类函数与loss定义"></a>分类函数与loss定义</h4><p><strong>分类函数</strong>由回归函数定义，常见的回归函数有一维线性回归、多维线性回归、多项式回归、Logistic回归、Softmax回归。行为识别属于多标签分类，对于多标签来说最常用的就是Softmax回归，原理是处理多分类任务时将可以判定为某类的特征进行相加，然后将特征转化为判定。</p>
<p><strong>Loss</strong>：MSE、合页损失函数(hinge loss)和交叉熵函数(cross entropy loss)</p>
<p>对于Softmax回归最常用的Loss即是交叉熵函数，它是真实的概率分布One-hot编码后取对数再乘以预测的概率分布求和取反。</p>
<h4 id="优化器定义"><a href="#优化器定义" class="headerlink" title="优化器定义"></a>优化器定义</h4><p>SGD(随机梯度下降)、SGD+Momentum(动量)、SGD+Nesterov Momentum(牛顿型动量)、Adagrad(自适应学习率)、Adadelta、RMSProp、Adam。</p>
<p>一般用Adam来作为默认的优化算法。初始的学习率一般为0.01或0.001，在训练过程中学习率的调整可以按照固<strong>定次减缓、指数减缓、分数减缓</strong>来进行。</p>
<h4 id="训练与验证过程"><a href="#训练与验证过程" class="headerlink" title="训练与验证过程"></a>训练与验证过程</h4><p>通过不断迭代，以mini-batch为单位将数据喂给模型，同时计算梯度，更新学习参数，返回本次的accuracy和loss。</p>
<p>在每个epoch每次批处理(mini-batch)训练后在该训练集和验证集上分别作网络前向运算，预测训练集和验证集样本标记(label)，返回本次的accuracy和loss，绘制学习曲线来检验模型泛化能力。</p>
<p>每个epoch训练前将数据集随机打乱来确保不同回合喂给模型的数据是不同的；每隔一段时间存储模型参数，以免crash从头训练</p>
<p>模型微调：可将训练好的模型带入网络进行初始化，选择一个较小的学习率，甚至可以不同层设置不同的学习率微调整个网络模型。</p>
<h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><p>只是前向计算没有训练收敛过程，故对于同一个样本输入，输出结果也应该一致。最后，可通过正负样本、Top-1/5或混淆矩阵多种方式表示准确率。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/20190926211248102.png" alt="动作识别与分类"></p>
<p>方法：</p>
<p>人体图像分割</p>
<p>人体骨骼关键点检测</p>
<p>人体姿态估计</p>
<p>纯粹的图像（动作）分类</p>
<p>光流法</p>
<p>动作的识别最终就能转变成<strong>特征提取、分类</strong>两个主要过程</p>
<p>特征提取包含<strong>静态帧的特征，动态帧间的特征</strong>。</p>
<h2 id="动作识别实现"><a href="#动作识别实现" class="headerlink" title="动作识别实现"></a>动作识别实现</h2><p>视频逐帧分析，采用连续的动作识别出人物动作，如走路、跑步、蹲下等。在计算机视觉中人机交互中有很大的应用，主要处理模型大概分为两个大类：卷积神经网络（3D-CNN）、基于循环神经网络与其扩展模型（CNN + LSTM）</p>
<p>要识别出人物的动作通常需要连续的视频数据进行分析处理，需要采集的特征通常有单帧图像数据的特征和多帧图像数据之间时间上的特征，简单来说就是静态帧数据+帧间数据。</p>
<p>a、静态帧数据，表示单帧图像空间信息</p>
<p>b、帧间数据，表示时间信息（光流数据）</p>
<p>常用的数据集有：KTH、Weizmaan、HOHA、Keck Gesture、MSR action、YouTube Action、UT-Interaction等等。</p>
<p>从目标分析的角度上看，动作识别也能看作是分类的问题，每个动作就是一类，如果有二十个动作就是二十类。那么动作的识别最终就能转变成特征提取、分类两个主要过程。特征提取包含静态帧的特征，动态帧间的特征。算法在不断的迭代发展，产生了很多经典的处理模型、算法。一般的识别流程为：</p>
<p><img src="https://perfectism13.github.io/2019/12/05/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E5%88%86%E7%B1%BB/640.webp" alt="img"></p>
<h1 id="传统有监督特征提取方法"><a href="#传统有监督特征提取方法" class="headerlink" title="传统有监督特征提取方法"></a>传统有监督特征提取方法</h1><p>时空关键点，密集轨迹方法</p>
<h2 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h2><p>恰巧我也算是没人带在看这方面的事情，如果基于深度学习的话，你不妨先了解神经网络-&gt;卷积-&gt;循环神经网络。 了解一些通用的众人皆知的卷积神经网络（CNN）之后（如lenet5，alexnet，resnet，googlenet等），再去了解动作识别用神经网络如何去做，通常分为（静态、动态）。静态的话CNN基本可以完成，动态的话，你需要去了解双流结构，Two-Stream Convolutional Networks for Action Recognition in Videos.pdf，去了解3D卷积神经网络（搜索3D convolution for action recognition, C3D network）。 接下来，你可以去了解是否需要加入RNN的模块来帮助构造模型更好的去解析时序类的数据，看一些LSTM+action recognition的论文，在接下来，你可以看看目前火热的Attention机制，</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/44420871" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44420871</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45444790" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45444790</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>工作岗位需求</title>
    <url>/2020/07/24/%E5%B7%A5%E4%BD%9C%E5%B2%97%E4%BD%8D%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<h1 id="工作岗位需求"><a href="#工作岗位需求" class="headerlink" title="工作岗位需求"></a>工作岗位需求</h1><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><h3 id="算法工程师-软件算法"><a href="#算法工程师-软件算法" class="headerlink" title="算法工程师-软件算法"></a>算法工程师-软件算法</h3><ul>
<li>人工智能AI算法、大数据算法、数据结构算法设计和开发能力</li>
<li>至少掌握Java/Python/C其中一种开发语言，掌握Hadoop开源工具使用更佳；</li>
<li>至少掌握一种数据挖掘工具和深度模型训练工具,如Tensorflow,caffe,matlab；</li>
</ul>
<h3 id="算法工程师-媒体算法"><a href="#算法工程师-媒体算法" class="headerlink" title="算法工程师-媒体算法"></a>算法工程师-媒体算法</h3><ul>
<li>具备图像、音频、视频处理算法、深度学习、人脸识别、监控视频、SLAM、3D重建、场景识别、智能语音、智能交互、多媒体信息搜索、光学设计、视频协议标准（HEVC/H264/VPx/VC1/MPEGx）等领域算法理论、研发经历或评测调优经验</li>
</ul>
<h3 id="技术研究工程师-车联网与自动驾驶"><a href="#技术研究工程师-车联网与自动驾驶" class="headerlink" title="技术研究工程师-车联网与自动驾驶"></a>技术研究工程师-车联网与自动驾驶</h3><ul>
<li>（1）传感器融合算法<br>（2）SLAM/VIO算法<br>（3）智能决策、推理、路径规划和运动控制<br>（4）智能交通系统模拟仿真<br>（5）计算机视觉、模式识别、多媒体内容分析<br>负责本领域算法/模型的设计、实现、测试和评估</li>
<li>（1）具备移动机器人等领域研究经验，参与国内外知名相关竞赛，如未来挑战赛等；<br>（2）具备相关工程或开发经验，如深度学习、仿真系统搭建/开发经验等；<br>（3）传感器融合算法方向要求熟悉视觉、毫米波雷达、激光雷达和GPS/IMU等传感器；</li>
</ul>
<h3 id="AI工程师-CV"><a href="#AI工程师-CV" class="headerlink" title="AI工程师-CV"></a>AI工程师-CV</h3><ul>
<li>从事计算机视觉、模式识别、多媒体内容分析等方向的应用研究和开发工作；如3D重建、图像超分、OCR、多目标跟踪、场景识别等；</li>
</ul>
<h3 id="AI工程师-ML"><a href="#AI工程师-ML" class="headerlink" title="AI工程师-ML"></a>AI工程师-ML</h3><ul>
<li>从事机器学习算法和理论前沿研究。研究领域包括：元学习，AutoML, 深度学习，强化学习，贝叶斯学习等；</li>
</ul>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="技术研究ML"><a href="#技术研究ML" class="headerlink" title="技术研究ML"></a>技术研究ML</h3><p>神经网络模型设计，超参数优化，现有模型的分布式加速，并行算法库，模式识别，概率统计，最优化，SPark，XGboost</p>
<h3 id="技术研究CV"><a href="#技术研究CV" class="headerlink" title="技术研究CV"></a>技术研究CV</h3><p>人脸识别，物体检测，分类，语义分割，活体识别，车辆与人员的检测识别与跟踪，图像/视频搜索，视频语义分析，视频特征提取与识别，页面分析与自动合成，OCR</p>
<p>shell、python，matlab</p>
<h3 id="技术研究others"><a href="#技术研究others" class="headerlink" title="技术研究others"></a>技术研究others</h3><p>传统ML（SVM，随机森林，k-MEANS）,深度神经网络（CNN，RNN，LSTM，Seq2Seq）</p>
<h2 id="大疆"><a href="#大疆" class="headerlink" title="大疆"></a>大疆</h2><h3 id="算法-影像类"><a href="#算法-影像类" class="headerlink" title="算法 -影像类"></a>算法 -影像类</h3><p>3A技术：自动对焦(AF)、自动曝光(AE)和自动白平衡(AWB)</p>
<p>画质调优、智能增强</p>
<p>掌握ISP核心算法（去噪、插值、锐化、颜色链路等模块）及3A控制算法设计原理。对计算成像（曝光融合，图像去噪，色调映射）有较深入理解，了解一般的机器学习算法，熟悉相机相关业务（人脸识别、分割、检测、融合、增强等）算法的质量评价准则及具体实现，掌握相机成像及工作原理相关知识，爱好摄影，熟悉后期工作流者优先。</p>
<h3 id="算法-感知类"><a href="#算法-感知类" class="headerlink" title="算法-感知类"></a>算法-感知类</h3><p>SLAM、多传感器融合及深度估计算法</p>
<p>基于双目立体匹配算法的自主机器人环境感知系统开发</p>
<p>基于多传感器融合方案的自主机器人定位及运动物体状态估计系统开发</p>
<p>研发3D检测跟踪算法，开发基于多传感器融合的环境感知算法</p>
<p>熟悉常见传感器特性、多视觉几何算法、三维重建算法、定位匹配技术、滤波理论及常用的图像处理算法，对机器人学等领域有深入认识，并了解各个算法的条件和瓶颈，具有点云数据处理、立体视觉、多传感器融合等科研或开发经验优先。</p>
<p>在高水平国际会议、期刊上发布过相关文章，或在各类竞赛中取得优异成绩，包括但不限于IJRR、CVPR、ICCV、ECCV、NIPS、ICML、ICRA、IROS、ITS、IV、3DV、RSS、IJRR、T-RO、JFR、电子设计大赛、Robocon等；</p>
<h3 id="算法-ML类"><a href="#算法-ML类" class="headerlink" title="算法-ML类"></a>算法-ML类</h3><p>\1. 研发基于图像、点云的语义分割、3D检测跟踪算法；</p>
<p>\2. 研发图像跟踪、人脸识别、人体关键点识别、检测等视觉算法；</p>
<p>\3. 研发视频内容理解、自动剪辑等视觉算法，以及在实际场景中的应用；</p>
<p>\4. 深度学习基础技术的研发，包括但不限于神经网络量化和加速、AutoML、Active Learning等。</p>
<p>熟悉机器学习算法，了解深度学习的学术前沿，具有AUTOML，模型压缩，对抗学习，增强学习，自学习，动作识别，视频理解，物体检测、目标跟踪、场景分割、人脸识别等科研或开发经验优先。</p>
<h3 id="算法-决策规划类"><a href="#算法-决策规划类" class="headerlink" title="算法-决策规划类"></a>算法-决策规划类</h3><p>\1. 研发基于激光雷达、视觉、毫米波雷达等传感器的机器人自动导航应用；</p>
<p>\2. 研发动态复杂环境下规划模块及数据融合框架的算法设计、实现；</p>
<p>\3. 控制和量化导航规划系统风险，强化系统健壮性。</p>
<p>具备导航规划算法、机器人环境感知算法及数据融合算法、凸优化、在线优化、非线性优化、数值优化、移动机器人系统开发等经验。</p>
<h2 id="Alibaba"><a href="#Alibaba" class="headerlink" title="Alibaba"></a>Alibaba</h2><h3 id="达摩院算法-3D-cv"><a href="#达摩院算法-3D-cv" class="headerlink" title="达摩院算法-3D cv"></a>达摩院算法-3D cv</h3><p>三维重建、点云分析、网格处理、参数化建模、纹理合成、SLAM，SFM等计算机图形学和计算机三维视觉相关领域</p>
<h3 id="天猫精灵事业部-视觉算法专家-视觉交互方向"><a href="#天猫精灵事业部-视觉算法专家-视觉交互方向" class="headerlink" title="天猫精灵事业部-视觉算法专家-视觉交互方向"></a>天猫精灵事业部-视觉算法专家-视觉交互方向</h3><p>熟悉图像／视频分析（如物体检测，物体识别，场景理解，手势识别，肢体识别等）的相关算法；</p>
<h3 id="达摩院-自动驾驶视觉感知算法专家-杭州-北京"><a href="#达摩院-自动驾驶视觉感知算法专家-杭州-北京" class="headerlink" title="达摩院-自动驾驶视觉感知算法专家-杭州/北京"></a>达摩院-自动驾驶视觉感知算法专家-杭州/北京</h3><p>具有视频分割检测、模型轻量化网络搜索、单目回3D、多目标跟踪中的一个或多个开发和系统实现经验；</p>
<p>3、精通PyTorch, Caffe框架中的一种，并掌握神经网络相关的优化调参；或精通卡尔曼滤波系列和粒子滤波等技术在单目3D,多目标跟踪中的实际应用；</p>
<h3 id="阿里文娱产品技术平台-计算机视觉算法（增强方向）-摩酷实验室"><a href="#阿里文娱产品技术平台-计算机视觉算法（增强方向）-摩酷实验室" class="headerlink" title="阿里文娱产品技术平台-计算机视觉算法（增强方向）-摩酷实验室"></a>阿里文娱产品技术平台-计算机视觉算法（增强方向）-摩酷实验室</h3><p>a) 去噪声、超分辨率等方向的研发经验；</p>
<p>b) 深度学习模型工程化压缩加速，云/端设备部署相关经验；</p>
<p>c) HDR、影像风格迁移等方向的研发经验；</p>
<h3 id="达摩院-工程专家-视觉智能"><a href="#达摩院-工程专家-视觉智能" class="headerlink" title="达摩院-工程专家-视觉智能"></a>达摩院-工程专家-视觉智能</h3><p>3) 熟悉云上产品流程开发经验和工具栈，或者端上AI应用和优化经验，具备分布式计算、FPGA/CUDA开发、Hadoop/Spark/Flink等流计算开发能力者优先；</p>
<p>4) 具有扎实的工程实现和架构能力，精通C/C++/Java/Python其中一种及以上编程语言；</p>
<p>5) 或：精通各种主流JAVA框架，包括spring、netty、hibernate、mybatis等，对JVM原理有深层次的理解；或具备分布式系统架构能力，熟悉分布式容错、分布式缓存、高并发等主流技术，具备多线程及高性能的设计与编码及性能调优经验；</p>
<h3 id="阿里文娱产品技术平台-计算机视觉算法（人脸方向）-摩酷实验室"><a href="#阿里文娱产品技术平台-计算机视觉算法（人脸方向）-摩酷实验室" class="headerlink" title="阿里文娱产品技术平台-计算机视觉算法（人脸方向）-摩酷实验室"></a>阿里文娱产品技术平台-计算机视觉算法（人脸方向）-摩酷实验室</h3><p>a) 人脸识别、端侧人脸检测、端侧人脸关键点提取等方向的研发经验；</p>
<p>b) 深度学习端侧模型工程化压缩加速部署相关经验；</p>
<p>c) 人脸图像/视频生成端侧模型方向的研发经验；</p>
<h3 id="新零售技术事业群-视觉算法-淘系技术部"><a href="#新零售技术事业群-视觉算法-淘系技术部" class="headerlink" title="新零售技术事业群-视觉算法-淘系技术部"></a>新零售技术事业群-视觉算法-淘系技术部</h3><p>图像数据的分析与处理、生成与编辑、搭配与增强、效果评估、视觉数据检索等技术研发；</p>
<h3 id="钉钉-DingTalk-视觉技术（图像视频）专家-智能硬件技术"><a href="#钉钉-DingTalk-视觉技术（图像视频）专家-智能硬件技术" class="headerlink" title="钉钉(DingTalk)-视觉技术（图像视频）专家-智能硬件技术"></a>钉钉(DingTalk)-视觉技术（图像视频）专家-智能硬件技术</h3><p>\2. 算法工程方向，负责计算机视觉、图像识别、视频分析等方向算法工程化应用，落地到产品上；</p>
<p>\3. 图像质量方向，负责Camera驱动适配和软件功能开发、ISP tuning以及图像处理算法应用等相关工作</p>
<p>\4. 应用开发方向，负责机器视觉和图像视频系统软件架构设计和软件开发；</p>
<h3 id="蚂蚁金服-计算机视觉高级-资深专家"><a href="#蚂蚁金服-计算机视觉高级-资深专家" class="headerlink" title="蚂蚁金服-计算机视觉高级/资深专家"></a>蚂蚁金服-计算机视觉高级/资深专家</h3><p>参与图像/视频技术的研发、升级，以及在蚂蚁金服各个应用场景的落地；</p>
<p>2、运用 CUDA 库以及多机多 GPU 卡参与大规模分布式机器学习能力建设；</p>
<p>对大规模分布式计算范式有深刻认识，熟悉 MapReduce，了解 Parameter Server 框架；</p>
<p>对于有模型压缩、量化、剪枝、加速、端上移植优化等经验者优先</p>
<h3 id="Aliexpress-算法专家-视觉技术"><a href="#Aliexpress-算法专家-视觉技术" class="headerlink" title="Aliexpress-算法专家-视觉技术"></a>Aliexpress-算法专家-视觉技术</h3><p>\1. 图像/视频搜索方向（拍立淘）</p>
<p>图像/视频分析算法，包括但不限于视频检测和跟踪、图像/视频特征、图像/视频caption和视频摘要；</p>
<p>大规模图像/视频搜索系统，包括但不限于矢量搜索引擎、鲁棒的图像/视频表示、多模态搜索和搜索重排序。</p>
<p>\2. 图像/视频识别方向</p>
<p>大规模图像识别（extreme classification），包括但不限于multi-class/multi-label；</p>
<p>万物识别（如花草等），商品识别、细粒度识别以及多模态识别（如图文联合识别）相关。</p>
<p>\3. 图像/视频分割检测方向</p>
<p>设计开发图像/视频检测和分割算法，包括但不限于显著物体检测，实例分割，语义分割；</p>
<p>手机端轻量级模型设计开发，服务器端模型设计开发。</p>
<p>\4. 超大规模分布式训练</p>
<p>参与超大规模分布式深度学习训练平台建设及优化开发；</p>
<p>高性能分布式深度学习训练算法设计及实现，包括但不限于计算优化、通信优化、算子优化等。</p>
<p>2.熟悉常见分布式训练框架，包括但不限于Horovod等；</p>
<p>3.精通并行编程技术及相关并行加速库，能够实现算子级设计和优化；</p>
<p>\4. 扎实的工程能力，精通C/C++/Python，熟悉分布式计算，熟悉分布式计算，有Hadoop/SPAPK经验者优先；</p>
<h3 id="达摩院-多媒体技术专家-创意视觉"><a href="#达摩院-多媒体技术专家-创意视觉" class="headerlink" title="达摩院-多媒体技术专家-创意视觉"></a>达摩院-多媒体技术专家-创意视觉</h3><p>\2. 熟悉opencv或opengl，了解图像渲染和处理的机制和常用算法工具。</p>
<p>\3. 熟悉ffmpeg 源码或者熟练使用ffmpeg 库API 或者其它类似的多媒体架构，深入了解媒体处理的流程。</p>
<h3 id="阿里云智能事业群-视频云-实时计算机视觉算法专家-杭州-上海"><a href="#阿里云智能事业群-视频云-实时计算机视觉算法专家-杭州-上海" class="headerlink" title="阿里云智能事业群-视频云-实时计算机视觉算法专家-杭州/上海"></a>阿里云智能事业群-视频云-实时计算机视觉算法专家-杭州/上海</h3><p>a. 负责视频会议场景下视频图像的AI算法研发优化和技术创新，包括但不限于背景虚化/替换、视频去噪、视频超分、超帧率、细节增强、色彩优化、光线矫正、花屏修复、抖动矫正、违规检测、拥塞预测、宕机预测等；</p>
<p>b. 结合业务场景和前沿技术发展设计轻量、高效、低功耗的算法，并推动算法快速工程化落地。</p>
<p>a.具有人像抠图、视频去噪、超分辨率、超帧率、图像增强等方向研发经验者优先；</p>
<p>b.具备模型轻量化剪枝、量化、压缩等相关经验者优先；</p>
<p>c.熟悉多终端模型推理优化者优先，包括但不限于Intel CPU、Cuda、ARM、Meta、Vulkan、OpenCL等相关工程优化；</p>
<p>3、 精通Tensorflow、Pytorch等框架，熟悉MNN、NCNN等推理框架及其优化方法；</p>
]]></content>
  </entry>
  <entry>
    <title>平台框架部分补充</title>
    <url>/2020/07/24/%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E9%83%A8%E5%88%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="平台框架部分补充"><a href="#平台框架部分补充" class="headerlink" title="平台框架部分补充"></a>平台框架部分补充</h1><p>闵晨阳 车辆1601 2019.11.14</p>
<h2 id="ROS常见开源库"><a href="#ROS常见开源库" class="headerlink" title="ROS常见开源库"></a>ROS常见开源库</h2><p>pcl： Point Cloud Library是用于点云处理任务和3D几何处理的算法的开源库</p>
<p>openrave： 开放式机器人自动化虚拟环境为在现实世界的机器人应用中测试，开发和部署运动规划算法提供了一个环境</p>
<p>openni： 验证和提高互操作性自然用户界面和有机用户接口对于自然交互（NI）设备，使用这些设备的应用程序和中间件这便于此类设备的访问和使用</p>
<p>BSD 许可协议：Berkeley Software Distribution license，是自由软件中使用最广泛的许可协议之一。BSD 就是遵照这个许可证来发布，也因此而得名 BSD 许可协议。</p>
<h2 id="Apollo-Ros有何不同"><a href="#Apollo-Ros有何不同" class="headerlink" title="Apollo Ros有何不同"></a>Apollo Ros有何不同</h2><p>详见： <a href="http://blog.exbot.net/archives/3437" target="_blank" rel="noopener">http://blog.exbot.net/archives/3437</a></p>
<p><strong>一、 自动驾驶对ROS框架的三点需求</strong></p>
<p>自动驾驶系统非常复杂，包含感知、障碍物检测、决策、车辆控制等模块，把这么多功能各异的模块集成在一起，组成一个完整的系统并完成自动驾驶的任务，这是一个非常大挑战。</p>
<p><strong>1、高效的开发支持</strong>，快速的算法迭代要求ROS框架要能提供良好的开发模式，算法工程师更多聚焦在算法本身的开发和功能验证上。通过一个框架统一完成诸如配置管理、环境配置、整体运行以及调试等功能，快速构建系统原型，验证算法和功能。</p>
<p><strong>2、模块灵活配置</strong>，感知、定位、决策模块，本身功能相对独立，通过接口定义数据。工程师在整体开发中希望各个模块独立开发、调试，应用时能通过框架快速集合成完整的系统并运行。</p>
<p><strong>3、丰富的调试工具</strong>，自动驾驶系统涉及大量图像、点云处理算法，对于各种可视化工具有非常高需求，障碍物检测是否精准， 规划路径是否合理、定位是否正确，这些环节在调试过程中都需要可视化工具的支持。</p>
<p><strong>二、 为什么选用ROS框架？</strong></p>
<p><strong>1、行业认可</strong>，ROS框架很早就被机器人行业所使用，目前有3000多个基础库，能够支持应用的快速开发。</p>
<p><strong>2、消息机制</strong>，ROS在开发过程中，基于功能把整个自动驾驶系统分成多个模块，每个模块负责自己消息的接收、处理、发布。当模块需要联调时，通过框架可以把各个模块快速的集成到一起。</p>
<p><strong>3、使用广泛</strong>，ROS是学术界使用最广泛的框架，对于验证最新的算法非常便利。</p>
<p>正是基于以上特性，在Apollo1.0版本中选择ROS作为开发和集成的框架。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/fc7aaf5673174f76901670c37839642a_th-2.png" alt="img"></p>
<p><strong>三、Apollo中ROS的改进</strong></p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/da1bd41d96dd43a5850ff0573d8a285a_th-1.png" alt="img"></p>
<p><strong>1、通信性能优化</strong></p>
<p><strong>｜问题：自动驾驶大量使用传感器引发很大的传输带宽需求</strong></p>
<p>自动驾驶系统为了能够感知复杂的道路情况，需要多种传感器协同工作才能覆盖不同的场景、不同路况需求。多传感器共同使用会对车载系统造成很大压力。</p>
<p><strong>｜解决优化：共享内存能减少传输中的数据拷贝，显著提升传输效率</strong></p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/eab7a7c0401e4d11b8ea75e55ef6357b_th-1.png" alt="img"></p>
<p><strong>｜问题：单路传感器消息有多个消费者时负载成倍增长</strong></p>
<p><strong>｜解决优化：共享内存可以有效满足一对多的传输场景</strong></p>
<p>共享内存本身的特性能够支持一次写入、多次读取功能。对于一对多传输场景，不同的使用者就可以同时读取，实现一次写入，多次读取的功能，成倍提升传输效率。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/9fad66a1c29d43babda165b200d7db47_th-1.png" alt="img"></p>
<p><strong>｜通信性能优化效果</strong></p>
<p>A、一对一传输过程中，共享内存吞吐量达到socket两倍，一对多传输过程中，共享内存传输对带宽的优势进一步扩大。</p>
<p>B、共享内存传输延迟比Shared节省一半，对强实时性系统的自动驾驶汽车帮助很大。</p>
<p>C、共享内存CPU资源占用要比socket减少很多，一定程度上提升计算算法和能力。</p>
<p><strong>2、去中心化的网络拓扑</strong></p>
<p><strong>｜ROS特点：ROS以Master为中心构建hybridp2p拓扑网络</strong></p>
<p>ROS是以Master为中心构建Hybrid p2p拓扑网络，带来了比较强的容错性，不同语言模块隔离，模块开发低耦合，当某个算法出现异常导致崩溃的时候，不会引起整个的异常，为局部异常处理提供便利。</p>
<p><strong>｜问题：Master作为拓扑网络的中心，一旦异常将影响整个网络</strong></p>
<p>整个系统非常依赖Master这个单点，一旦Master异常，所有节点都不能发现其他节点，这样整个系统就不能正常工作，缺乏异常恢复机制。</p>
<p><strong>｜解决优化：使用RTPS服务发现协议实现完全的P2P网络拓扑</strong></p>
<p>在ROS中添加基于RTPS服务协议功能，网络构建不会以Master作为中心，而是通过域概念作为划分，所有节点加入域中，会通过RTPS协议相互广播通知其他节点，然后节点间会建立点对点连接，来发布订阅消息，以替代Master作为中央信息交换的功能。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/c85fbfa5578d4480a882a3f1743f5d9c_th-1.png" alt="img"></p>
<p><strong>｜使用RTPS服务发现过程</strong></p>
<p>A. Sub节点启动，通过组播向网络注册</p>
<p>B、通过节点发现，两两建立unicast</p>
<p>C、向新加入的节点发送历史拓扑消息</p>
<p>D、收发双发建立连接，开始通信</p>
<p><strong>3、数据兼容性扩展</strong></p>
<p><strong>｜Message是ROS中描述软件组件接口的语言</strong></p>
<p>Message是ROS中描述接口的一种语言，当两个节点之间需要建立连接的时候，通常需要满足两个条件。一是接收和发送的Topic属于同一个话题，二是两个模块定义的模式要完全一致。</p>
<p><strong>｜ROS使用msg描述文件定义模块间的消息接口</strong></p>
<p>ROS怎么定义message？ROS使用msg文件对数据接口进行抽象化的描述，并可以生成不同语言的接口实现，以满足不同语言的通信交流需求。</p>
<p><strong>｜问题：接口升级后，不同版本的模块难以兼容</strong></p>
<p>兼容性的问题，当项目规模比较小时，影响不大；但是对于无人自动驾驶比较庞大的项目时，影响就很大。当某一个模块接口升级了，需要把所有相关模块升级到最新版本之后，才能在一起进行基础功能的连调。同时对于线下仿真调试的时候，有时需要把某一个模块回到历史版本验证或定位某一个问题，这时候若接口之间出现升级，就会出现不兼容问题，导致系统运行障碍。</p>
<p><strong>｜问题:接口升级后，历史数据也面临无法使用的问题</strong></p>
<p>接口兼容性问题会对历史数据使用造成更大影响，自动驾驶汽车系统中历史数据是非常宝贵和重要资源，对于这种问题有一些解决方式，一是通过离线数据批量转换和在线方式，二是转换成新数据。</p>
<p><strong>｜解决优化：protobuf能够很好支持向后兼容</strong></p>
<p>使用protobuf来替代ROSmessage，最大好处是可以完全覆盖message中本身包含的类型，有利于把既有的ROSmessage迁移到protobuf格式下。此外protobuf有非常好的版本兼容性。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/f92c6292ed9d439a9ed597399709230a_th.png" alt="img"></p>
<p><strong>｜解决优化：protobuf消息格式与ROS深度集成</strong></p>
<p>在Apollo ROS中，做了一整套对protobuf的支持， 在工程中可以不需要做protobuf和ROS message的转换，直接publish protobuf格式的消息，调试工具也能够非常正确的解析出来正确的protobuf消息。这样既能够很好解决兼容性问题，也不会产生额外的学习成本和使用成本。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/9dd4c11ea1a34ab198c9efde7966082d_th.png" alt="img"></p>
<h2 id="平台框架"><a href="#平台框架" class="headerlink" title="平台框架"></a>平台框架</h2><p><strong>OTA</strong>: 空中下载（OTA）是通过移动通信的空中接口实现对移动终端设备及SIM卡数据进行远程管理的技术。</p>
<p><strong>DuerOS</strong>:是百度<a href="https://baike.baidu.com/item/度秘" target="_blank" rel="noopener">度秘</a>事业部研发的对话式人工智能系统。</p>
<p><strong>HMI</strong>:Human Machine Interface , 人机界面（又称用户界面或使用者界面）是系统和用户之间进行交互和信息交换的媒介， 它实现信息的内部形式与人类可以接受形式之间的转换。凡参与人机信息交流的领域都存在 着人机界面。</p>
<p><strong>黑盒子存在的原因</strong>：</p>
<h3 id="端到端："><a href="#端到端：" class="headerlink" title="端到端："></a><strong>端到端</strong>：</h3><p>端到端就意味着完整性、完备性 ，一种工作态度</p>
<p> 单个模块即便能正常工作，但当各个模块组合成为一个系统时，整个系统可能不能正常工作，因此必须在整个系统的输出与输出之间建立一种端到端的连接，使整个系统能够正常工作</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/71278e9847764506ac39200bdc3a3b76_th-1573746277221.png" alt="img"></p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/c96d3715ac4d4717b7bebe7fe4089946_th-1573746464451.png" alt="img"></p>
<p><strong>｜Rule base的特点：</strong></p>
<p>1.系统复杂性，需要人工设计上千个模块。</p>
<p>2.高精地图的成本，更新必须及时。</p>
<p>3.车载硬件计算能力，每个模块都要深度学习，车辆最多可能需要运行十几个深度学习网络，对计算能力和消耗需求很大。</p>
<p><strong>｜功能、系统工程复杂度、算法要求</strong></p>
<p>人们开车的时候有两类行为：一类可以边打电话边开车，我们称之为Reactive control（无脑操作）。需要集中注意力做出判断的，是Proactive planning。End-to-End系统到目前为止，主要实现了Reactive control，Proactive planning尚处于探索阶段。每一个message背后其实都是一个复杂的系统，End-to-End大部分系统自己完成，算法要求都很高。</p>
<p><strong>｜可解释性</strong></p>
<p>自动驾驶对安全性要求极高，必须做可解释性的东西。很多公司不做End-to-End系统，主要原因是其不可解释，而Rule based是可解释的。但限制Rule based往前发展的恰恰就是面临的不确定性因素，尤其是复杂环境。可解释性不应该成为这两个系统选择或者是评比优劣的点，最终的评比应该是客观的指标性的东西，比如能安全运行多少公里。</p>
<p><strong>｜广铺成本</strong></p>
<p>Rule based广铺成本面临的大问题是高精地图，End-to-End目前还不需要高精地图，普通导航系统即可。</p>
<p><strong>｜传感器成本</strong></p>
<p>Rule based相对高一些，End-to-End相对低一些。并不是End-to-End系统需要的传感器少，而在于它对传感器的利用率高。以摄像头为例，宝马的自动驾驶方案中，前档有3个摄像头，周围一圈又有不少，每个摄像头都对应了Rule based系统中特定的功能。而End-to-End系统是用神经网络拟合，如不同的摄像头中所需要的像素级别的融合，可以自己用机器识别出，或者机器自己判断和加工中所需要的过程，更高效的利用传感器。</p>
<p><strong>｜车载计算资源、核心问题、关系</strong></p>
<p>车载计算资源的实践差距非常大，Rule based的研发和广铺成本极高，而End-to-End系统核心问题主要在于数据，它的所有行为需要数据，而目前开源闭源都很难有优质的数据需要训练。Rule based和End-to-End更像互补关系。对于普通的，需要在边打电话边开车的场合，End-to-End更适合；对于入口和街区，Rule based更靠谱。</p>
<h3 id="RTOS"><a href="#RTOS" class="headerlink" title="RTOS"></a>RTOS</h3><p>是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点</p>
<h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/Hardware_connection_3_5_1.png" alt="image alt text"></p>
<h3 id="软件连接"><a href="#软件连接" class="headerlink" title="软件连接"></a>软件连接</h3><p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/Apollo_3_5_software_architecture.png" alt="image alt text"></p>
<h2 id="计算平台体系结构设计"><a href="#计算平台体系结构设计" class="headerlink" title="计算平台体系结构设计"></a>计算平台体系结构设计</h2><p>详见： <a href="https://cloud.tencent.com/developer/article/1004746?from=10680" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004746?from=10680</a></p>
<h3 id="异构计算"><a href="#异构计算" class="headerlink" title="异构计算"></a>异构计算</h3><p>主要是指使用不同类型指令集和体系架构的计算单元组成系统的计算方式。</p>
<p>异构计算近年来得到更多关注，主要是因为通过提升CPU时钟频率和内核数量而提高计算能力的传统方式遇到了散热和能耗瓶颈。而与此同时，GPU等专用计算单元虽然工作频率较低，具有更多的内核数和并行计算能力，总体性能-芯片面积比和性能-功耗比都很高，却远远没有得到充分利用。广义上，不同计算平台的各个层次上都存在异构现象，除硬件层的指令集、互联方式、内存层次之外，软件层中<a href="https://zh.wikipedia.org/wiki/应用二进制接口" target="_blank" rel="noopener">应用二进制接口</a>、API、语言特性底层实现等的不同，对于上层应用和服务而言，都是异构的。</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><strong>G</strong>raphics <strong>P</strong>rocessing <strong>U</strong>nit ，EX： <strong>NVIDIA DRIVE PX 2</strong></p>
<p>GPU专为图像处理设计，主频一般在500mhz左右，但是核多啊，比如titan,有380多个流处理单元，500*400就是200g这个量级，远大与于前面2者了。</p>
<p>GPU的设计出发点在于GPU更适用于计算强度高、多并行的计算。因此，GPU把晶体管更多用于计算单元，而不像CPU用于数据Cache和流程控制器。这样的设计是因为并行计算时每个数据单元执行相同程序，不需要繁琐的流程控制而更需要高计算能力，因此也不需要大的cache容量。</p>
<p>GPU同CPU一样也是指令执行过程：取指令 -&gt;指令译码 -&gt;指令执行，只有在指令执行的时候，计算单元才发挥作用。GPU的逻辑控制单元相比CPU简单，所以要想做到指令流水处理，提高指令执行效率，必然要求处理的算法本身复杂度低，处理的数据之间相互独立，所以算法本身的串行处理会导致GPU浮点计算能力的显著降低。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/20190613175451735.png" alt="在这里插入图片描述"></p>
<p>与CPU相比，CPU芯片空间的不到20%是ALU，而GPU芯片空间的80%以上是ALU。即GPU拥有更多的ALU用于数据并行处理</p>
<ul>
<li>NVIDIA的PX平台是目前领先的基于GPU的无人驾驶解决方案。每个PX2由两个Tegra SoC和两个Pascal GPU图形处理器组成，其中每个图像处理器都有自己的专用内存并配备有专用的指令以完成深度神经网络加速。为了提供高吞吐量，每个Tegra SOC使用PCI-E Gen 2 x4总线与Pascal GPU直接相连，其总带宽为4 GB/s。此外，两个CPU-GPU集群通过千兆以太网项链，数据传输速度可达70 Gigabit/s。借助于优化的I/O架构与深度神经网络的硬件加速，每个PX2能够每秒执行24兆次深度学习计算。这意味着当运行AlexNet深度学习典型应用时，PX2的处理能力可达2800帧/秒。</li>
</ul>
<p>1 、多线程，提供了多核并行计算的基础结构，且核心数非常多，可以支撑大量数据的并行计算。</p>
<p>2、拥有更高的访存速度。</p>
<p>3、更高的浮点运算能力。</p>
<p>因此，GPU比CPU更适合深度学习中的大量训练数据、大量矩阵、卷积运算。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit ，</p>
<p>一般来说CPU运算能力最弱，CPU虽然主频最高，但是单颗也就8核、16核的样子，一个核3.5g，16核也就56g，再考虑指令周期，每秒最多也就30g次乘法。还是定点的。</p>
<p>CPU作为通用处理器，兼顾计算和控制，70%晶体管用来构建Cache 还有一部分控制单元，用来处理复杂逻辑和提高指令的执行效率，如图6所示，所以导致计算通用性强，可以处理计算复杂度高，但计算性能一般。适合逻辑控制运算</p>
<ul>
<li><p>CPU的指令执行过程是：取指令 -&gt;指令译码 -&gt;指令执行，只有在指令执行的时候，计算单元才发挥作用，这样取指令和指令译码的两段时间，计算单元是不在工作的，</p>
</li>
<li><p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/20190613175436184.png" alt="在这里插入图片描述"></p>
<p>CPU遵循的是冯诺依曼架构，其核心是存储程序、顺序执行。CPU的架构中需要大量的空间去放置存储单元（Cache）和控制单元（Control），相比之下计算单元（ALU）只占据了很小的一部分，所以它在大规模并行计算能力上极受限制，而更擅长于逻辑控制。 CPU无法做到大量矩阵数据并行计算的能力，但GPU可以。</p>
</li>
</ul>
<h3 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h3><p>Field Programmable Gate Array ,现场可编程逻辑门阵列，EX: <strong>Altera</strong> 的 <strong>CycloneV SoC</strong></p>
<p>FPGA的运算能力的，拿高端的来说。3000多个固定乘法器，拿数字逻辑还能搭3000个，最快能到接近300mhz, 也就是1800g这个量级。</p>
<p>FPGA作为一种高性能、低功耗的可编程芯片，可以根据客户定制来做针对性的算法设计。所以在处理海量数据的时候，FPGA 相比于CPU 和GPU，无指令，无需共享内存，优势在于：FPGA计算效率更高，FPGA更接近IO。</p>
<p>FPGA不采用指令和软件，是软硬件合一的器件。对FPGA进行编程要使用硬件描述语言，硬件描述语言描述的逻辑可以直接被编译为晶体管电路的组合。所以FPGA实际上直接用晶体管电路实现用户的算法，没有通过指令系统的翻译。 它就是一堆逻辑门电路的组合，可以编程，还可以重复编程。 用户可以通过烧入FPGA 配置文件来定义这些门电路以及存储器之间的连线。这种烧入不是一次性的，可重复编写定义，重复配置。</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/20190613175912795.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>FPGA的编程逻辑块（Programable Logic Blocks）中包含很多功能单元，由LUT（Look-up Table）、触发器组成。FPGA是直接通过这些门电路来实现用户的算法，没有通过指令系统的翻译，执行效率更高 ，大规模并行运算</p>
</li>
<li><p>FPGA由于算法是定制的，所以没有CPU和GPU的取指令和指令译码过程，数据流直接根据定制的算法进行固定操作，计算单元在每个时钟周期上都可以执行，所以可以充分发挥浮点计算能力，计算效率高于CPU和GPU。性能高、功耗低、可硬件编程的特点， 开发使用硬件描述语言，开发门槛相对GPU、NPU高。</p>
<p>Altera公司的Cyclone V SoC是一个基于FPGA的无人驾驶解决方案，现已应用在奥迪无人车产品中。Altera公司的FPGA专为传感器融合提供优化，可结合分析来自多个传感器的数据以完成高度可靠的物体检测。类似的产品有Zynq专为无人驾驶设计的Ultra ScaleMPSoC。当运行卷积神经网络计算任务时，Ultra ScaleMPSoC运算效能为14帧/秒/瓦，优于NVIDIA Tesla K40 GPU可达的4帧/秒/瓦。同时，在目标跟踪计算方面，Ultra ScaleMPSoC在1080p视频流上的处理能力可达60fps。</p>
</li>
</ul>
<h3 id="ASIC"><a href="#ASIC" class="headerlink" title="ASIC"></a>ASIC</h3><p><strong>A</strong>pplication <strong>S</strong>pecific <strong>I</strong>ntegrated <strong>C</strong>ircuit 专用集成电路, EX: <strong>Mobileye</strong> 的 <strong>Eyeq5</strong></p>
<p>优越性：体积小、功耗低、计算性能高、计算效率高、芯片出货量越大成本越低。但是缺点也很明显：算法是固定的，一旦算法变化就可能无法使用。FPGA成本高面向企业军工，ASIC成本面向消费电子。</p>
<p>Mobileye是一家基于ASIC的无人驾驶解决方案提供商。其Eyeq5 SOC装备有四种异构的全编程加速器，分别对专有的算法进行了优化，包括有：计算机视觉、信号处理和机器学习等。Eyeq5 SOC同时实现了两个PCI-E端口以支持多处理器间通信。这种加速器架构尝试为每一个计算任务适配最合适的计算单元，硬件资源的多样性使应用程序能够节省计算时间并提高计算效能。</p>
<h3 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h3><p><strong>digital signal processor</strong> 数字信号处理器，EX:德州仪器的 <strong>TDA2x</strong></p>
<p>DSP虽然主频不如CPU,但是胜在乘法器多，随随便便带16个乘法器，还是浮点的。再来个4核，8核，还有特定的算法硬件加速，所以虽然主频只有1,2g但是运算能力还是比CPU强。当然现在出现了带专用乘法器的CPU，DSP也集了ARM核，这两个的界限开始模糊了。<br>DSP所有计算均使用浮点算法，而且目前还没有位或整数运算指令</p>
<p>德州仪器提供了一种基于DSP的无人驾驶的解决方案。其TDA2x SoC拥有两个浮点DSP内核C66x和四个专为视觉处理设计的完全可编程的视觉加速器。相比ARM Cortex-15处理器，视觉加速器可提供八倍的视觉处理加速且功耗更低。类似设计有CEVA XM4。这是另一款基于DSP的无人驾驶计算解决方案，专门面向计算视觉任务中的视频流分析计算。使用CEVA XM4每秒处理30帧1080p的视频仅消耗功率30MW，是一种相对节能的解决方案。</p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">① 这几个应用场合不同，CPU虽然运算不行，但是擅长管理和调度，比如读取数据，管理文件，人机交互等，例程多，辅助工具也很多。</span><br><span class="line">② DSP相比而言管理弱了，运算加强了。这两者都是靠高主频来解决运算量的问题，适合有&lt;u&gt;大量递归操作以及不便拆分&lt;&#x2F;u&gt;的算法。</span><br><span class="line">③ GPU管理更弱，运算更强，但由于是多进程并发，更适合整块数据进行流处理的算法</span><br><span class="line">④ FPGA能管理能运算，但是开发周期长，复杂算法开发难度大。适合流处理算法，不管是整块数据进还是一个一个进。还有实时性来说，FPGA是最高的。前3种处理器为了避免将运算能力浪费在数据搬运上，一般要求累计一定量数据后才开始计算，产生群延时，而FPGA所有操作都并行，因此群延时可以很小</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>能耗比方面：ASIC &gt; FPGA &gt; GPU &gt; CPU</p>
<p>以人脸识别为例， 其处理基本流程及对应功能模块所需的算力分布如下：</p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/20190613175426636.png" alt="在这里插入图片描述"></p>
<p><img src="https://perfectism13.github.io/2019/11/17/%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80_%E5%B9%B3%E5%8F%B0%E6%A1%86%E6%9E%B6%E8%A1%A5%E5%85%85/20190613175919378.png" alt="在这里插入图片描述"></p>
<h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>摩尔定律（英语：Moore’s law）是由英特尔（Intel）创始人之一戈登·摩尔提出的。其内容为：集成电路上可容纳的晶体管数目，约每隔两年便会增加一倍；经常被引用的“18个月”，是由英特尔首席执行官大卫·豪斯（David House）提出：预计18个月会将芯片的性能提高一倍（即更多的晶体管使其更快），是一种以倍数增长的观测。</p>
<h2 id="车辆实时操作系统"><a href="#车辆实时操作系统" class="headerlink" title="车辆实时操作系统"></a>车辆实时操作系统</h2><p>详见： <a href="https://zhuanlan.zhihu.com/p/45294616" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45294616</a></p>
<h3 id="QNX"><a href="#QNX" class="headerlink" title="QNX"></a>QNX</h3><p>QNX，英文名Quick Unix，是由加拿大QSSL公司（2010年被加拿大黑莓公司收购）开发的分布式实时操作系统，采用独特的微内核实时平台，相比Windos、Linux等大型操作系统，QNX内核极小且运行速度极快。 除了快，QNX的实时性、稳定性也极高，据说MTTF（平均失效时间）可以达到99.999%（5个9），也就是说，一年365天当中，它可能出错的时间只有31秒。</p>
<p><strong>EX</strong>：Apollo2.0整合了QNX操作系统，大众、宝马、丰田、菲亚特、福特等</p>
<h3 id="WinCE"><a href="#WinCE" class="headerlink" title="WinCE"></a>WinCE</h3><p>Windos Embedbed Compact, 微软Windows操作系统中的一员 ,相对于Android系统的丰富体验，Windos CE就显得捉襟见肘。由于车机系统大部分应用场景是导航和音乐，移动互联时代，任何一部智能手机都能取代车机，而获得更佳的用户体验。</p>
<p><strong>EX</strong>： 早期如凯立德、四维图新等车载导航系统供应商，都是基于Windos CE开发的</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>免费开源、可个性化定制、 稳定性及处理效率较好、 基于Linux开发的难度也极大，而且开发周期比较长， 限制了车机系统进入门槛，除了规模较大的主机厂，以及有实力的车机供应商，能够花重金雇佣一支专业操作系统研发团队，其余的也只能望尘莫及 。</p>
<p><strong>EX:</strong> 凯迪拉克CUE系统</p>
<h3 id="VxWorks"><a href="#VxWorks" class="headerlink" title="VxWorks"></a>VxWorks</h3><p>美国 Wind River System 公司（ 简称风河公司 ，即 WRS 公司）推出的一个实时操作系统。</p>
]]></content>
  </entry>
  <entry>
    <title>我的CV&amp;DL之路</title>
    <url>/2020/07/24/%E6%88%91%E7%9A%84CV&amp;DL%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><ul>
<li>[ ] OpenCV to python</li>
<li>[ ] OpenCV to c++</li>
</ul>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><ul>
<li>[ ] data structure</li>
<li>[ ] ROS to Ubantu</li>
<li>[ ] python</li>
<li>[ ] c++</li>
<li>[ ] leetcode</li>
</ul>
<h2 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h2><ul>
<li>[x] DNN</li>
<li>[x] CNN</li>
<li>[x] RNN,LSTM</li>
<li>[x] use google colab to train my model</li>
<li>[ ] transfer learning</li>
<li>[ ] deploy</li>
<li>[ ] distributed system</li>
</ul>
<h2 id="Action-Recognition"><a href="#Action-Recognition" class="headerlink" title="Action Recognition"></a>Action Recognition</h2><ul>
<li>[ ] Survey of action recognition</li>
<li>[ ] static action recognition</li>
<li>[ ] action recognition in video</li>
<li>[ ] LSTM to action recognition</li>
<li>[ ] Skeleton-Based Action Recognition</li>
<li>[ ] Use OpenVINO to deploy model</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>环境配置常见问题</title>
    <url>/2020/07/24/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="环境配置常见问题"><a href="#环境配置常见问题" class="headerlink" title="环境配置常见问题"></a>环境配置常见问题</h1><h2 id="hexo博客"><a href="#hexo博客" class="headerlink" title="hexo博客"></a>hexo博客</h2><h3 id="sh-deploy-sh出现-spawn-failed"><a href="#sh-deploy-sh出现-spawn-failed" class="headerlink" title="sh deploy.sh出现 spawn failed"></a>sh deploy.sh出现 spawn failed</h3><p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><h3 id="navigator不能打开"><a href="#navigator不能打开" class="headerlink" title="navigator不能打开"></a>navigator不能打开</h3><p>1.重置源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --remove -key channels</span><br></pre></td></tr></table></figure>
<p>2.删除清华镜像：删除 <code>.condarc</code>中的<code>defaults</code>行</p>
<p>2.管理员运行<code>conda prompt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#conda update </span><br><span class="line">conda update anaconda-navigator</span><br><span class="line">anaconda-navigator --reset</span><br><span class="line">conda update anaconda-client</span><br><span class="line">conda update -f anaconda-client</span><br><span class="line">anaconda-navigator   #命令行启动Navigator</span><br></pre></td></tr></table></figure>
<h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No module named &#39;torchtext&#39;</span><br></pre></td></tr></table></figure>
<p>办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install https:&#x2F;&#x2F;github.com&#x2F;pytorch&#x2F;text&#x2F;archive&#x2F;master.zip</span><br></pre></td></tr></table></figure>
<p>tqdm模块<br>tqdm是一个快速、扩展性强的进度条工具库，<br>其githup地址：<a href="https://github.com/tqdm/tqdm" target="_blank" rel="noopener">https://github.com/tqdm/tqdm</a></p>
<p>办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install tqdm</span><br><span class="line">device &#x3D; torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)</span><br><span class="line">#ouput cpu</span><br></pre></td></tr></table></figure>
<h2 id="Jupyter-Lab"><a href="#Jupyter-Lab" class="headerlink" title="Jupyter Lab"></a>Jupyter Lab</h2><p>载入py文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%load test.py</span><br></pre></td></tr></table></figure>
<h2 id="CUDA-cudnn"><a href="#CUDA-cudnn" class="headerlink" title="CUDA cudnn"></a>CUDA cudnn</h2><p>CUDA 10.1</p>
<p>cudnn 7.6.3</p>
<h2 id="使用特定源安装"><a href="#使用特定源安装" class="headerlink" title="使用特定源安装"></a>使用特定源安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu&#x3D;&#x3D;1.8 -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>
<h3 id="升级pip"><a href="#升级pip" class="headerlink" title="升级pip"></a>升级pip</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip install -U pip</span><br></pre></td></tr></table></figure>
<p>tensorflow与keras间的兼容</p>
<p><a href="https://docs.floydhub.com/guides/environments/" target="_blank" rel="noopener">https://docs.floydhub.com/guides/environments/</a></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="解压zip"><a href="#解压zip" class="headerlink" title="解压zip"></a>解压zip</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip test.zip</span><br></pre></td></tr></table></figure>
<h3 id="解压7z"><a href="#解压7z" class="headerlink" title="解压7z"></a>解压7z</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install p7zip</span><br><span class="line">7z x test.7z</span><br></pre></td></tr></table></figure>
<p>详见 <a href="https://blog.csdn.net/AC_huang/article/details/23279641" target="_blank" rel="noopener">https://blog.csdn.net/AC_huang/article/details/23279641</a></p>
<h3 id="展示文件树状结构"><a href="#展示文件树状结构" class="headerlink" title="展示文件树状结构"></a>展示文件树状结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tree</span><br><span class="line">tree --dirsfirst --filelimit 50</span><br></pre></td></tr></table></figure>
<h3 id="命令行退出python"><a href="#命令行退出python" class="headerlink" title="命令行退出python"></a>命令行退出python</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quit()</span><br></pre></td></tr></table></figure>
<h2 id="matlab"><a href="#matlab" class="headerlink" title="matlab"></a>matlab</h2><p>匿名函数求导后，求某点值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syms y</span><br><span class="line">f&#x3D;@(x) 2*x^2+3;</span><br><span class="line">diff&#x3D;diff(f(y)) </span><br><span class="line">diff&#x3D;matlabFunction(diff)</span><br><span class="line">diff(0.5)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>用Keras实现视频动作分类</title>
    <url>/2020/07/24/%E7%94%A8Keras%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%8A%A8%E4%BD%9C%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="用Keras实现视频动作分类"><a href="#用Keras实现视频动作分类" class="headerlink" title="用Keras实现视频动作分类"></a>用Keras实现视频动作分类</h1><p>使用LSTM或者RNN处理时序信息太费时间</p>
<p>所以我们先训练一个用于图片上运动信息分类的CNN，通过采用一种滚动平均的方法将其应用在视频分类中</p>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><ol>
<li>Loop over all frames in the video file</li>
<li>For each frame, pass the frame through the CNN</li>
<li>Classify each frame <em>individually</em> and <em>independently</em> of each other</li>
<li>Choose the label with the largest corresponding probability</li>
<li>Label the frame and write the output frame to disk</li>
</ol>
<p>if you’ve ever tried to apply simple image classification to video classification you likely encountered a sort of <strong>“prediction flickering”</strong>（预测闪烁）</p>
<p>因此如何避免CNN模型在两个标签之间闪烁很重要</p>
<h3 id="使用滚动平均方法（rolling-prediction-average）"><a href="#使用滚动平均方法（rolling-prediction-average）" class="headerlink" title="使用滚动平均方法（rolling prediction average）"></a>使用滚动平均方法（<strong>rolling prediction average</strong>）</h3><p>假设视频里的随后几帧含有相同的语义内容</p>
<ol>
<li>Loop over all frames in the video file</li>
<li>For each frame, pass the frame through the CNN</li>
<li>Obtain the predictions from the CNN</li>
<li>Maintain a list of the last <em>K</em> predictions</li>
<li>Compute the average of the last <em>K</em> predictions and choose the label with the largest corresponding probability（假设每个视频帧有三个概率输出，则将3xK平均为单个3，然后取概率最大的标签）</li>
<li>Label the frame and write the output frame to disk</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码链接：</p>
<p><a href="https://github.com/perfectism13/learning_colab" target="_blank" rel="noopener">https://github.com/perfectism13/learning_colab</a></p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from google.colab import drive</span><br><span class="line">drive.mount(&#39;&#x2F;content&#x2F;drive&#39;)</span><br><span class="line">import os</span><br><span class="line">os.chdir(r&#39;&#x2F;content&#x2F;drive&#x2F;My Drive&#x2F;colab&#x2F;keras-video-classification&#x2F;keras-video-classification&#39;)</span><br><span class="line">print(os.getcwd())</span><br><span class="line">!ls</span><br><span class="line">!apt-get install p7zip</span><br><span class="line">!7z x sports-type-classifier-data.7z</span><br><span class="line">!ls</span><br><span class="line">!tree --dirsfirst --filelimit 50</span><br></pre></td></tr></table></figure>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># USAGE</span><br><span class="line"># python train.py --dataset Sports-Type-Classifier&#x2F;data --model model&#x2F;activity.model --label-bin model&#x2F;lb.pickle --epochs 50</span><br><span class="line"></span><br><span class="line"># set the matplotlib backend so figures can be saved in the background</span><br><span class="line">import matplotlib</span><br><span class="line">matplotlib.use(&quot;Agg&quot;)</span><br><span class="line"></span><br><span class="line"># import the necessary packages</span><br><span class="line">from keras.preprocessing.image import ImageDataGenerator</span><br><span class="line">from keras.layers.pooling import AveragePooling2D</span><br><span class="line">from keras.applications import ResNet50</span><br><span class="line">from keras.layers.core import Dropout</span><br><span class="line">from keras.layers.core import Flatten</span><br><span class="line">from keras.layers.core import Dense</span><br><span class="line">from keras.layers import Input</span><br><span class="line">from keras.models import Model</span><br><span class="line">from keras.optimizers import SGD</span><br><span class="line">from sklearn.preprocessing import LabelBinarizer</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.metrics import classification_report</span><br><span class="line">from imutils import paths</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line">import pickle</span><br><span class="line">import cv2</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># construct the argument parser and parse the arguments</span><br><span class="line"># 构建python文件运行时的命令行输入</span><br><span class="line">ap &#x3D; argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(&quot;-d&quot;, &quot;--dataset&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to input dataset&quot;)</span><br><span class="line">ap.add_argument(&quot;-m&quot;, &quot;--model&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to output serialized model&quot;)</span><br><span class="line">ap.add_argument(&quot;-l&quot;, &quot;--label-bin&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to output label binarizer&quot;)</span><br><span class="line">ap.add_argument(&quot;-e&quot;, &quot;--epochs&quot;, type&#x3D;int, default&#x3D;25,</span><br><span class="line">	help&#x3D;&quot;# of epochs to train our network for&quot;)</span><br><span class="line">ap.add_argument(&quot;-p&quot;, &quot;--plot&quot;, type&#x3D;str, default&#x3D;&quot;plot.png&quot;,</span><br><span class="line">	help&#x3D;&quot;path to output loss&#x2F;accuracy plot&quot;)</span><br><span class="line">args &#x3D; vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line"># initialize the set of labels from the spots activity dataset we are</span><br><span class="line"># going to train our network on</span><br><span class="line">LABELS &#x3D; set([&quot;weight_lifting&quot;, &quot;tennis&quot;, &quot;football&quot;])</span><br><span class="line"></span><br><span class="line"># grab the list of images in our dataset directory, then initialize</span><br><span class="line"># the list of data (i.e., images) and class images</span><br><span class="line">print(&quot;[INFO] loading images...&quot;)</span><br><span class="line"># 通过imtuils的paths类获取dataset对应路径下所有图片的路径</span><br><span class="line">imagePaths &#x3D; list(paths.list_images(args[&quot;dataset&quot;])) </span><br><span class="line">data &#x3D; []</span><br><span class="line">labels &#x3D; []</span><br><span class="line"></span><br><span class="line"># loop over the image paths</span><br><span class="line">for imagePath in imagePaths:</span><br><span class="line">	# extract the class label from the filename</span><br><span class="line">	label &#x3D; imagePath.split(os.path.sep)[-2]</span><br><span class="line"></span><br><span class="line">	# if the label of the current image is not part of of the labels</span><br><span class="line">	# are interested in, then ignore the image</span><br><span class="line">	# 跳过不参与训练的标签对应的图片</span><br><span class="line">	if label not in LABELS:</span><br><span class="line">		continue</span><br><span class="line"></span><br><span class="line">	# load the image, convert it to RGB channel ordering, and resize</span><br><span class="line">	# it to be a fixed 224x224 pixels, ignoring aspect ratio</span><br><span class="line">	image &#x3D; cv2.imread(imagePath)</span><br><span class="line">	image &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line">	image &#x3D; cv2.resize(image, (224, 224))</span><br><span class="line"></span><br><span class="line">	# update the data and labels lists, respectively</span><br><span class="line">	# 储存训练标签和图片</span><br><span class="line">	data.append(image)</span><br><span class="line">	labels.append(label)</span><br><span class="line"></span><br><span class="line"># convert the data and labels to NumPy arrays</span><br><span class="line"># 将数据和标签转换成numpy数组</span><br><span class="line">data &#x3D; np.array(data)</span><br><span class="line">labels &#x3D; np.array(labels)</span><br><span class="line"></span><br><span class="line"># perform one-hot encoding on the labels</span><br><span class="line"># 通过二值元素数组来对标签进行一键编码</span><br><span class="line">lb &#x3D; LabelBinarizer()</span><br><span class="line">labels &#x3D; lb.fit_transform(labels)</span><br><span class="line"></span><br><span class="line"># partition the data into training and testing splits using 75% of</span><br><span class="line"># the data for training and the remaining 25% for testing</span><br><span class="line"># 将整个数据的%75用来训练剩下的用来检验</span><br><span class="line">(trainX, testX, trainY, testY) &#x3D; train_test_split(data, labels,</span><br><span class="line">	test_size&#x3D;0.25, stratify&#x3D;labels, random_state&#x3D;42)</span><br><span class="line"></span><br><span class="line"># initialize the training data augmentation object</span><br><span class="line"># 声明训练时的数据增强操作</span><br><span class="line">trainAug &#x3D; ImageDataGenerator(</span><br><span class="line">	rotation_range&#x3D;30,</span><br><span class="line">	zoom_range&#x3D;0.15,</span><br><span class="line">	width_shift_range&#x3D;0.2,</span><br><span class="line">	height_shift_range&#x3D;0.2,</span><br><span class="line">	shear_range&#x3D;0.15,</span><br><span class="line">	horizontal_flip&#x3D;True,</span><br><span class="line">	fill_mode&#x3D;&quot;nearest&quot;)</span><br><span class="line"></span><br><span class="line"># initialize the validation&#x2F;testing data augmentation object (which</span><br><span class="line"># we&#39;ll be adding mean subtraction to)</span><br><span class="line"># 测验时无数据增强操作</span><br><span class="line">valAug &#x3D; ImageDataGenerator()</span><br><span class="line"></span><br><span class="line"># define the ImageNet mean subtraction (in RGB order) and set the</span><br><span class="line"># the mean subtraction value for each of the data augmentation</span><br><span class="line"># objects</span><br><span class="line"># 设置训练和测试时用来归一化的图片每个通道的均值</span><br><span class="line">mean &#x3D; np.array([123.68, 116.779, 103.939], dtype&#x3D;&quot;float32&quot;)</span><br><span class="line">trainAug.mean &#x3D; mean</span><br><span class="line">valAug.mean &#x3D; mean</span><br><span class="line"></span><br><span class="line"># load the ResNet-50 network, ensuring the head FC layer sets are left</span><br><span class="line"># off</span><br><span class="line"># 通过keras.applications来获取预训练的resnet50模型</span><br><span class="line">baseModel &#x3D; ResNet50(weights&#x3D;&quot;imagenet&quot;, include_top&#x3D;False,</span><br><span class="line">	input_tensor&#x3D;Input(shape&#x3D;(224, 224, 3)))</span><br><span class="line"></span><br><span class="line"># construct the head of the model that will be placed on top of the</span><br><span class="line"># the base model</span><br><span class="line"># 定义basemodel前的全连接层</span><br><span class="line">headModel &#x3D; baseModel.output</span><br><span class="line">headModel &#x3D; AveragePooling2D(pool_size&#x3D;(7, 7))(headModel)</span><br><span class="line">headModel &#x3D; Flatten(name&#x3D;&quot;flatten&quot;)(headModel)</span><br><span class="line">headModel &#x3D; Dense(512, activation&#x3D;&quot;relu&quot;)(headModel)</span><br><span class="line">headModel &#x3D; Dropout(0.5)(headModel)</span><br><span class="line">headModel &#x3D; Dense(len(lb.classes_), activation&#x3D;&quot;softmax&quot;)(headModel)</span><br><span class="line"></span><br><span class="line"># place the head FC model on top of the base model (this will become</span><br><span class="line"># the actual model we will train)</span><br><span class="line"># 在basemodel前加上一个全连接层来微调</span><br><span class="line">model &#x3D; Model(inputs&#x3D;baseModel.input, outputs&#x3D;headModel)</span><br><span class="line"></span><br><span class="line"># loop over all layers in the base model and freeze them so they will</span><br><span class="line"># *not* be updated during the training process</span><br><span class="line"># 训练时将basemodel里的全部参数冻结</span><br><span class="line">for layer in baseModel.layers:</span><br><span class="line">	layer.trainable &#x3D; False</span><br><span class="line"></span><br><span class="line"># compile our model (this needs to be done after our setting our</span><br><span class="line"># layers to being non-trainable)</span><br><span class="line"># 定义初始学习率和优化方法来编译模型</span><br><span class="line">print(&quot;[INFO] compiling model...&quot;)</span><br><span class="line">opt &#x3D; SGD(lr&#x3D;1e-4, momentum&#x3D;0.9, decay&#x3D;1e-4 &#x2F; args[&quot;epochs&quot;])</span><br><span class="line">model.compile(loss&#x3D;&quot;categorical_crossentropy&quot;, optimizer&#x3D;opt,</span><br><span class="line">	metrics&#x3D;[&quot;accuracy&quot;])</span><br><span class="line"></span><br><span class="line"># train the head of the network for a few epochs (all other layers</span><br><span class="line"># are frozen) -- this will allow the new FC layers to start to become</span><br><span class="line"># initialized with actual &quot;learned&quot; values versus pure random</span><br><span class="line"># 使用fit_generator类来对逐批生成的数据进行训练</span><br><span class="line">print(&quot;[INFO] training head...&quot;)</span><br><span class="line">H &#x3D; model.fit_generator(</span><br><span class="line">	trainAug.flow(trainX, trainY, batch_size&#x3D;32),</span><br><span class="line">	steps_per_epoch&#x3D;len(trainX) &#x2F;&#x2F; 32,</span><br><span class="line">	validation_data&#x3D;valAug.flow(testX, testY),</span><br><span class="line">	validation_steps&#x3D;len(testX) &#x2F;&#x2F; 32,</span><br><span class="line">	epochs&#x3D;args[&quot;epochs&quot;])</span><br><span class="line"></span><br><span class="line"># evaluate the network</span><br><span class="line"># 使用sklearn的classification_report类查看预测效果</span><br><span class="line">print(&quot;[INFO] evaluating network...&quot;)</span><br><span class="line">predictions &#x3D; model.predict(testX, batch_size&#x3D;32)</span><br><span class="line">print(classification_report(testY.argmax(axis&#x3D;1), </span><br><span class="line">	predictions.argmax(axis&#x3D;1), target_names&#x3D;lb.classes_))</span><br><span class="line"></span><br><span class="line"># plot the training loss and accuracy</span><br><span class="line"># 打印训练loss和准确性等</span><br><span class="line">N &#x3D; args[&quot;epochs&quot;]</span><br><span class="line">plt.style.use(&quot;ggplot&quot;)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.arange(0, N), H.history[&quot;loss&quot;], label&#x3D;&quot;train_loss&quot;)</span><br><span class="line">plt.plot(np.arange(0, N), H.history[&quot;val_loss&quot;], label&#x3D;&quot;val_loss&quot;)</span><br><span class="line">plt.plot(np.arange(0, N), H.history[&quot;acc&quot;], label&#x3D;&quot;train_acc&quot;)</span><br><span class="line">plt.plot(np.arange(0, N), H.history[&quot;val_acc&quot;], label&#x3D;&quot;val_acc&quot;)</span><br><span class="line">plt.title(&quot;Training Loss and Accuracy on Dataset&quot;)</span><br><span class="line">plt.xlabel(&quot;Epoch #&quot;)</span><br><span class="line">plt.ylabel(&quot;Loss&#x2F;Accuracy&quot;)</span><br><span class="line">plt.legend(loc&#x3D;&quot;lower left&quot;) # 标签说明放在左下角</span><br><span class="line">plt.savefig(args[&quot;plot&quot;])</span><br><span class="line"></span><br><span class="line"># serialize the model to disk</span><br><span class="line"># 讲训练好的模型保存</span><br><span class="line">print(&quot;[INFO] serializing network...&quot;)</span><br><span class="line">model.save(args[&quot;model&quot;])</span><br><span class="line"></span><br><span class="line"># serialize the label binarizer to disk</span><br><span class="line"># 保存标签二值化器</span><br><span class="line">f &#x3D; open(args[&quot;label_bin&quot;], &quot;wb&quot;)</span><br><span class="line">f.write(pickle.dumps(lb))</span><br><span class="line">f.close()</span><br><span class="line">!python train.py --dataset data --model output&#x2F;activity.model \</span><br><span class="line">	--label-bin output&#x2F;lb.pickle --epochs 50</span><br><span class="line">Using TensorFlow backend.</span><br><span class="line">[INFO] loading images...</span><br><span class="line">libpng warning: iCCP: known incorrect sRGB profile</span><br><span class="line">libpng warning: iCCP: known incorrect sRGB profile</span><br><span class="line">libpng warning: iCCP: known incorrect sRGB profile</span><br><span class="line">libpng warning: iCCP: known incorrect sRGB profile</span><br><span class="line">libpng warning: iCCP: known incorrect sRGB profile</span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:66: The name tf.get_default_graph is deprecated. Please use tf.compat.v1.get_default_graph instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:541: The name tf.placeholder is deprecated. Please use tf.compat.v1.placeholder instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:4479: The name tf.truncated_normal is deprecated. Please use tf.random.truncated_normal instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:190: The name tf.get_default_session is deprecated. Please use tf.compat.v1.get_default_session instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:197: The name tf.ConfigProto is deprecated. Please use tf.compat.v1.ConfigProto instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:203: The name tf.Session is deprecated. Please use tf.compat.v1.Session instead.</span><br><span class="line"></span><br><span class="line">2019-12-14 08:24:02.011318: I tensorflow&#x2F;core&#x2F;platform&#x2F;profile_utils&#x2F;cpu_utils.cc:94] CPU Frequency: 2300000000 Hz</span><br><span class="line">2019-12-14 08:24:02.013846: I tensorflow&#x2F;compiler&#x2F;xla&#x2F;service&#x2F;service.cc:168] XLA service 0x2306840 initialized for platform Host (this does not guarantee that XLA will be used). Devices:</span><br><span class="line">2019-12-14 08:24:02.013885: I tensorflow&#x2F;compiler&#x2F;xla&#x2F;service&#x2F;service.cc:176]   StreamExecutor device (0): Host, Default Version</span><br><span class="line">2019-12-14 08:24:02.018815: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcuda.so.1</span><br><span class="line">2019-12-14 08:24:02.152830: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_gpu_executor.cc:983] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2019-12-14 08:24:02.153830: I tensorflow&#x2F;compiler&#x2F;xla&#x2F;service&#x2F;service.cc:168] XLA service 0x2306bc0 initialized for platform CUDA (this does not guarantee that XLA will be used). Devices:</span><br><span class="line">2019-12-14 08:24:02.153865: I tensorflow&#x2F;compiler&#x2F;xla&#x2F;service&#x2F;service.cc:176]   StreamExecutor device (0): Tesla K80, Compute Capability 3.7</span><br><span class="line">2019-12-14 08:24:02.155504: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_gpu_executor.cc:983] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2019-12-14 08:24:02.156205: I tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_device.cc:1618] Found device 0 with properties: </span><br><span class="line">name: Tesla K80 major: 3 minor: 7 memoryClockRate(GHz): 0.8235</span><br><span class="line">pciBusID: 0000:00:04.0</span><br><span class="line">2019-12-14 08:24:02.176292: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcudart.so.10.1</span><br><span class="line">2019-12-14 08:24:02.394209: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcublas.so.10</span><br><span class="line">2019-12-14 08:24:02.508460: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcufft.so.10</span><br><span class="line">2019-12-14 08:24:02.530840: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcurand.so.10</span><br><span class="line">2019-12-14 08:24:02.748284: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcusolver.so.10</span><br><span class="line">2019-12-14 08:24:02.770949: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcusparse.so.10</span><br><span class="line">2019-12-14 08:24:03.213586: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcudnn.so.7</span><br><span class="line">2019-12-14 08:24:03.213829: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_gpu_executor.cc:983] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2019-12-14 08:24:03.214779: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_gpu_executor.cc:983] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2019-12-14 08:24:03.215576: I tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_device.cc:1746] Adding visible gpu devices: 0</span><br><span class="line">2019-12-14 08:24:03.220635: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcudart.so.10.1</span><br><span class="line">2019-12-14 08:24:03.222331: I tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_device.cc:1159] Device interconnect StreamExecutor with strength 1 edge matrix:</span><br><span class="line">2019-12-14 08:24:03.222385: I tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_device.cc:1165]      0 </span><br><span class="line">2019-12-14 08:24:03.222418: I tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_device.cc:1178] 0:   N </span><br><span class="line">2019-12-14 08:24:03.223491: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_gpu_executor.cc:983] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2019-12-14 08:24:03.224341: I tensorflow&#x2F;stream_executor&#x2F;cuda&#x2F;cuda_gpu_executor.cc:983] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero</span><br><span class="line">2019-12-14 08:24:03.225215: W tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_bfc_allocator.cc:39] Overriding allow_growth setting because the TF_FORCE_GPU_ALLOW_GROWTH environment variable is set. Original config value was 0.</span><br><span class="line">2019-12-14 08:24:03.225289: I tensorflow&#x2F;core&#x2F;common_runtime&#x2F;gpu&#x2F;gpu_device.cc:1304] Created TensorFlow device (&#x2F;job:localhost&#x2F;replica:0&#x2F;task:0&#x2F;device:GPU:0 with 10805 MB memory) -&gt; physical GPU (device: 0, name: Tesla K80, pci bus id: 0000:00:04.0, compute capability: 3.7)</span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:207: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:216: The name tf.is_variable_initialized is deprecated. Please use tf.compat.v1.is_variable_initialized instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:223: The name tf.variables_initializer is deprecated. Please use tf.compat.v1.variables_initializer instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:2041: The name tf.nn.fused_batch_norm is deprecated. Please use tf.compat.v1.nn.fused_batch_norm instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:148: The name tf.placeholder_with_default is deprecated. Please use tf.compat.v1.placeholder_with_default instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:4267: The name tf.nn.max_pool is deprecated. Please use tf.nn.max_pool2d instead.</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras_applications&#x2F;resnet50.py:265: UserWarning: The output shape of &#96;ResNet50(include_top&#x3D;False)&#96; has been changed since Keras 2.2.0.</span><br><span class="line">  warnings.warn(&#39;The output shape of &#96;ResNet50(include_top&#x3D;False)&#96; &#39;</span><br><span class="line">Downloading data from https:&#x2F;&#x2F;github.com&#x2F;fchollet&#x2F;deep-learning-models&#x2F;releases&#x2F;download&#x2F;v0.2&#x2F;resnet50_weights_tf_dim_ordering_tf_kernels_notop.h5</span><br><span class="line">94658560&#x2F;94653016 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 7s 0us&#x2F;step</span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:4271: The name tf.nn.avg_pool is deprecated. Please use tf.nn.avg_pool2d instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:4432: The name tf.random_uniform is deprecated. Please use tf.random.uniform instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:3733: calling dropout (from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please use &#96;rate&#96; instead of &#96;keep_prob&#96;. Rate should be set to &#96;rate &#x3D; 1 - keep_prob&#96;.</span><br><span class="line">[INFO] compiling model...</span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;optimizers.py:793: The name tf.train.Optimizer is deprecated. Please use tf.compat.v1.train.Optimizer instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:3576: The name tf.log is deprecated. Please use tf.math.log instead.</span><br><span class="line"></span><br><span class="line">[INFO] training head...</span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;tensorflow_core&#x2F;python&#x2F;ops&#x2F;math_grad.py:1424: where (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Use tf.where in 2.0, which has the same broadcast rule as np.where</span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:1033: The name tf.assign_add is deprecated. Please use tf.compat.v1.assign_add instead.</span><br><span class="line"></span><br><span class="line">WARNING:tensorflow:From &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;dist-packages&#x2F;keras&#x2F;backend&#x2F;tensorflow_backend.py:1020: The name tf.assign is deprecated. Please use tf.compat.v1.assign instead.</span><br><span class="line"></span><br><span class="line">Epoch 1&#x2F;50</span><br><span class="line">2019-12-14 08:24:25.840365: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcublas.so.10</span><br><span class="line">2019-12-14 08:24:26.891772: I tensorflow&#x2F;stream_executor&#x2F;platform&#x2F;default&#x2F;dso_loader.cc:44] Successfully opened dynamic library libcudnn.so.7</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 29s 597ms&#x2F;step - loss: 1.2660 - acc: 0.3822 - val_loss: 0.9862 - val_acc: 0.5332</span><br><span class="line">Epoch 2&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 24s 504ms&#x2F;step - loss: 1.0399 - acc: 0.4962 - val_loss: 0.8028 - val_acc: 0.6337</span><br><span class="line">Epoch 3&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 24s 496ms&#x2F;step - loss: 0.8882 - acc: 0.5950 - val_loss: 0.6543 - val_acc: 0.7119</span><br><span class="line">Epoch 4&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 23s 478ms&#x2F;step - loss: 0.8053 - acc: 0.6517 - val_loss: 0.5938 - val_acc: 0.7510</span><br><span class="line">Epoch 5&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 23s 479ms&#x2F;step - loss: 0.7165 - acc: 0.6940 - val_loss: 0.4964 - val_acc: 0.8045</span><br><span class="line">Epoch 6&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 24s 490ms&#x2F;step - loss: 0.6342 - acc: 0.7500 - val_loss: 0.4970 - val_acc: 0.8148</span><br><span class="line">Epoch 7&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 23s 471ms&#x2F;step - loss: 0.6217 - acc: 0.7526 - val_loss: 0.4313 - val_acc: 0.8313</span><br><span class="line">Epoch 8&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 464ms&#x2F;step - loss: 0.5881 - acc: 0.7832 - val_loss: 0.3984 - val_acc: 0.8683</span><br><span class="line">Epoch 9&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 23s 475ms&#x2F;step - loss: 0.5611 - acc: 0.7741 - val_loss: 0.4083 - val_acc: 0.8498</span><br><span class="line">Epoch 10&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 23s 471ms&#x2F;step - loss: 0.5241 - acc: 0.8073 - val_loss: 0.3564 - val_acc: 0.8807</span><br><span class="line">Epoch 11&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 459ms&#x2F;step - loss: 0.4947 - acc: 0.8171 - val_loss: 0.3755 - val_acc: 0.8642</span><br><span class="line">Epoch 12&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 467ms&#x2F;step - loss: 0.4841 - acc: 0.8190 - val_loss: 0.3499 - val_acc: 0.8704</span><br><span class="line">Epoch 13&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 463ms&#x2F;step - loss: 0.4801 - acc: 0.8196 - val_loss: 0.3397 - val_acc: 0.8704</span><br><span class="line">Epoch 14&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 455ms&#x2F;step - loss: 0.4430 - acc: 0.8242 - val_loss: 0.3491 - val_acc: 0.8786</span><br><span class="line">Epoch 15&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 456ms&#x2F;step - loss: 0.4179 - acc: 0.8477 - val_loss: 0.2985 - val_acc: 0.8909</span><br><span class="line">Epoch 16&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 448ms&#x2F;step - loss: 0.4189 - acc: 0.8379 - val_loss: 0.3302 - val_acc: 0.8807</span><br><span class="line">Epoch 17&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 454ms&#x2F;step - loss: 0.4167 - acc: 0.8425 - val_loss: 0.3139 - val_acc: 0.8868</span><br><span class="line">Epoch 18&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 464ms&#x2F;step - loss: 0.3985 - acc: 0.8444 - val_loss: 0.3067 - val_acc: 0.8926</span><br><span class="line">Epoch 19&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 447ms&#x2F;step - loss: 0.3881 - acc: 0.8587 - val_loss: 0.3024 - val_acc: 0.8951</span><br><span class="line">Epoch 20&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 459ms&#x2F;step - loss: 0.3944 - acc: 0.8548 - val_loss: 0.2902 - val_acc: 0.8992</span><br><span class="line">Epoch 21&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 446ms&#x2F;step - loss: 0.3782 - acc: 0.8620 - val_loss: 0.2824 - val_acc: 0.9115</span><br><span class="line">Epoch 22&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 440ms&#x2F;step - loss: 0.4034 - acc: 0.8412 - val_loss: 0.3105 - val_acc: 0.9012</span><br><span class="line">Epoch 23&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 461ms&#x2F;step - loss: 0.3600 - acc: 0.8691 - val_loss: 0.2667 - val_acc: 0.9012</span><br><span class="line">Epoch 24&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 456ms&#x2F;step - loss: 0.3357 - acc: 0.8750 - val_loss: 0.2630 - val_acc: 0.9177</span><br><span class="line">Epoch 25&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 440ms&#x2F;step - loss: 0.3411 - acc: 0.8737 - val_loss: 0.3130 - val_acc: 0.8951</span><br><span class="line">Epoch 26&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 460ms&#x2F;step - loss: 0.3312 - acc: 0.8848 - val_loss: 0.2747 - val_acc: 0.9198</span><br><span class="line">Epoch 27&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 448ms&#x2F;step - loss: 0.3401 - acc: 0.8691 - val_loss: 0.2811 - val_acc: 0.9033</span><br><span class="line">Epoch 28&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 445ms&#x2F;step - loss: 0.3326 - acc: 0.8776 - val_loss: 0.2546 - val_acc: 0.9280</span><br><span class="line">Epoch 29&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 442ms&#x2F;step - loss: 0.3445 - acc: 0.8692 - val_loss: 0.2683 - val_acc: 0.9156</span><br><span class="line">Epoch 30&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 454ms&#x2F;step - loss: 0.3072 - acc: 0.8854 - val_loss: 0.2658 - val_acc: 0.9095</span><br><span class="line">Epoch 31&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 449ms&#x2F;step - loss: 0.3029 - acc: 0.8978 - val_loss: 0.2819 - val_acc: 0.9033</span><br><span class="line">Epoch 32&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 457ms&#x2F;step - loss: 0.3123 - acc: 0.8900 - val_loss: 0.2680 - val_acc: 0.9198</span><br><span class="line">Epoch 33&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 450ms&#x2F;step - loss: 0.3020 - acc: 0.8867 - val_loss: 0.2422 - val_acc: 0.9198</span><br><span class="line">Epoch 34&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 463ms&#x2F;step - loss: 0.3244 - acc: 0.8802 - val_loss: 0.2712 - val_acc: 0.9115</span><br><span class="line">Epoch 35&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 462ms&#x2F;step - loss: 0.2898 - acc: 0.8952 - val_loss: 0.2588 - val_acc: 0.9160</span><br><span class="line">Epoch 36&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 454ms&#x2F;step - loss: 0.3157 - acc: 0.8854 - val_loss: 0.2807 - val_acc: 0.9095</span><br><span class="line">Epoch 37&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 465ms&#x2F;step - loss: 0.3021 - acc: 0.8848 - val_loss: 0.2514 - val_acc: 0.9218</span><br><span class="line">Epoch 38&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 453ms&#x2F;step - loss: 0.3053 - acc: 0.8731 - val_loss: 0.2646 - val_acc: 0.9053</span><br><span class="line">Epoch 39&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 454ms&#x2F;step - loss: 0.2845 - acc: 0.8874 - val_loss: 0.2502 - val_acc: 0.9177</span><br><span class="line">Epoch 40&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 443ms&#x2F;step - loss: 0.2850 - acc: 0.8972 - val_loss: 0.2571 - val_acc: 0.9136</span><br><span class="line">Epoch 41&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 461ms&#x2F;step - loss: 0.2892 - acc: 0.8997 - val_loss: 0.2667 - val_acc: 0.9156</span><br><span class="line">Epoch 42&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 450ms&#x2F;step - loss: 0.2804 - acc: 0.8971 - val_loss: 0.2466 - val_acc: 0.9115</span><br><span class="line">Epoch 43&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 436ms&#x2F;step - loss: 0.2756 - acc: 0.8978 - val_loss: 0.2548 - val_acc: 0.9177</span><br><span class="line">Epoch 44&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 445ms&#x2F;step - loss: 0.2730 - acc: 0.9010 - val_loss: 0.2562 - val_acc: 0.9239</span><br><span class="line">Epoch 45&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 443ms&#x2F;step - loss: 0.2724 - acc: 0.9017 - val_loss: 0.2561 - val_acc: 0.9259</span><br><span class="line">Epoch 46&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 455ms&#x2F;step - loss: 0.2871 - acc: 0.8906 - val_loss: 0.2700 - val_acc: 0.9239</span><br><span class="line">Epoch 47&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 456ms&#x2F;step - loss: 0.2734 - acc: 0.9017 - val_loss: 0.2244 - val_acc: 0.9259</span><br><span class="line">Epoch 48&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 453ms&#x2F;step - loss: 0.2570 - acc: 0.9062 - val_loss: 0.2566 - val_acc: 0.9156</span><br><span class="line">Epoch 49&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 22s 450ms&#x2F;step - loss: 0.2457 - acc: 0.9069 - val_loss: 0.2649 - val_acc: 0.9177</span><br><span class="line">Epoch 50&#x2F;50</span><br><span class="line">48&#x2F;48 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 21s 446ms&#x2F;step - loss: 0.2753 - acc: 0.8997 - val_loss: 0.2346 - val_acc: 0.9300</span><br><span class="line">[INFO] evaluating network...</span><br><span class="line">                precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">      football       0.92      0.95      0.93       196</span><br><span class="line">        tennis       0.92      0.91      0.92       179</span><br><span class="line">weight_lifting       0.94      0.91      0.92       143</span><br><span class="line"></span><br><span class="line">      accuracy                           0.92       518</span><br><span class="line">     macro avg       0.93      0.92      0.92       518</span><br><span class="line">  weighted avg       0.92      0.92      0.92       518</span><br><span class="line"></span><br><span class="line">[INFO] serializing network...</span><br></pre></td></tr></table></figure>
<h3 id="用滚动预测平均的方式应用模型到视频分类中"><a href="#用滚动预测平均的方式应用模型到视频分类中" class="headerlink" title="用滚动预测平均的方式应用模型到视频分类中"></a>用滚动预测平均的方式应用模型到视频分类中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># USAGE</span><br><span class="line"># python predict_video.py --model model&#x2F;activity.model --label-bin model&#x2F;lb.pickle --input example_clips&#x2F;lifting.mp4 --output output&#x2F;lifting_128avg.avi --size 128</span><br><span class="line"></span><br><span class="line"># import the necessary packages</span><br><span class="line">from keras.models import load_model</span><br><span class="line">from collections import deque #用来实现滑动平均</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line">import pickle</span><br><span class="line">import cv2</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line"># construct the argument parser and parse the arguments</span><br><span class="line">ap &#x3D; argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(&quot;-m&quot;, &quot;--model&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to trained serialized model&quot;)</span><br><span class="line">ap.add_argument(&quot;-l&quot;, &quot;--label-bin&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to  label binarizer&quot;)</span><br><span class="line">ap.add_argument(&quot;-i&quot;, &quot;--input&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to our input video&quot;)</span><br><span class="line">ap.add_argument(&quot;-o&quot;, &quot;--output&quot;, required&#x3D;True,</span><br><span class="line">	help&#x3D;&quot;path to our output video&quot;)</span><br><span class="line">ap.add_argument(&quot;-s&quot;, &quot;--size&quot;, type&#x3D;int, default&#x3D;128,</span><br><span class="line">	help&#x3D;&quot;size of queue for averaging&quot;)</span><br><span class="line">args &#x3D; vars(ap.parse_args())</span><br><span class="line"></span><br><span class="line"># load the trained model and label binarizer from disk</span><br><span class="line"># 从命令行的声明载入训练好的模型以及二值化</span><br><span class="line">print(&quot;[INFO] loading model and label binarizer...&quot;)</span><br><span class="line">model &#x3D; load_model(args[&quot;model&quot;])</span><br><span class="line">lb &#x3D; pickle.loads(open(args[&quot;label_bin&quot;], &quot;rb&quot;).read())</span><br><span class="line"></span><br><span class="line"># initialize the image mean for mean subtraction along with the</span><br><span class="line"># predictions queue</span><br><span class="line">mean &#x3D; np.array([123.68, 116.779, 103.939][::1], dtype&#x3D;&quot;float32&quot;)</span><br><span class="line"># 初始化Q为一个双向序列，deque的尺寸由size决定</span><br><span class="line">Q &#x3D; deque(maxlen&#x3D;args[&quot;size&quot;])</span><br><span class="line"></span><br><span class="line"># initialize the video stream, pointer to output video file, and</span><br><span class="line"># frame dimensions</span><br><span class="line"># 使用opencv的VideoCapture类读取视频流，并初始化视频写入类</span><br><span class="line">vs &#x3D; cv2.VideoCapture(args[&quot;input&quot;])</span><br><span class="line">writer &#x3D; None</span><br><span class="line">(W, H) &#x3D; (None, None)</span><br><span class="line"></span><br><span class="line"># loop over frames from the video file stream</span><br><span class="line"># 循环抓取被测试视频的帧</span><br><span class="line">while True:</span><br><span class="line">	# read the next frame from the file</span><br><span class="line">	(grabbed, frame) &#x3D; vs.read()</span><br><span class="line"></span><br><span class="line">	# if the frame was not grabbed, then we have reached the end</span><br><span class="line">	# of the stream</span><br><span class="line">	# 如果没有抓取到视频帧，则退出</span><br><span class="line">	if not grabbed:</span><br><span class="line">		break</span><br><span class="line"></span><br><span class="line">	# if the frame dimensions are empty, grab them</span><br><span class="line">	if W is None or H is None:</span><br><span class="line">		(H, W) &#x3D; frame.shape[:2]</span><br><span class="line"></span><br><span class="line">	# clone the output frame, then convert it from BGR to RGB</span><br><span class="line">	# ordering, resize the frame to a fixed 224x224, and then</span><br><span class="line">	# perform mean subtraction 归一化操作</span><br><span class="line">	output &#x3D; frame.copy()</span><br><span class="line">	frame &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)</span><br><span class="line">	frame &#x3D; cv2.resize(frame, (224, 224)).astype(&quot;float32&quot;) #改变图像宽和高，像素转移到特定数据类型</span><br><span class="line">	frame -&#x3D; mean</span><br><span class="line"></span><br><span class="line">	# make predictions on the frame and then update the predictions</span><br><span class="line">	# queue</span><br><span class="line">	# 新建一维用来储存每一帧对应的分类结果</span><br><span class="line">	preds &#x3D; model.predict(np.expand_dims(frame, axis&#x3D;0))[0]</span><br><span class="line">	# 将预测值加载Q后面</span><br><span class="line">	Q.append(preds)</span><br><span class="line"></span><br><span class="line">	# perform prediction averaging over the current history of</span><br><span class="line">	# previous predictions</span><br><span class="line">	# 先平均到K个概率输出值，在取最大</span><br><span class="line">	results &#x3D; np.array(Q).mean(axis&#x3D;0)</span><br><span class="line">	i &#x3D; np.argmax(results)</span><br><span class="line">	label &#x3D; lb.classes_[i]</span><br><span class="line"></span><br><span class="line">	# draw the activity on the output frame</span><br><span class="line">	text &#x3D; &quot;activity: &#123;&#125;&quot;.format(label)</span><br><span class="line">	cv2.putText(output, text, (35, 50), cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">		1.25, (0, 255, 0), 5)</span><br><span class="line"></span><br><span class="line">	# check if the video writer is None</span><br><span class="line">	if writer is None:</span><br><span class="line">		# initialize our video writer</span><br><span class="line">		fourcc &#x3D; cv2.VideoWriter_fourcc(*&quot;MJPG&quot;)</span><br><span class="line">		writer &#x3D; cv2.VideoWriter(args[&quot;output&quot;], fourcc, 30,</span><br><span class="line">			(W, H), True)</span><br><span class="line"></span><br><span class="line">	# write the output frame to disk</span><br><span class="line">	writer.write(output)</span><br><span class="line"></span><br><span class="line">	# show the output image</span><br><span class="line">	# 避免cannot connect to X server，此处使用matplotlib</span><br><span class="line">	# cv2.imshow(&quot;Output&quot;, output)</span><br><span class="line">  plt.imshow(output)</span><br><span class="line">	key &#x3D; cv2.waitKey(1) &amp; 0xFF</span><br><span class="line"></span><br><span class="line">	# if the &#96;q&#96; key was pressed, break from the loop</span><br><span class="line">	if key &#x3D;&#x3D; ord(&quot;q&quot;):</span><br><span class="line">		break</span><br><span class="line"></span><br><span class="line"># release the file pointers</span><br><span class="line">print(&quot;[INFO] cleaning up...&quot;)</span><br><span class="line">writer.release()</span><br><span class="line">vs.release()</span><br><span class="line">!sudo apt-get install tree</span><br><span class="line">!tree --dirsfirst --filelimit 50</span><br><span class="line">.</span><br><span class="line">├── data</span><br><span class="line">│   ├── badminton [938 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── baseball [746 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── basketball [495 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── boxing [705 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── chess [481 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── cricket [715 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── fencing [635 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── football [799 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── formula1 [687 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── gymnastics [719 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── hockey [572 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── ice_hockey [715 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── kabaddi [454 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── models</span><br><span class="line">│   │   ├── res50-stage-1.pth</span><br><span class="line">│   │   ├── res50-stage-2.pth</span><br><span class="line">│   │   ├── res50-stage-3.pth</span><br><span class="line">│   │   ├── stage-1.pth</span><br><span class="line">│   │   ├── tmp.pth</span><br><span class="line">│   │   └── unfreeze-stage-1.pth</span><br><span class="line">│   ├── motogp [679 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── shooting [536 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── swimming [689 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── table_tennis [713 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── tennis [718 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── volleyball [713 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── weight_lifting [577 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── wrestling [611 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── wwe [671 entries exceeds filelimit, not opening dir]</span><br><span class="line">│   ├── badminton_urls.txt</span><br><span class="line">│   ├── baseball_urls.txt</span><br><span class="line">│   ├── basketball_urls.txt</span><br><span class="line">│   ├── boxing_urls.txt</span><br><span class="line">│   ├── chess_urls.txt</span><br><span class="line">│   ├── cleaned.csv</span><br><span class="line">│   ├── cricket_urls.txt</span><br><span class="line">│   ├── export.pkl</span><br><span class="line">│   ├── fencing_urls.txt</span><br><span class="line">│   ├── football_urls.txt</span><br><span class="line">│   ├── formula1_urls.txt</span><br><span class="line">│   ├── gymnastics_urls.txt</span><br><span class="line">│   ├── hockey_urls.txt</span><br><span class="line">│   ├── ice_hockey_urls.txt</span><br><span class="line">│   ├── kabaddi_urls.txt</span><br><span class="line">│   ├── motogp_urls.txt</span><br><span class="line">│   ├── shooting_urls.txt</span><br><span class="line">│   ├── swimming_urls.txt</span><br><span class="line">│   ├── table_tennis_urls.txt</span><br><span class="line">│   ├── tennis_urls.txt</span><br><span class="line">│   ├── volleyball_urls.txt</span><br><span class="line">│   ├── weight_lifting_urls.txt</span><br><span class="line">│   ├── wrestling_urls.txt</span><br><span class="line">│   └── wwe_urls.txt</span><br><span class="line">├── example_clips</span><br><span class="line">│   ├── lifting.mp4</span><br><span class="line">│   ├── soccer.mp4</span><br><span class="line">│   └── tennis.mp4</span><br><span class="line">├── model</span><br><span class="line">├── output</span><br><span class="line">│   ├── activity.model</span><br><span class="line">│   ├── lb.pickle</span><br><span class="line">│   ├── tennis_128frames_smoothened.avi</span><br><span class="line">│   ├── tennis_128frames_smoothened (convert-video-online.com).mp4</span><br><span class="line">│   └── tennis_1frame.avi</span><br><span class="line">├── Sports-Type-Classifier</span><br><span class="line">│   ├── readme_images</span><br><span class="line">│   │   ├── acc_sports.png</span><br><span class="line">│   │   ├── cric.png</span><br><span class="line">│   │   ├── heat_cric.png</span><br><span class="line">│   │   ├── si_sports.png</span><br><span class="line">│   │   ├── sports_confusion_matrix.png</span><br><span class="line">│   │   ├── sports_data_aug.png</span><br><span class="line">│   │   └── sports.png</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── sports_classifier.ipynb</span><br><span class="line">├── plot.png</span><br><span class="line">├── predict_video.py</span><br><span class="line">├── sports_classifier.ipynb</span><br><span class="line">├── sports-type-classifier-data.7z</span><br><span class="line">├── sports-type-classifier-data.zip</span><br><span class="line">└── train.py</span><br><span class="line"></span><br><span class="line">29 directories, 53 files</span><br><span class="line">!python predict_video.py --model output&#x2F;activity.model \</span><br><span class="line">	--label-bin output&#x2F;lb.pickle \</span><br><span class="line">	--input example_clips&#x2F;lifting.mp4 \</span><br><span class="line">	--output output&#x2F;lifting_128frame.avi \</span><br><span class="line">	--size 128</span><br><span class="line">!python predict_video.py --model output&#x2F;activity.model \</span><br><span class="line">	--label-bin output&#x2F;lb.pickle \</span><br><span class="line">	--input example_clips&#x2F;tennis.mp4 \</span><br><span class="line">	--output output&#x2F;tennis_128frames_smoothened.avi \</span><br><span class="line">	--size 128</span><br></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://www.pyimagesearch.com/2019/07/15/video-classification-with-keras-and-deep-learning/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2019/07/15/video-classification-with-keras-and-deep-learning/</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>计算机视觉：算法与应用 笔记</title>
    <url>/2020/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%9A%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="计算机视觉：算法与应用-笔记"><a href="#计算机视觉：算法与应用-笔记" class="headerlink" title="计算机视觉：算法与应用 笔记"></a>计算机视觉：算法与应用 笔记</h1><h1 id="1-图像形成"><a href="#1-图像形成" class="headerlink" title="1 图像形成"></a>1 图像形成</h1><h2 id="1-1-1-几何基元与变换"><a href="#1-1-1-几何基元与变换" class="headerlink" title="1.1.1 几何基元与变换"></a>1.1.1 几何基元与变换</h2><p><code>几何基元</code>：2D点、2D直线、2D圆锥曲线、3D点、3D平面、3D直线、3D二次曲面</p>
<p><code>齐次坐标（投影坐标）</code>：用于投影几何里的坐标系统，给定欧氏平面上的一点 (<em>x</em>, <em>y</em>)，对任意非零实数 Z，三元组 (<em>xZ</em>, <em>yZ</em>, <em>Z</em>) 即称之为该点的齐次坐标</p>
<p><code>笛卡尔坐标与齐次坐标的关系</code>：</p>
<ul>
<li>投影平面上的任何点都可以表示成一三元组 (<em>X</em>, <em>Y</em>, <em>Z</em>)，称之为该点的<strong>齐次坐标</strong>或<strong>投影坐标</strong>，其中 X、Y 及 Z 不全为 0</li>
<li>当 Z 为 0，则该点表示一无穷远点</li>
<li>三元组 (0, 0, 0) 不表示任何点。原点表示为 (0, 0, 1)</li>
</ul>
<h2 id="1-1-2-2D变换"><a href="#1-1-2-2D变换" class="headerlink" title="1.1.2 2D变换"></a>1.1.2 2D变换</h2><p>平移、刚体运动（旋转+平移）、相似（放缩旋转）、仿射、投影（透视变换）、拉伸/挤压、平面状表面流（经历小的3D运动时）、双线性内插（任意非共线的四点运动的内插）</p>
<h2 id="1-1-2-3D变换"><a href="#1-1-2-3D变换" class="headerlink" title="1.1.2 3D变换"></a>1.1.2 3D变换</h2><h2 id="4-特征检测与匹配"><a href="#4-特征检测与匹配" class="headerlink" title="4 特征检测与匹配"></a>4 特征检测与匹配</h2><h3 id="4-3-线条"><a href="#4-3-线条" class="headerlink" title="4.3 线条"></a>4.3 线条</h3>]]></content>
  </entry>
  <entry>
    <title>迁移学习</title>
    <url>/2020/07/24/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><p><strong>大量资源训练的模型</strong>经过细微调整后解决同一类问题，解决原始数据较少的问题，可节省大量时间和算力，因为分类对象变化，需要重新训练</p>
<p>若出现负迁移:模型的泛化能力恶化，解决两个毫不相关的问题</p>
]]></content>
  </entry>
  <entry>
    <title>问题</title>
    <url>/2020/07/24/%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>问题：</p>
<ol>
<li><pre><code>frame = cv2.resize(frame, (224, 224)).astype(&quot;float32&quot;)
</code></pre></li>
<li><p>数据预处理是用sklearn比较好还是自带的</p>
</li>
<li><p>动作识别和人体姿态估计（只是识别出骨骼关键点）有关系吗</p>
</li>
<li><p>光流法能用在动作识别上吗</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/2020/07/24/%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><h4 id="2019-2-16"><a href="#2019-2-16" class="headerlink" title="2019.2.16"></a>2019.2.16</h4><p>有的时候其实要及时行乐，不去想那些没有发生的事情，豁达一点，其实事情并没有想象的那么重要，那么糟糕，但是当人们真正面对的时候，往往头脑冲动，自甘堕落，一直活在对过去的内疚和对未来的恐惧中，这其实是很可悲的。</p>
<h4 id="2019-2-19"><a href="#2019-2-19" class="headerlink" title="2019.2.19"></a>2019.2.19</h4><p>有的时候多希望梦境是真的，因为在梦里人可以无所畏惧，有的时候如果入梦太深，尽管处于半睡半醒的状态，但还是不愿醒来，不情愿的醒来之后，会感到很失落，就像看一部电影，看到落幕，却发现主角并不是自己一样。</p>
<h4 id="2019-2-23"><a href="#2019-2-23" class="headerlink" title="2019.2.23"></a>2019.2.23</h4><p>记得哪里曾经说过，当一个人开始回忆过去时便开始衰老了，我想大多数人都想象不到自己会变成什么样的人或许丑陋，或许高尚，回忆过去的原因可能是因为那种心灵的疲惫让自己羡慕心底对未来的向往吧</p>
<h4 id="2019-2-24"><a href="#2019-2-24" class="headerlink" title="2019.2.24"></a>2019.2.24</h4><p>家庭环境是对一个人的性格影响最大的，就拿家境不是很好的我来说，总是不够自信，太过自卑，把有些事情看的太重，或者说太敏感，其实有时候自信一点，放开一点，结果会更好，加油吧，少年！</p>
<h4 id="2019-11-04于天马公寓"><a href="#2019-11-04于天马公寓" class="headerlink" title="2019.11.04于天马公寓"></a>2019.11.04于天马公寓</h4><p>这短短的一生我们最终都会失去，不妨大胆一点，爱一个人，攀一座山，追一个梦。说的多好呀，但是有多少人能够大胆起来</p>
]]></content>
  </entry>
  <entry>
    <title>驾驶员动作检测综述</title>
    <url>/2020/07/24/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="驾驶员动作检测综述"><a href="#驾驶员动作检测综述" class="headerlink" title="驾驶员动作检测综述"></a>驾驶员动作检测综述</h1><p>闵晨阳 2020.02.01</p>
<h2 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h2><h3 id="多流融合的CNN"><a href="#多流融合的CNN" class="headerlink" title="多流融合的CNN"></a>多流融合的CNN</h3><p>原文见参考文献【1】</p>
<p><strong>datasets</strong></p>
<p>SEU-DRIVING dataset，state-farm distracted driving dataset</p>
<p><strong>Network architecture</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/1.PNG" alt="img"></p>
<p><strong>Fusion strategy</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/2.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/3.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/4.PNG" alt="img"></p>
<p><strong>Experiment results</strong></p>
<p><strong>state farm</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/5.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/6.PNG" alt="img"></p>
<p>SEU</p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/7.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/8.PNG" alt="img"></p>
<h3 id="多尺度注意机制CNN"><a href="#多尺度注意机制CNN" class="headerlink" title="多尺度注意机制CNN"></a>多尺度注意机制CNN</h3><p>原文见参考文献【2】</p>
<p><strong>datasets</strong></p>
<p>State-Farm,S-DA,R-DA</p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/32.PNG" alt="img"></p>
<p><strong>Network architecture</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/10.PNG" alt="img"></p>
<p><strong>Experiment results</strong></p>
<p><strong>state farm</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/14.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/13.PNG" alt="img"></p>
<p><strong>R-DA</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/11.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/12.PNG" alt="img"></p>
<p><strong>S-DA</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/16.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/15.PNG" alt="img"></p>
<h3 id="融合手脸特征的CNN"><a href="#融合手脸特征的CNN" class="headerlink" title="融合手脸特征的CNN"></a>融合手脸特征的CNN</h3><p>原文见参考文献【5】</p>
<p><strong>datasets</strong></p>
<p>AUC([5]首创)</p>
<p><strong>Network architecture</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/23.PNG" alt="img"></p>
<p><strong>Experiment results</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/24.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/25.PNG" alt="img"></p>
<h2 id="视频分类"><a href="#视频分类" class="headerlink" title="视频分类"></a>视频分类</h2><h3 id="Two-Stream-Inflated-3D-ConvNet-I3D"><a href="#Two-Stream-Inflated-3D-ConvNet-I3D" class="headerlink" title="Two-Stream Inflated 3D ConvNet(I3D)"></a>Two-Stream Inflated 3D ConvNet(I3D)</h3><p>原文见参考文献【3】【4】</p>
<p><strong>datasets</strong></p>
<p>AUC,State Farm</p>
<p>经过对以上两个数据集的每一帧图片的组合得到20,094 10-frame clips for State<br>Farm and 14,536 10-frame clips for AUC dataset</p>
<p><strong>Network architecture</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/17.PNG" alt="img"></p>
<p><strong>Experiment results</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/18.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/20.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/19.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/21.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/22.PNG" alt="img"></p>
<h3 id="基于空间-时间特征的CNN"><a href="#基于空间-时间特征的CNN" class="headerlink" title="基于空间-时间特征的CNN"></a>基于空间-时间特征的CNN</h3><p>原文见参考文献【6】</p>
<p><strong>datasets</strong></p>
<p>AUC ,Brain4Cars</p>
<p><strong>Network architecture</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/26.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/27.PNG" alt="img"></p>
<p><strong>数据融合</strong>：通过每一帧图片后增加几帧光流来联系“连续几帧图片”</p>
<p>融合后的四帧数据输入带有Softmax层(批量归一化层）的inception网络，每一帧结果融合后经过softmax层输出预测结果</p>
<p><strong>Experiment results</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/28.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/29.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/30.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/31.PNG" alt="img"></p>
<h3 id="多类型细粒度Drive-amp-Act数据集"><a href="#多类型细粒度Drive-amp-Act数据集" class="headerlink" title="多类型细粒度Drive&amp;Act数据集"></a>多类型细粒度Drive&amp;Act数据集</h3><p>原文见参考文献【7】</p>
<p><strong>datasets</strong></p>
<p><a href="https://www.driveandact.com/" target="_blank" rel="noopener">https://www.driveandact.com/</a></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/33.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/34.PNG" alt="img"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/35.PNG" alt="35"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/36.PNG" alt="36"></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/37.PNG" alt="37"></p>
<p><strong>Experiment results</strong></p>
<p><strong>Mid-Level</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/38.PNG" alt="img"></p>
<p><strong>Action-Object-Location</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/39.PNG" alt="39"></p>
<p><strong>Long-running Task</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/40.PNG" alt="40"></p>
<p><strong>多类型数据融合的结果</strong></p>
<p><img src="https://perfectism13.github.io/2020/02/01/%E9%A9%BE%E9%A9%B6%E5%91%98%E5%8A%A8%E4%BD%9C%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/41.PNG" alt="41"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>【1】Hu Y, Lu M, Lu X, et al. Driving behaviour recognition from still images by using multi-stream fusion CNN[J]. machine vision applications, 2019, 30(5): 851-865.</p>
<p>【2】Hu Y, Lu M, Lu X, et al. Feature refinement for image-based driver action recognition via multi-scale attention convolutional neural network[J]. Signal Processing-image Communication, 2020.</p>
<p>【3】Moslemi N, Azmi R, Soryani M, et al. Driver Distraction Recognition using 3D Convolutional Neural Networks[C]. international conference on pattern recognition, 2019.</p>
<p>【4】 J. Carreira and A. Zisserman, “Quo Vadis, Action Recognition? A New Model and the Kinetics Dataset,” in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2017.</p>
<p>【5】Abouelnaga Y, Eraqi H M, Moustafa M, et al. Real-time Distracted Driver Posture Classification.[J]. arXiv: Computer Vision and Pattern Recognition, 2017.</p>
<p>【6】Kose N, Kopuklu O, Unnervik A, et al. Real-Time Driver State Monitoring Using a CNN Based Spatio-Temporal Approach*[C]. international conference on intelligent transportation systems, 2019.</p>
<p>【7】Martin M, Roitberg A, Haurilet M, et al. Drive&amp;Act: A Multi-Modal Dataset for Fine-Grained Driver Behavior Recognition in Autonomous Vehicles[C]. international conference on computer vision, 2019: 2801-2810.</p>
]]></content>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/2020/07/24/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><p>闵晨阳</p>
<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​    Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="assets/1541383178746.png" alt="1541383178746"></p>
<p><img src="assets/1541384366413.png" alt="1541384366413"></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img src="assets/1541383817248.png" alt="1541383817248"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img src="assets/1541384140042.png" alt="1541384140042"></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img src="assets/1541384818688.png" alt="1541384818688"></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，==对该段代码做整体说明==</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code><ul>
<li>==通常在文件上方定义==，表示一个常量</li>
</ul>
</li>
</ol>
<ol>
<li><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code><ul>
<li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"一周里总共有 "</span> &lt;&lt; day &lt;&lt; <span class="string">" 天"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> month = <span class="number">12</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"一年里总共有 "</span> &lt;&lt; month &lt;&lt; <span class="string">" 个月份"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
</tr>
</tbody>
</table>
</div>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"short 类型所占内存空间为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"int 类型所占内存空间为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"long 类型所占内存空间为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"long long 类型所占内存空间为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= long long==</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于==表示小数==</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d1&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"float  sizeof = "</span> &lt;&lt; <span class="keyword">sizeof</span>(f1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"double sizeof = "</span> &lt;&lt; <span class="keyword">sizeof</span>(d1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="keyword">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"f2 = "</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"f3 = "</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用==1个字节==。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = "abcde"; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = 'abcde'; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASCII码表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
</div>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p>
<p>现阶段我们常用的转义字符有：<code>\n  \\  \t</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td><strong>\\</strong></td>
<td><strong>代表一个反斜线字符”\”</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>\’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>\”</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0~9，a~f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\\"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tHello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">"hello world"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include\<string>==</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  —- 真（本质是1）</li>
<li>false —- 假（本质是0）</li>
</ul>
<p><strong>bool类型占==1个字节==大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of bool = "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入整型变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入浮点型变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入字符型变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入字符串型变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入布尔型变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p>
<p>算术运算符包括以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>—</td>
<td>前置递减</td>
<td>a=2; b=—a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>—</td>
<td>后置递减</td>
<td>a=2; b=a—;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a1 + b1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a1 - b1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a1 * b1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a1 / b1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a2 / b2 &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="keyword">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d1 / d2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a2 % b2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>></td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>>=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a == b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a != b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &gt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &lt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== </p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>或</td>
<td>a \</td>
<td>\</td>
<td>b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; !a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; !!a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a || b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑==或==运算符总结： ==同假为假，其余为真==</p>
</blockquote>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p>
</li>
<li><p>多行格式if语句</p>
</li>
<li><p>多条件的if语句</p>
</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件){ 条件满足执行的语句 }</code></p>
<p><img src="assets/clip_image002.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"您输入的分数为： "</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学！！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol>
<li>多行格式if语句：<code>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</code></li>
</ol>
<p><img src="assets/clip_image002-1541662519170.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我未考上一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>多条件的if语句：<code>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}</code></li>
</ol>
<p><img src="assets/clip_image002-1541662566808.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了北大"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了清华"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了人大"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请给电影打分"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"经典"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"非常好"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"一般"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"烂片"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code>while(循环条件){ 循环语句 }</code></p>
<p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p>
<p><img src="assets/clip_image002-1541668640382.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循</p>
</blockquote>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do{ 循环语句 } while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件</p>
<p><img src="assets/clip_image002-1541671163478.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<p><img src="assets/1541673704101.png" alt="1541673704101"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="assets/1541676003486.png" alt="1541676003486"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择您挑战副本的难度："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"1、普通"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"2、中等"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"3、困难"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"您选择的是普通难度"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"您选择的是中等难度"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"您选择的是困难难度"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p>
<p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};</code></li>
<li><code>数据类型  数组名[ ] = { 值1，值2 ...};</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="keyword">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; score[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; score[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; score[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="keyword">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; score2[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="keyword">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; score3[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"整个数组所占内存空间为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"每个元素所占内存空间为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"数组的元素个数为： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"数组首地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"数组中第一个元素地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"数组中第二个元素地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img src="assets/1541905327273.png" alt="1541905327273"></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
<li><code>数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="keyword">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="keyword">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组大小： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组一行大小： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组元素大小： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组行数： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组列数： "</span> &lt;&lt; <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组首地址："</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组第一行地址："</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组第二行地址："</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组第一个元素地址："</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"二维数组第二个元素地址："</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody>
</table>
</div>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> names[<span class="number">3</span>] = &#123; <span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; names[i] &lt;&lt; <span class="string">"同学总成绩为： "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型 </p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句 </p>
<p>5、return 表达式</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code>函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="keyword">int</span> sum = add(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = add(a, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，==如果形参发生，并不会影响实参==</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"num2 = "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"num2 = "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	swap(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mian中的 a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mian中的 b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is test01"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is test02"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is test03 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test04</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is test04 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">	swap(a, b);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li>内存编号是从0开始记录的，一般用十六进制数字表示</li>
<li>可以利用指针变量保存地址</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p = "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
<p>总结2：利用指针可以记录地址</p>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//* 解引用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="keyword">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   —- 常量指针</li>
<li>const修饰常量   —- 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个元素： "</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"指针访问第一个元素： "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> * p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	swap1(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	swap2(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	bubbleSort(arr, len);</span><br><span class="line"></span><br><span class="line">	printArray(arr, len);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 { 结构体成员列表 }；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span> <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">"张三"</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu1.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span> = &#123;</span> <span class="string">"李四"</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu2.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">"王五"</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu3.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code>struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">arr</span>[3]=</span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		&#123;<span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">"李四"</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">"王五"</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; arr[i].score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> = &#123;</span> <span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> * <span class="title">p</span> = &amp;<span class="title">stu</span>;</span></span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; p-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span> <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">t1</span>;</span></span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">"老王"</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">"张三"</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"教师 职工编号： "</span> &lt;&lt; t1.id &lt;&lt; <span class="string">" 姓名： "</span> &lt;&lt; t1.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; t1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"辅导学员 姓名： "</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">" 考试分数： "</span> &lt;&lt; t1.stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"子函数中 姓名："</span> &lt;&lt; stu.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"子函数中 姓名："</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	printStudent(stu);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主函数中 姓名："</span> &lt;&lt; stu.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu.age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	printStudent2(&amp;stu);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主函数中 姓名："</span> &lt;&lt; stu.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	<span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="keyword">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	printStudent(&amp;stu);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> tName = <span class="string">"教师"</span>;</span><br><span class="line">	<span class="built_in">string</span> sName = <span class="string">"学生"</span>;</span><br><span class="line">	<span class="built_in">string</span> nameSeed = <span class="string">"ABCDE"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = rand() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tArray[i].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"\t姓名："</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(tArray) / <span class="keyword">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line">	allocateSpace(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	printTeachers(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"刘备"</span>,<span class="number">23</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"关羽"</span>,<span class="number">22</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"张飞"</span>,<span class="number">20</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"赵云"</span>,<span class="number">21</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"貂蝉"</span>,<span class="number">19</span>,<span class="string">"女"</span>&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">string</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">" 性别： "</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; arr[i].age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hero</span> <span class="title">arr</span>[5] =</span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		&#123;<span class="string">"刘备"</span>,<span class="number">23</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"关羽"</span>,<span class="number">22</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"张飞"</span>,<span class="number">20</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"赵云"</span>,<span class="number">21</span>,<span class="string">"男"</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"貂蝉"</span>,<span class="number">19</span>,<span class="string">"女"</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	bubbleSort(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	printHeros(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-内存分区模型"><a href="#9-内存分区模型" class="headerlink" title="9 内存分区模型"></a>9 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p>ps：前两个在程序运行前划分，后两个程序运行时生成</p>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="9-1-程序运行前"><a href="#9-1-程序运行前" class="headerlink" title="9.1 程序运行前"></a>9.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​    <strong>代码区：</strong></p>
<p>​        存放 CPU 执行的机器指令</p>
<p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​    <strong>全局区：</strong></p>
<p>​        全局变量和静态变量存放在此.</p>
<p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​        ==该区域的数据在程序结束后由操作系统释放==.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"局部变量a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"局部变量b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"全局变量g_a地址为： "</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"全局变量g_b地址为： "</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"静态变量s_a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"静态变量s_b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串常量地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串常量地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">"hello world1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"全局常量c_g_a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"全局常量c_g_b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"局部常量c_l_a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"局部常量c_l_b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src="E:/jianguo_sync/Dropbox/我的坚果云/OneDrive - hnu.edu.cn/学习资料/C++/Cpp-0-1-Resource-master/Cpp-0-1-Resource-master/第3阶段-C++核心编程 资料/讲义/assets/1545017602518.png" alt="1545017602518"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="9-2-程序运行后"><a href="#9-2-程序运行后" class="headerlink" title="9.2 程序运行后"></a>9.2 程序运行后</h3><p>​    <strong>栈区：</strong></p>
<p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等，形参也放在栈区</p>
<p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>堆区：</strong></p>
<p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​        在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="9-3-new操作符"><a href="#9-3-new操作符" class="headerlink" title="9.3 new操作符"></a>9.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p>
<p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>
<p>​    语法：<code>new 数据类型</code></p>
<p>​    利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = func();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-引用"><a href="#10-引用" class="headerlink" title="10 引用"></a>10 引用</h2><h3 id="10-1-引用的基本使用"><a href="#10-1-引用的基本使用" class="headerlink" title="10.1 引用的基本使用"></a>10.1 引用的基本使用</h3><p><strong>作用： </strong>给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-引用注意事项"><a href="#10-2-引用注意事项" class="headerlink" title="10.2 引用注意事项"></a>10.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="keyword">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-引用做函数参数"><a href="#10-3-引用做函数参数" class="headerlink" title="10.3 引用做函数参数"></a>10.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	mySwap01(a, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	mySwap02(&amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	mySwap03(a, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="10-4-引用做函数返回值"><a href="#10-4-引用做函数返回值" class="headerlink" title="10.4 引用做函数返回值"></a>10.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = test01();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref2 = test02();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	test02() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-5-引用的本质"><a href="#10-5-引用的本质" class="headerlink" title="10.5 引用的本质"></a>10.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref:"</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">	func(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="10-6-常量引用"><a href="#10-6-常量引用" class="headerlink" title="10.6 常量引用"></a>10.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	showValue(a);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-函数提高"><a href="#11-函数提高" class="headerlink" title="11 函数提高"></a>11 函数提高</h2><h3 id="11-1-函数默认参数"><a href="#11-1-函数默认参数" class="headerlink" title="11.1 函数默认参数"></a>11.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code>返回值类型  函数名 （参数= 默认值）{}</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; func(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; func(<span class="number">100</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-函数占位参数"><a href="#11-2-函数占位参数" class="headerlink" title="11.2 函数占位参数"></a>11.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型){}</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	func(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-函数重载"><a href="#11-3-函数重载" class="headerlink" title="11.3 函数重载"></a>11.3 函数重载</h3><h4 id="11-3-1-函数重载概述"><a href="#11-3-1-函数重载概述" class="headerlink" title="11.3.1 函数重载概述"></a>11.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func 的调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func (int a) 的调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func (double a)的调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func (int a ,double b) 的调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func (double a ,int b)的调用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; "func (double a ,int b)的调用！" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	func();</span><br><span class="line">	func(<span class="number">10</span>);</span><br><span class="line">	func(<span class="number">3.14</span>);</span><br><span class="line">	func(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	func(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-2-函数重载注意事项"><a href="#11-3-2-函数重载注意事项" class="headerlink" title="11.3.2 函数重载注意事项"></a>11.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func (int &amp;a) 调用 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func (const int &amp;a) 调用 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2(int a, int b = 10) 调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2(int a) 调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	func(a); <span class="comment">//调用无const</span></span><br><span class="line">	func(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
