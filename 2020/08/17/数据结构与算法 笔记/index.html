<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"perfectism13.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据结构与算法 笔记基本概念一、数据结构1. 其他定义 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》 数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》 数据结构（data">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法 笔记">
<meta property="og:url" content="https://perfectism13.github.io/2020/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="perfectism&#39;s blog">
<meta property="og:description" content="数据结构与算法 笔记基本概念一、数据结构1. 其他定义 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》 数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》 数据结构（data">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026114834352.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026114856464.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026114920772.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026114938359.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026114956314.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026115013432.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026115028605.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026115044316.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026115118948.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026115134161.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181026114920772.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181030202740803.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2018103020280133.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2018103020284288.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181030202857229.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181101090543537.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181101090730163.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181101090806846.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181101090819459.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102110417706.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102110800268.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102113105538.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102112405164.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102114124904.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102112415831.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102115543530.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102112435166.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181102115827971.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181104104440648.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181104104459868.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181104104516209.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181104104530440.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181105100214250.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181107200837443.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181113150234459.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2018111315021063.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181118171739821.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181118171601539.gif">
<meta property="article:published_time" content="2020-08-16T16:00:00.000Z">
<meta property="article:modified_time" content="2020-08-26T02:01:05.590Z">
<meta property="article:author" content="Chenyang Min">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20181026114834352.jpg">

<link rel="canonical" href="https://perfectism13.github.io/2020/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%20%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法 笔记 | perfectism's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">perfectism's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">物来顺应，未来不迎，当时不杂，既往不恋</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/perfectism13" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://perfectism13.github.io/2020/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenyang Min">
      <meta itemprop="description" content="Computer Vision, Deep Learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="perfectism's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-17T00:00:00+08:00">2020-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-26 10:01:05" itemprop="dateModified" datetime="2020-08-26T10:01:05+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构与算法-笔记"><a href="#数据结构与算法-笔记" class="headerlink" title="数据结构与算法 笔记"></a>数据结构与算法 笔记</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><h4 id="1-其他定义"><a href="#1-其他定义" class="headerlink" title="1. 其他定义"></a>1. 其他定义</h4><ul>
<li>数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。 ——Sartaj Sahni 《数据结构、算法与应用》</li>
<li>数据结构是 ADT（Abstract Data Type，数据抽象类型）的物理实现。 ——Clifford A.Shaffer 《数据结构与算法分析》</li>
<li>数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 ——中文维基百科</li>
</ul>
<h4 id="2-解决问题方法的效率"><a href="#2-解决问题方法的效率" class="headerlink" title="2. 解决问题方法的效率"></a>2. 解决问题方法的效率</h4><ul>
<li>跟数组的组织方式有关</li>
<li>跟空间的利用效率有关</li>
<li>跟算法的巧妙程度有关</li>
</ul>
<h4 id="3-最终定义"><a href="#3-最终定义" class="headerlink" title="3. 最终定义"></a>3. 最终定义</h4><ul>
<li>数据对象在计算机中的组织方式<ul>
<li>逻辑结构</li>
<li>物理存储结构</li>
</ul>
</li>
<li>数据对象必定与一系列加在其上的操作相关联</li>
<li>完成这些操作所用的方法就是算法</li>
</ul>
<h4 id="4-抽象数据类型（Abstract-Data-Type）"><a href="#4-抽象数据类型（Abstract-Data-Type）" class="headerlink" title="4. 抽象数据类型（Abstract Data Type）"></a>4. 抽象数据类型（Abstract Data Type）</h4><ul>
<li>数据类型<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
</li>
<li>抽象：描述数据类型的方法不依赖于具体实现<ul>
<li>与存放数据的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言均无关</li>
</ul>
</li>
</ul>
<p>只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题</p>
<a id="more"></a>
<h3 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul>
<li>一个有限指令集</li>
<li>≥ 0 的输入</li>
<li>==&gt;==0 的输出</li>
<li>一定在有限步骤之后终止</li>
<li>每一条指令必须<ul>
<li>有充分明确的目标，不可以有歧义</li>
<li>计算机能处理范围内</li>
<li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li>
</ul>
</li>
</ul>
<h4 id="2-描述算法的手段"><a href="#2-描述算法的手段" class="headerlink" title="2. 描述算法的手段"></a>2. 描述算法的手段</h4><ol>
<li><p>空间复杂度 S(n)</p>
<p>根据算法写成的程序在执行时<strong>占用存储空间的长度</strong></p>
</li>
<li><p>时间复杂度 T(n)</p>
<p>根据算法写成的程序在执行时<strong>耗费的时间的长度</strong></p>
</li>
</ol>
<h4 id="3-评价"><a href="#3-评价" class="headerlink" title="3. 评价"></a>3. 评价</h4><ul>
<li><p>在分析一般算法的效率时，常常关注</p>
<ul>
<li>最坏情况复杂度$T_{\text {worst}}(n)$</li>
<li>平均情况复杂度 $T_{\text {avg}}(n)$</li>
<li>$T_{\text {avg}}(n) \leq T_{\text {worst}}(n)$</li>
</ul>
<p>一般情况下更多关注的是最坏情况复杂度</p>
</li>
</ul>
<h4 id="4-复杂度的渐进表示法"><a href="#4-复杂度的渐进表示法" class="headerlink" title="4. 复杂度的渐进表示法"></a>4. 复杂度的渐进表示法</h4><ul>
<li>$T(n)=O(f(n))$ 表示存在常数 $\mathrm{C}&gt;0, n_{0}&gt;0,$ 使得当 $n \geq n_{0}$ 时有 $T(n) \leq$$C \cdot f(n),$ 即 $O(f(n))$ 表示 $f(n)$ 是 $\mathrm{T}(\mathrm{n})$ 的某种上界</li>
<li>$T(n)=\Omega(g(n))$ 表示存在常数 $\mathrm{C}&gt;0, n_{0}&gt;0,$ 使得当 $n \geq n_{0}$ 时有 $T(n) \geq$$C \cdot g(n),$ 即 $\Omega(g(n))$ 表示 $g(n)$ 是 $\mathrm{T}(\mathrm{n})$ 的某种下界</li>
<li>$T(n)=\theta(h(n))$ 表示同时有 $T(n)=O(h(n))$ 和 $T(n)=\Omega(h(n)),$ 即$\theta(h(n))$ 既是上界也是下界</li>
</ul>
<h4 id="5-复杂度分析小窍门"><a href="#5-复杂度分析小窍门" class="headerlink" title="5. 复杂度分析小窍门"></a>5. 复杂度分析小窍门</h4><ul>
<li><p>若两段算法分别有复杂度 $T_{1}(n)=O\left(f_{1}(n)\right)$ 和 $T_{2}(n)=O\left(f_{2}(n)\right),$ 则</p>
<script type="math/tex; mode=display">T_{1}(n)+T_{2}(n)=\max \left(O\left(f_{1}(n)\right), O\left(f_{2}(n)\right)\right)</script></li>
<li><script type="math/tex; mode=display">
T_{1}(n) \times T_{2}(n)=O\left(f_{1}(n) \times f_{2}(n)\right)</script></li>
<li><p>若 $T(n)$ 是关于 $n$ 的 $k$ 阶多项式, 那么 $T(n)=\theta\left(n^{k}\right)$</p>
</li>
<li><p>一个 for 循环的时间复杂度等于循环次数乘以循环体代码的复杂度</p>
</li>
<li><p>if-else 结构的复杂度取决于 if 的条件判断复杂度和两个分枝部分的复杂度，总体复杂 度取三者中最大</p>
</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1-什么是线性表"><a href="#1-什么是线性表" class="headerlink" title="1. 什么是线性表"></a>1. 什么是线性表</h3><p> “线性表”：由同类型数据元素构成有序序列的线性结构</p>
<ul>
<li>表中元素个数称为线性表的<strong>长度</strong></li>
<li>线性表没有元素时，称为<strong>空表</strong></li>
<li>表起始位置称为<strong>表头</strong>，表结束位置称<strong>表尾</strong></li>
</ul>
<h3 id="2-线性表的抽象数据类型描述"><a href="#2-线性表的抽象数据类型描述" class="headerlink" title="2. 线性表的抽象数据类型描述"></a>2. 线性表的抽象数据类型描述</h3><ul>
<li><p>类型名称：线性表（List）</p>
</li>
<li><p>数据对象集：线性表是 n (≥0) 个元素构成的有序序列$\left(a_{1}, a_{2}, \ldots, a_{n}\right)$</p>
</li>
<li><p>操作集：线性表 L ∈ List，整数 i 表示位置，元素 X ∈ ElementType</p>
<p>线性表基本操作主要有：</p>
<ul>
<li><code>List MakeEmpty()</code>： 初始化一个空线性表 L</li>
<li><code>ElementType FindKth(int K,List L)</code>：根据位序 K，返回相应元素</li>
<li><code>int Find(ElementType X,List L)</code>：在线性表 L 中查找 X 的第一次出现位置</li>
<li><code>void Insert(ElementType X,int i,List L)</code>：在位序 i 前插入一个新元素 X</li>
<li><code>void Delete(int i,List L)</code>：删除指定位序 i 的元素</li>
<li><code>int Length(List L)</code>：返回线性表 L 的长度 n</li>
</ul>
</li>
</ul>
<h4 id="1-线性表的顺序存储实现"><a href="#1-线性表的顺序存储实现" class="headerlink" title="1. 线性表的顺序存储实现"></a>1. 线性表的顺序存储实现</h4><p> 利用数组的连续存储空间顺序存放线性表的各元素</p>
<p>注：顺序存储中是序号是下标，从 0 开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100  <span class="comment">// MAXSIZE 定义为 Data 数组的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;  <span class="comment">// ElementType 可定义为任意类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">   ElementType Data[MAXSIZE]; </span><br><span class="line">   <span class="keyword">int</span> Last;  <span class="comment">// Last 定义线性表的最后一个元素的位置</span></span><br><span class="line">&#125;;</span><br><span class="line">List L;</span><br><span class="line"><span class="comment">//访问下标为 i 的元素：L-&gt;Data[i]</span></span><br><span class="line"><span class="comment">//线性表的长度：L-&gt;Last+1</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; <span class="comment">//初始化顺序表 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,List L)</span></span>; <span class="comment">//查找 X 第一次出现的下标 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List L)</span></span>; <span class="comment">//在下标为 i 的地方插入 X </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List L)</span></span>;   <span class="comment">//删除下标为 i 的当前值 </span></span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List L)</span></span>;  <span class="comment">//返回下标为 K 的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span></span>;  <span class="comment">//返回顺序表的长度 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    L-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找 ，返回查到的第一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,List L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)  </span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last &lt; i)  <span class="comment">//如果没找到，返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 找到后返回下标 </span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last == MAXSIZE<span class="number">-1</span>)&#123;  <span class="comment">//位置已满 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || L-&gt;Last+<span class="number">1</span> &lt; i)&#123;  <span class="comment">//位置越界，如果将数插入 L-&gt;Data[L-&gt;Last+1]，下面都不用腾位置了 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=L-&gt;Last;j&gt;=i;j--)   <span class="comment">// 从后往前依次向后挪一个，给 a[i]腾出位置     </span></span><br><span class="line">        L-&gt;Data[j+<span class="number">1</span>] = L-&gt;Data[j];   </span><br><span class="line">    L-&gt;Data[i] = X;    <span class="comment">//新元素插入</span></span><br><span class="line">    L-&gt;Last++;    <span class="comment">// Last仍然指向最后元素</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || L-&gt;Last &lt;i)&#123;  <span class="comment">//位置越界，而删除最多到 L-&gt;Data[L-&gt;Last]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L-&gt;Data[%d]不存在元素"</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;=L-&gt;Last;j++)   <span class="comment">// 从前往后依次向前挪一个，将 a[i] 覆盖了 </span></span><br><span class="line">        L-&gt;Data[j<span class="number">-1</span>] = L-&gt;Data[j];</span><br><span class="line">    L-&gt;Last--;  <span class="comment">// Last仍然指向最后元素</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按序查找</span></span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(K &lt; <span class="number">0</span> || L-&gt;Last &lt; K)&#123;  <span class="comment">//位置越界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L-&gt;Data[%d]不存在元素"</span>,K);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Data[K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L-&gt;Last+<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	L = MakeEmpty();</span><br><span class="line">	Insert(<span class="number">11</span>,<span class="number">0</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"在线性表L-Data[0]插入11\n"</span>);</span><br><span class="line">	Insert(<span class="number">25</span>,<span class="number">0</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"在线性表L-Data[0]插入25\n"</span>);</span><br><span class="line">	Insert(<span class="number">33</span>,<span class="number">0</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"在线性表L-Data[0]插入33\n"</span>);</span><br><span class="line">	Insert(<span class="number">77</span>,<span class="number">0</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"在线性表L-Data[0]插入77\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"此时的线性表为："</span>); </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length(L);i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,L-&gt;Data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"查找值为12的下标是：%d\n"</span>,Find(<span class="number">12</span>,L));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"下标为3的线性表的值是：%d\n"</span>,FindKth(<span class="number">3</span>,L));</span><br><span class="line">	Delete(<span class="number">2</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"删除线性表中下标为2的元素\n"</span>);</span><br><span class="line">	Delete(<span class="number">2</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"删除线性表中下标为2的元素\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"此时的线性表为："</span>); </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length(L);i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,L-&gt;Data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-线性表的链表存储实现"><a href="#2-线性表的链表存储实现" class="headerlink" title="2. 线性表的链表存储实现"></a>2. 线性表的链表存储实现</h4><p> 不要求逻辑上相邻的两个元素物理上也相邻，通过”链”建立起数据之间的逻辑关系</p>
<ul>
<li>插入、删除不需要移动数据元素，只需要修改”链”</li>
</ul>
<p>注：链表存储中序号从 1 开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; <span class="comment">// ElementType 可定义为任意类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElementType Data;   <span class="comment">//数据域 </span></span><br><span class="line">	List Next;   <span class="comment">// 下一个链表的地址 </span></span><br><span class="line">&#125;; </span><br><span class="line">List L;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>; <span class="comment">//初始化链表 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span></span>;  <span class="comment">// 以遍历链表的方法求链表长度 </span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List L)</span></span>;  <span class="comment">// 按序号查找 </span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X,List L)</span></span>;  <span class="comment">// 按值查找 </span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List L)</span></span>;  <span class="comment">//将 X 插入到第 i-1(i&gt;0) 个结点之后 </span></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List L)</span></span>; <span class="comment">// 删除第 i(i&gt;0) 个结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span></span>; <span class="comment">// 输出链表元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表 </span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">	List L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">	L = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">	List p = L;</span><br><span class="line">	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;  <span class="comment">// 当 p 不为空 </span></span><br><span class="line">		p = p-&gt;Next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 按序查找 </span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List L)</span></span>&#123;</span><br><span class="line">	List p = L;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//从 1 开始 </span></span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; i&lt;K)&#123;</span><br><span class="line">		p = p-&gt;Next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == K)    <span class="comment">// 找到了 </span></span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">else</span>    <span class="comment">// 未找到 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找  </span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X,List L)</span></span>&#123;</span><br><span class="line">	List p = L;</span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; p-&gt;Data!=X)</span><br><span class="line">		p = p-&gt;Next;</span><br><span class="line">	<span class="comment">// 找到了，返回 p</span></span><br><span class="line">	<span class="comment">// 未找到，返回 NULL，此时 p 等于 NULL </span></span><br><span class="line">	<span class="keyword">return</span> p;   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入</span></span><br><span class="line"><span class="comment">1. 用 s 指向一个新的结点</span></span><br><span class="line"><span class="comment">2. 用 p 指向链表的第 i-1 个结点 </span></span><br><span class="line"><span class="comment">3. s-&gt;Next = p-&gt;Next，将 s 的下一个结点指向 p 的下一个结点 </span></span><br><span class="line"><span class="comment">4. p-&gt;Next = s，将 p 的下一结点改为 s   */</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List L)</span></span>&#123;</span><br><span class="line">	List p,s;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">1</span>)&#123;     <span class="comment">// 新结点插入在表头 </span></span><br><span class="line">		s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">		s-&gt;Data = X;</span><br><span class="line">		s-&gt;Next = L;</span><br><span class="line">		<span class="keyword">return</span> s;     <span class="comment">//插入的结点为头结点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	p = FindKth(i<span class="number">-1</span>,L);   <span class="comment">// 找到第 i-1 个结点</span></span><br><span class="line">	<span class="keyword">if</span>(!p)&#123;   <span class="comment">// 第 i-1 个结点不存在 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"结点错误"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">		s-&gt;Data = X;</span><br><span class="line">		s-&gt;Next = p-&gt;Next;   <span class="comment">//将 s 的下一个结点指向 p 的下一个结点 </span></span><br><span class="line">		p-&gt;Next = s;   <span class="comment">// 将 p 的下一结点改为 s</span></span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除</span></span><br><span class="line"><span class="comment">1. 用 p 指向链表的第 i-1 个结点 </span></span><br><span class="line"><span class="comment">2. 用 s 指向要被删除的的第 i 个结点</span></span><br><span class="line"><span class="comment">3. p-&gt;Next = s-&gt;Next，p 指针指向 s 后面</span></span><br><span class="line"><span class="comment">4. free(s)，释放空间 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List L)</span></span>&#123;</span><br><span class="line">	List p,s;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">//如果要删除头结点 </span></span><br><span class="line">		s = L;</span><br><span class="line">		<span class="keyword">if</span>(L)   <span class="comment">// 如果不为空 </span></span><br><span class="line">			L = L-&gt;Next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">free</span>(s);   <span class="comment">// 释放被删除结点 </span></span><br><span class="line">		<span class="keyword">return</span> L; </span><br><span class="line">	&#125;</span><br><span class="line">	p = FindKth(i<span class="number">-1</span>,L);    <span class="comment">// 查找第 i-1 个结点</span></span><br><span class="line">	<span class="keyword">if</span>(!p || !(p-&gt;Next))&#123;     <span class="comment">// 第 i-1 个或第 i 个结点不存在 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"结点错误"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		s = p-&gt;Next;    <span class="comment">// s 指向第 i 个结点 </span></span><br><span class="line">		p-&gt;Next = s-&gt;Next;  <span class="comment">//从链表删除 </span></span><br><span class="line">		<span class="built_in">free</span>(s);  <span class="comment">// 释放被删除结点 </span></span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">	List t;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"当前链表为："</span>);</span><br><span class="line">	<span class="keyword">for</span>(t = L;t;t =t-&gt;Next)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d  "</span>,t-&gt;Data);</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NULL"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	L = MakeEmpty();</span><br><span class="line">	Print(L);</span><br><span class="line">	L = Insert(<span class="number">11</span>,<span class="number">1</span>,L);</span><br><span class="line">	L = Insert(<span class="number">25</span>,<span class="number">1</span>,L);</span><br><span class="line">	L = Insert(<span class="number">33</span>,<span class="number">2</span>,L);</span><br><span class="line">	L = Insert(<span class="number">77</span>,<span class="number">3</span>,L);</span><br><span class="line">	Print(L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"当前链表长度为：%d\n"</span>,Length(L));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"此时链表中第二个结点的值是：%d\n"</span>,FindKth(<span class="number">2</span>,L)-&gt;Data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"查找22是否在该链表中："</span>);</span><br><span class="line">	<span class="keyword">if</span>(Find(<span class="number">22</span>,L))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"是！\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"否！\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"查找33是否在该链表中："</span>);</span><br><span class="line">	<span class="keyword">if</span>(Find(<span class="number">33</span>,L))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"是！\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"否！\n"</span>);</span><br><span class="line">	L = Delete(<span class="number">1</span>,L);</span><br><span class="line">	L = Delete(<span class="number">3</span>,L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------删除后-----\n"</span>); </span><br><span class="line">	Print(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="1-什么是堆栈"><a href="#1-什么是堆栈" class="headerlink" title="1. 什么是堆栈"></a>1. 什么是堆栈</h3><p>堆栈（Stack）：具有一定操作约束的线性表</p>
<ul>
<li>只在一端（栈顶，Top）做插入、删除</li>
<li>插入数据：入栈（Push）</li>
<li>删除数据：出栈（Pop）</li>
<li>后入先出：Last In First Out（LIFO）</li>
</ul>
<h3 id="2-堆栈的抽象数据类型描述"><a href="#2-堆栈的抽象数据类型描述" class="headerlink" title="2. 堆栈的抽象数据类型描述"></a>2. 堆栈的抽象数据类型描述</h3><ul>
<li><p>类型名称：堆栈（Stack）</p>
</li>
<li><p>数据对象集：一个有 0 个或多个元素的有穷线性表</p>
</li>
<li><p>操作集：长度为 MaxSize 的堆栈 S ∈ Stack，堆栈元素 item ∈ ElementType</p>
<p>堆栈的基本操作主要有：</p>
<ul>
<li><code>Stack CreateStack(int MaxSize)</code>：生成空堆栈，其最大长度为 MaxSize</li>
<li><code>int IsFull(Stack S,int MaxSize)</code>：判断堆栈 S 是否已满</li>
<li><code>void Push(Stack S,ElementType item)</code>：将元素 item 压入堆栈</li>
<li><code>int IsEmpty(Stack S)</code>：判断堆栈 S 是否为空</li>
<li><code>ElementType Pop(Stack S)</code>：删除并返回栈顶元素</li>
</ul>
</li>
</ul>
<h4 id="1-栈的顺序存储实现"><a href="#1-栈的顺序存储实现" class="headerlink" title="1. 栈的顺序存储实现"></a>1. 栈的顺序存储实现</h4><p> 栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100   <span class="comment">// 堆栈元素的最大个数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; <span class="comment">// ElementType 暂时定义为 int 类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">	ElementType Data[MaxSize];   <span class="comment">// 存储堆栈元素</span></span><br><span class="line">	<span class="keyword">int</span> Top;  <span class="comment">// 记录栈顶元素下标 </span></span><br><span class="line">&#125;; </span><br><span class="line">Stack S;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>;  <span class="comment">// 初始化堆栈 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Stack S)</span></span>; <span class="comment">// 判断堆栈是否已满 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>;   <span class="comment">// 判断堆栈是否为空 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S,ElementType item)</span></span>;   <span class="comment">// 入栈 </span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>;   <span class="comment">// 出栈 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆栈 </span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">	S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">	S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> S;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已满 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (S-&gt;Top == MaxSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为空 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (S-&gt;Top == <span class="number">-1</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S,ElementType item)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsFull(S))&#123;   <span class="comment">// Top 从 0 开始 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		S-&gt;Top++;   <span class="comment">// 栈顶元素加一 </span></span><br><span class="line">		S-&gt;Data[S-&gt;Top] = item;   <span class="comment">// 放进最上 </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(S))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ElementType val = S-&gt;Data[S-&gt;Top];  <span class="comment">//取出最上 </span></span><br><span class="line">		S-&gt;Top--;  <span class="comment">// 栈顶元素减一 </span></span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	S = CreateStack();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"5入栈\n"</span>);</span><br><span class="line">	Push(S,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"7入栈\n"</span>);</span><br><span class="line">	Push(S,<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"66入栈\n"</span>);</span><br><span class="line">	Push(S,<span class="number">66</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d出栈\n"</span>,Pop(S));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d出栈\n"</span>,Pop(S));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869</span></span><br></pre></td></tr></table></figure>
<h4 id="2-栈的链表存储实现"><a href="#2-栈的链表存储实现" class="headerlink" title="2. 栈的链表存储实现"></a>2. 栈的链表存储实现</h4><p> 栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>;  <span class="comment">// 初始化链栈 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>;  <span class="comment">// 判断链栈是否为空 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S,ElementType item)</span></span>;  <span class="comment">// 入栈 </span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>;  <span class="comment">// 出栈</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stack S;</span><br><span class="line">	S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">	S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (S-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S,ElementType item)</span></span>&#123;</span><br><span class="line">	Stack tmp;</span><br><span class="line">	tmp = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">	tmp-&gt;Data = item;</span><br><span class="line">	<span class="comment">// 链栈栈顶元素是链表头结点，新入栈的链表在栈顶元素后面 </span></span><br><span class="line">	tmp-&gt;Next = S-&gt;Next;   </span><br><span class="line">	S-&gt;Next = tmp;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">	Stack First;</span><br><span class="line">	ElementType TopVal;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(S))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		First = S-&gt;Next;   <span class="comment">// 出栈第一个元素在栈顶元素后面 </span></span><br><span class="line">		S-&gt;Next = First-&gt;Next;  <span class="comment">//把第一个元素从链栈删除 </span></span><br><span class="line">		TopVal = First-&gt;Data;   <span class="comment">// 取出被删除结点的值 </span></span><br><span class="line">		<span class="built_in">free</span>(First);  <span class="comment">// 释放空间 </span></span><br><span class="line">		<span class="keyword">return</span> TopVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Stack S;</span><br><span class="line">	S = CreateStack();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"5入栈\n"</span>);</span><br><span class="line">	Push(S,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"7入栈\n"</span>);</span><br><span class="line">	Push(S,<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"66入栈\n"</span>);</span><br><span class="line">	Push(S,<span class="number">66</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d出栈\n"</span>,Pop(S));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d出栈\n"</span>,Pop(S));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="1-什么是队列"><a href="#1-什么是队列" class="headerlink" title="1. 什么是队列"></a>1. 什么是队列</h3><p>队列（Queue）：具有一定操作约束的线性表</p>
<ul>
<li>插入和删除操作：只能在一端（front）插入，而在另一端（rear）删除</li>
<li>数据插入：入队列（AddQ）</li>
<li>数据删除：出队列（DeleteQ）</li>
<li>先进先出：FIFO</li>
</ul>
<h3 id="2-队列的抽象数据类型描述"><a href="#2-队列的抽象数据类型描述" class="headerlink" title="2. 队列的抽象数据类型描述"></a>2. 队列的抽象数据类型描述</h3><ul>
<li><p>类型名称：队列（Queue）</p>
</li>
<li><p>数据对象集：一个有 0 个或多个元素的有穷线性表</p>
</li>
<li><p>操作集：长度为 MaxSize 的队列 Q∈Queue，队列元素 item∈ElementType</p>
<p>队列的基本操作主要有：</p>
<ul>
<li><code>Queue CreateQueue(int MaxSize)</code>：生成长度为 MaxSize 的空队列</li>
<li><code>int IsFull(Queue Q)</code>：判断队列 Q 是已满</li>
<li><code>void AddQ(Queue Q,ElementType item)</code>：将数据元素 item 插入队列 Q 中</li>
<li><code>int IsEmpty(Queue Q)</code>：判断队列 Q 是否为空</li>
<li><code>ElementType DeleteQ(Queue Q)</code>：将队头数据元素从队列中删除并返回</li>
</ul>
</li>
</ul>
<h4 id="1-循环队列的顺序存储实现"><a href="#1-循环队列的顺序存储实现" class="headerlink" title="1. 循环队列的顺序存储实现"></a>1. 循环队列的顺序存储实现</h4><p> 队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量 front 以及一个记录队列尾元素位置的变量 rear 组成，其中 front 指向整个队列的头一个元素的再前一个，rear 指向的是整个队列的最后一个元素，从 rear 入队，从 front 出队，且仅使用 n-1 个数组空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	ElementType Data[MaxSize];</span><br><span class="line">	<span class="keyword">int</span> front;   <span class="comment">// 记录队头 </span></span><br><span class="line">	<span class="keyword">int</span> rear;    <span class="comment">// 记录队尾 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>;  <span class="comment">// 初始化队列 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,ElementType item)</span></span>;  <span class="comment">//  入队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Queue Q)</span></span>; <span class="comment">// 判断队列是否已满 </span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>;  <span class="comment">// 出队 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>; <span class="comment">// 判断队列是否为空 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Queue Q;</span><br><span class="line">	Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">	Q-&gt;front = <span class="number">-1</span>;</span><br><span class="line">	Q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> ((Q-&gt;rear+<span class="number">1</span>) % MaxSize == Q-&gt;front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,ElementType item)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsFull(Q))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队列满"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">		Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>) % MaxSize;</span><br><span class="line">		Q-&gt;Data[Q-&gt;rear] = item; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q-&gt;front == Q-&gt;rear);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(Q))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Q-&gt;front = (Q-&gt;front+<span class="number">1</span>) % MaxSize;</span><br><span class="line">		<span class="keyword">return</span> Q-&gt;Data[Q-&gt;front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Queue Q;</span><br><span class="line">	Q = CreateQueue();</span><br><span class="line">	AddQ(Q,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3入队\n"</span>);</span><br><span class="line">	AddQ(Q,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"5入队\n"</span>);</span><br><span class="line">	AddQ(Q,<span class="number">11</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"11入队\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d出队\n"</span>,DeleteQ(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d出队\n"</span>,DeleteQ(Q));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-队列的链式存储实现"><a href="#2-队列的链式存储实现" class="headerlink" title="2. 队列的链式存储实现"></a>2. 队列的链式存储实现</h4><p> 队列的链式存储结构也可以用一个单链表实现。插入和删除操作分别在链表的两头进行，front 在链表头，rear 在链表尾，从 rear 入队，从 front 出队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span>    <span class="comment">// 指向队尾结点 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span>   <span class="comment">// 指向队头结点 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>;  <span class="comment">// 初始化队列 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,ElementType item)</span></span>;  <span class="comment">//  入队</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>;  <span class="comment">// 出队 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>; <span class="comment">// 判断队列是否为空 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Queue Q;</span><br><span class="line">	Q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">	Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否为空 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q-&gt;front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,ElementType item)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span>;</span></span><br><span class="line">	node = (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	node-&gt;Data = item;</span><br><span class="line">	node-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==<span class="literal">NULL</span>)&#123;  <span class="comment">//此时队列空 </span></span><br><span class="line">		Q-&gt;rear = node;</span><br><span class="line">		Q-&gt;front = node;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//不为空 </span></span><br><span class="line">		Q-&gt;rear-&gt;Next = node;  <span class="comment">// 将结点入队 </span></span><br><span class="line">		Q-&gt;rear = node;   <span class="comment">// rear 仍然保持最后 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">	ElementType FrontElem;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(Q))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FrontCell = Q-&gt;front;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)&#123; <span class="comment">// 队列中只有一个元素 </span></span><br><span class="line">		Q-&gt;front = Q-&gt;rear = <span class="literal">NULL</span>; </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Q-&gt;front = Q-&gt;front-&gt;Next;</span><br><span class="line">	&#125;</span><br><span class="line">	FrontElem = FrontCell-&gt;Data;</span><br><span class="line">	<span class="built_in">free</span>(FrontCell);</span><br><span class="line">	<span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Queue Q;</span><br><span class="line">	Q = CreateQueue();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"入队5\n"</span>); </span><br><span class="line">	AddQ(Q,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"入队4\n"</span>); </span><br><span class="line">	AddQ(Q,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"入队4\n"</span>); </span><br><span class="line">	AddQ(Q,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"出队%d\n"</span>,DeleteQ(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"出队%d\n"</span>,DeleteQ(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"出队%d\n"</span>,DeleteQ(Q));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,DeleteQ(Q));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1. 树的定义"></a>1. 树的定义</h3><p>树（Tree）：n（n≥0）个结点构成的有限集合</p>
<p>当 n=0 时，称为<strong>空树</strong></p>
<h4 id="1-特征"><a href="#1-特征" class="headerlink" title="1. 特征"></a>1. 特征</h4><p>对于任一棵非空树（n＞0），它具备以下特征：</p>
<ul>
<li>树中有个称为“根（Root）”的特殊结点，用 r 表示</li>
<li>其余结点可分为 m(m&gt;0) 个互不相交的有限集$\mathrm{T}_{1}, \mathrm{T}_{2}, \ldots, \mathrm{T}_{m}$,其中每个集合本身又是一棵树，称为原来树的”子树（SubTree）”</li>
<li>子树是不相交的</li>
<li>除根结点外，每个结点有且仅有一个父结点</li>
<li>一棵 N 个结点的树有 N-1 条边</li>
</ul>
<h4 id="2-基本术语"><a href="#2-基本术语" class="headerlink" title="2. 基本术语"></a>2. 基本术语</h4><ul>
<li>结点的度（Degree）：结点的子树个数</li>
<li>树的度：树的所有结点中最大的度数</li>
<li>叶结点（Leaf）：度为 0 的结点</li>
<li>父结点（Parent）：有子树的结点是其子树的根结点的父结点</li>
<li>子结点（Child）：若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子结点，也称孩子结点</li>
<li>兄弟结点（Sibling）：具有同一父结点的各个结点彼此是兄弟结点</li>
<li>路径：从结点 $\mathrm{n}_{1}$ 到 $\mathrm{n}_{k}$ 的路径为一个结点序列$\mathrm{n}_{1}, \mathrm{n}_{2}, \ldots, \mathrm{n}_{k}$,其中 $\mathrm{n}_{i}$是$\mathrm{n}_{i}$的父结点</li>
<li>路径长度：路径所包含边的个数</li>
<li>祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li>
<li>子孙结点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙</li>
<li>结点的层次（Level）：规定根结点在 1 层，其他任一结点的层数是其父结点的层数加一</li>
<li>树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度</li>
</ul>
<h4 id="3-树的表示"><a href="#3-树的表示" class="headerlink" title="3. 树的表示"></a>3. 树的表示</h4><h5 id="1-儿子-兄弟表示法"><a href="#1-儿子-兄弟表示法" class="headerlink" title="1. 儿子-兄弟表示法"></a>1. 儿子-兄弟表示法</h5><p><img src="https://img-blog.csdnimg.cn/20181026114834352.jpg" alt="img"></p>
<ul>
<li>Element 存值</li>
<li>FirstChild 指向第一个儿子</li>
<li>NextSibling 指向下一个兄弟</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181026114856464.jpg" alt="img"></p>
<h5 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h5><p>即度为 2 的树</p>
<p><img src="https://img-blog.csdnimg.cn/20181026114920772.jpg" alt="img"></p>
<ul>
<li>Element 存值</li>
<li>Left 指向左子树</li>
<li>Right 指向右子树</li>
</ul>
<p>二叉树其实就是儿子-兄弟表示法的链表右移 45° 得到的结果</p>
<p><img src="https://img-blog.csdnimg.cn/20181026114938359.jpg" alt="img"></p>
<h3 id="2-二叉树-1"><a href="#2-二叉树-1" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h4><p> 二叉树 T：一个有穷的结点集合</p>
<p> 这个集合可以为空</p>
<p> 若不为空，则它是由<strong>根结点</strong>和称为其<strong>左子树T</strong>L_L<em>L</em>和<strong>右子树T</strong>R_R<em>R</em>的两个不相交的二叉树组成</p>
<p> 二叉树的子树有左右顺序之分</p>
<h4 id="2-五种基本形态"><a href="#2-五种基本形态" class="headerlink" title="2. 五种基本形态"></a>2. 五种基本形态</h4><p><img src="https://img-blog.csdnimg.cn/20181026114956314.jpg" alt="img"></p>
<h4 id="3-特殊形态"><a href="#3-特殊形态" class="headerlink" title="3. 特殊形态"></a>3. 特殊形态</h4><ul>
<li><p>斜二叉树</p>
<p>只有左儿子或只有右儿子</p>
<p><img src="https://img-blog.csdnimg.cn/20181026115013432.jpg" alt="img"></p>
</li>
<li><p>完美二叉树（满二叉树）</p>
<p>除最后一层叶结点外，每个结点都有两个子结点</p>
<p><img src="https://img-blog.csdnimg.cn/20181026115028605.jpg" alt="img"></p>
</li>
<li><p>完全二叉树</p>
<p>有 n 个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为 i（1 ≤ i ≤ n）结点与满二叉树中编号为 i 结点在二叉树中位置相同</p>
<p><img src="https://img-blog.csdnimg.cn/20181026115044316.jpg" alt="img"></p>
</li>
</ul>
<h4 id="4-重要性质"><a href="#4-重要性质" class="headerlink" title="4. 重要性质"></a>4. 重要性质</h4><ul>
<li>一个二叉树第 i 层的最大结点数为：$2^{i-1}, i \geq1$</li>
<li>深度为 k 的二叉树有最大结点总数为：$2^{k}-1, k \geq 1$</li>
<li>对任何非空二叉树 T，若 $\mathrm {n}_{0}$表示叶结点的个数、$\mathrm {n}_{2}$是度为 2 的非叶结点个数，那么二者满足关系 $\mathrm {n}_{0} = {n}_{2}+1$</li>
</ul>
<h4 id="5-抽象数据类型定义"><a href="#5-抽象数据类型定义" class="headerlink" title="5. 抽象数据类型定义"></a>5. 抽象数据类型定义</h4><ul>
<li><p>类型名称：二叉树</p>
</li>
<li><p>数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成</p>
</li>
<li><p>操作集：BT ∈ BinTree，Item ∈ ElementType</p>
<p>主要操作有：</p>
<ul>
<li><code>Boolean IsEmpty(BinTree BT)</code>：判别 BT 是否为空</li>
<li><code>void Traversal(BinTree BT)</code>：遍历，按某顺序访问每个结点</li>
<li><code>BinTree CreatBinTree()</code>：创建一个二叉树</li>
</ul>
<p>常用的遍历方法有：</p>
<ul>
<li><code>void PreOrderTraversal(BinTree BT)</code>：先序——根、左子树、右子树</li>
<li><code>void InOrderTraversal(BinTree BT)</code>：中序——左子树、根、右子树</li>
<li><code>void PostOrderTraversal(BinTree BT)</code>：后序——左子树、右子树、根</li>
<li><code>void LevelOrderTraversal(BinTree BT)</code>：层次遍历，从上到下、从左到右</li>
</ul>
</li>
</ul>
<h5 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1. 顺序存储结构"></a>1. 顺序存储结构</h5><p>按从上至下、从左到右顺序存储 n 个结点的完全二叉树的结点父子关系：</p>
<ul>
<li>非根结点（序号 i &gt; 1）的<strong>父结点</strong>的序号是 ⌊i/2⌋（向下取整）</li>
<li>结点（序号为 i）的<strong>左孩子结点</strong>的序号是 2i（若 2 i ≤ n，否则没有左孩子</li>
<li>结点（序号为 i）的<strong>右孩子结点</strong>的序号是 2i+1（若 2 i +1 ≤ n，否则没有右孩子</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181026115118948.jpg" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20181026115134161.jpg" alt="img"></p>
<h5 id="2-链表存储"><a href="#2-链表存储" class="headerlink" title="2. 链表存储"></a>2. 链表存储</h5><p><img src="https://img-blog.csdnimg.cn/20181026114920772.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	Element Data;  <span class="comment">// 存值 </span></span><br><span class="line">	BinTree Left;    <span class="comment">// 左儿子结点 </span></span><br><span class="line">	BinTree Right;   <span class="comment">// 右儿子结点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="0-树的表示"><a href="#0-树的表示" class="headerlink" title="0. 树的表示"></a>0. 树的表示</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> Data;  <span class="comment">// 存值 </span></span><br><span class="line">	BinTree Left;    <span class="comment">// 左儿子结点 </span></span><br><span class="line">	BinTree Right;   <span class="comment">// 右儿子结点 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h4 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1. 先序遍历"></a>1. 先序遍历</h4><p>遍历过程：</p>
<ol>
<li>访问<strong>根结点</strong></li>
<li><strong>先序</strong>遍历其<strong>左子树</strong></li>
<li><strong>先序</strong>遍历其<strong>右子树</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181030202740803.jpg" alt="img"></p>
<h5 id="1-递归实现"><a href="#1-递归实现" class="headerlink" title="1.递归实现"></a>1.递归实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);  <span class="comment">// 打印根 </span></span><br><span class="line">		PreOrderTraversal(BT-&gt;Left);  <span class="comment">// 进入左子树 </span></span><br><span class="line">		PreOrderTraversal(BT-&gt;Right);  <span class="comment">// 进入右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h5 id="2-非递归实现"><a href="#2-非递归实现" class="headerlink" title="2. 非递归实现"></a>2. 非递归实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	BinTree T = BT;</span><br><span class="line">	Stack S = CreateStack();  <span class="comment">// 创建并初始化堆栈 S</span></span><br><span class="line">	<span class="keyword">while</span>(T || !IsEmpty(S))&#123;  <span class="comment">// 当树不为空或堆栈不空 </span></span><br><span class="line">		<span class="keyword">while</span>(T)&#123;     </span><br><span class="line">			Push(S,T);    <span class="comment">// 压栈，第一次遇到该结点 </span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);  <span class="comment">// 访问结点</span></span><br><span class="line">			T = T-&gt;Left;   <span class="comment">// 遍历左子树 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!IsEmpty(S))&#123;  <span class="comment">// 当堆栈不空 </span></span><br><span class="line">			T = Pop(S);    <span class="comment">// 出栈，第二次遇到该结点 </span></span><br><span class="line">			T = T-&gt;Right;  <span class="comment">// 访问右结点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h4><p>递归过程：</p>
<ol>
<li><strong>中序</strong>遍历其<strong>左子树</strong></li>
<li>访问<strong>根结点</strong></li>
<li><strong>中序</strong>遍历其<strong>右子树</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2018103020280133.jpg" alt="img"></p>
<h5 id="1-递归实现-1"><a href="#1-递归实现-1" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">		InOrderTraversal(BT-&gt;Left);  <span class="comment">// 进入左子树 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);  <span class="comment">// 打印根 </span></span><br><span class="line">		InOrderTraversal(BT-&gt;Right);  <span class="comment">// 进入右子树 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h6 id="2-非递归实现-1"><a href="#2-非递归实现-1" class="headerlink" title="2. 非递归实现"></a>2. 非递归实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	BinTree T = BT;</span><br><span class="line">	Stack S = CreateStack();  <span class="comment">// 创建并初始化堆栈 S</span></span><br><span class="line">	<span class="keyword">while</span>(T || !IsEmpty(S))&#123;  <span class="comment">// 当树不为空或堆栈不空 </span></span><br><span class="line">		<span class="keyword">while</span>(T)&#123;     </span><br><span class="line">			Push(S,T);    <span class="comment">// 压栈</span></span><br><span class="line">			T = T-&gt;Left;   <span class="comment">// 遍历左子树 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!IsEmpty(S))&#123;  <span class="comment">// 当堆栈不空 </span></span><br><span class="line">			T = Pop(S);    <span class="comment">// 出栈</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);  <span class="comment">// 访问结点</span></span><br><span class="line">			T = T-&gt;Right;  <span class="comment">// 访问右结点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><p>遍历过程：</p>
<ol>
<li><strong>后序</strong>遍历其<strong>左子树</strong></li>
<li><strong>后序</strong>遍历其<strong>右子树</strong></li>
<li>访问<strong>根结点</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2018103020284288.jpg" alt="img"></p>
<h5 id="1-递归实现-2"><a href="#1-递归实现-2" class="headerlink" title="1. 递归实现"></a>1. 递归实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">		PostOrderTraversal(BT-&gt;Left);  <span class="comment">// 进入左子树 </span></span><br><span class="line">		PostOrderTraversal(BT-&gt;Right);  <span class="comment">// 进入右子树 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);  <span class="comment">// 打印根 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h5 id="2-非递归实现-2"><a href="#2-非递归实现-2" class="headerlink" title="2. 非递归实现"></a>2. 非递归实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	BinTree T = BT;</span><br><span class="line">	Stack S = CreateStack();  <span class="comment">// 创建并初始化堆栈 S</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;BinTree&gt; v;   <span class="comment">// 创建存储树结点的动态数组</span></span><br><span class="line">	Push(S,T);</span><br><span class="line">	<span class="keyword">while</span>(!IsEmpty(S))&#123;  <span class="comment">// 当树不为空或堆栈不空 </span></span><br><span class="line">		T = Pop(S);</span><br><span class="line">		v.push_back(T);  <span class="comment">// 出栈元素进数组</span></span><br><span class="line">		<span class="keyword">if</span>(T-&gt;Left)</span><br><span class="line">			Push(S,T-&gt;Left);</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;Right)</span><br><span class="line">			Push(S,T-&gt;Right);</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());  <span class="comment">// 逆转 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)  <span class="comment">// 输出数组元素</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,v[i]-&gt;Data);</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>先序、中序和后序遍历过程：遍历过程中经过结点的路线一样，只是访问各结点的时机不同，即：</p>
<ul>
<li>先序遍历是第一次”遇到”该结点时访问</li>
<li>中序遍历是第二次”遇到”该结点（此时该结点从左子树返回）时访问</li>
<li>后序遍历是第三次”遇到”该结点（此时该结点从右子树返回）时访问</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181030202857229.jpg" alt="img"></p>
<h4 id="5-层序遍历"><a href="#5-层序遍历" class="headerlink" title="5. 层序遍历"></a>5. 层序遍历</h4><p>遍历过程：从上至下，从左至右访问所有结点</p>
<p>队列实现过程：</p>
<ol>
<li>根结点入队</li>
<li>从队列中取出一个元素</li>
<li>访问该元素所指结点</li>
<li>若该元素所指结点的左孩子结点非空，左孩子结点入队</li>
<li>若该元素所指结点的右孩子结点非空，右孩子结点入队</li>
<li>循环 1 - 4，直到队列中为空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;BinTree&gt; q;   <span class="comment">// 创建队列</span></span><br><span class="line">	BinTree T;</span><br><span class="line">	<span class="keyword">if</span>(!BT)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	q.push(BT);  <span class="comment">// BT 入队 </span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		T = q.front();  <span class="comment">// 访问队首元素 </span></span><br><span class="line">		q.pop();  <span class="comment">// 出队</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;Left)  <span class="comment">// 如果存在左儿子结点</span></span><br><span class="line">			q.push(T-&gt;Left);  <span class="comment">// 入队</span></span><br><span class="line">	 	<span class="keyword">if</span>(T-&gt;Right)</span><br><span class="line">	 		q.push(T-&gt;Right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<h4 id="6-例子"><a href="#6-例子" class="headerlink" title="6. 例子"></a>6. 例子</h4><h5 id="1-输出叶子结点"><a href="#1-输出叶子结点" class="headerlink" title="1. 输出叶子结点"></a>1. 输出叶子结点</h5><p>前序遍历加个没有孩子结点的约束即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">FindLeaves</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">		<span class="keyword">if</span>( !BT-&gt;Left &amp;&amp; !BT-&gt;Right)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);  <span class="comment">// 打印叶子结点</span></span><br><span class="line">		FindLeaves(BT-&gt;Left);  <span class="comment">// 进入左子树 </span></span><br><span class="line">		FindLeaves(BT-&gt;Right);  <span class="comment">// 进入右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<h5 id="2-树的高度"><a href="#2-树的高度" class="headerlink" title="2. 树的高度"></a>2. 树的高度</h5><p>当前树的高度为其子树最大高度 +1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetHeight</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hl,hr,maxh;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">		hl = GetHeight(BT-&gt;Left);  <span class="comment">// 求左子树高度 </span></span><br><span class="line">		hr = GetHeight(BT-&gt;Right);  <span class="comment">// 求右子树高度 </span></span><br><span class="line">		maxh = (hl&gt;hr)?hl:hr;</span><br><span class="line">		<span class="keyword">return</span> maxh+<span class="number">1</span>;  <span class="comment">// 当前结点高度为左右子树最大的高度+1 </span></span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<h5 id="3-由两种遍历序列确定二叉树"><a href="#3-由两种遍历序列确定二叉树" class="headerlink" title="3. 由两种遍历序列确定二叉树"></a>3. 由两种遍历序列确定二叉树</h5><p><strong>前提</strong>：有一种序列必须是中序！</p>
<p>方法：</p>
<ol>
<li>根据先序（或后序）遍历序列第一个（或最后一个）结点<strong>确定根结点</strong></li>
<li>根据根结点在中序序列中<strong>分割出左右</strong>两个子序列</li>
<li>对左子树和右子树分别递归使用同样的方法继续分解</li>
</ol>
<p>例如：</p>
<p>前序：ABCDEFG<br>中序：CBDAFEG</p>
<p>先序遍历为”根左右”，则 A 是根，对应可以划分出中序中：(CBD)A(FEG)，CBD 为左子树，FEG 为右子树，再根据前序的 BCD，B 为根，划分出中序中 (C(B)D)A(FEG)，则 C D 分别是 B 的左右子树…最后可得树为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  B    E</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">C   D F  G</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h4><p> 二叉搜索树（BST）也称二叉排序树或二叉查找树</p>
<p>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p>
<ol>
<li>非空<strong>左子树</strong>的所有键值<strong>小于</strong>其根结点的键值</li>
<li>非空<strong>右子树</strong>的所有键值<strong>大于</strong>其根结点的键值</li>
<li>左、右子树都是二叉搜索树</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20181101090543537.jpg" alt="img"></p>
<h4 id="2-特殊函数"><a href="#2-特殊函数" class="headerlink" title="2. 特殊函数"></a>2. 特殊函数</h4><ul>
<li><code>BinTree Find(ElementType X,BinTree BST)</code>：从二叉搜索树 BST 中查找元素 X，返回其所在结点地址</li>
<li><code>BinTree FindMin(BinTree BST)</code>：从二叉搜索树 BST 中查找并返回最小元素所在结点的地址</li>
<li><code>BinTree FindMax(BinTree BST)</code>：从二叉搜索树 BST 中查找并返回最大元素所在结点的地址</li>
<li><code>BinTree Insert(ElementType X,BinTree BST)</code>：插入一个元素进 BST</li>
<li><code>BinTree Delete(ElementType X,BinTree BST)</code>：从 BST 中删除一个元素</li>
</ul>
<h5 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h5><ul>
<li>查找从根结点开始，如果树为空，返回 NULL</li>
<li>若搜索树不为空，则根结点键值和 X 进行比较，并进行不同处理：<ol>
<li>若 X <strong>小于</strong>根结点键值，在<strong>左子树</strong>中继续查找</li>
<li>若 X <strong>大于</strong>根结点键值，在<strong>右子树</strong>中继续查找</li>
<li>如 X 等于根节点键值，查找结束，返回指向此结点的指针</li>
</ol>
</li>
</ul>
<h5 id="2-查找最大和最小元素"><a href="#2-查找最大和最小元素" class="headerlink" title="2. 查找最大和最小元素"></a>2. 查找最大和最小元素</h5><ul>
<li><strong>最大元素</strong>一定是在树的<strong>最右</strong>分支的端结点上</li>
<li><strong>最小元素</strong>一定是在树的<strong>最左</strong>分支的端结点上</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181101090730163.jpg" alt="img"></p>
<h5 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h5><p>删除的三种情况：</p>
<ol>
<li><p>要删除的是<strong>叶结点</strong>：直接删除，并将其父结点指针置为 NULL</p>
</li>
<li><p>要删除的结点<strong>只有一个孩子</strong>结点：将其父结点的指针指向要删除结点的孩子结点</p>
</li>
<li><p>要删除的结点有左、右两棵子树：用<strong>右子树的最小元素</strong>或<strong>左子树的最大元素</strong>替代被删除结点</p>
<p><img src="https://img-blog.csdnimg.cn/20181101090806846.gif" alt="img"> <img src="https://img-blog.csdnimg.cn/20181101090819459.gif" alt="img"></p>
</li>
</ol>
<h5 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	BinTree Left;</span><br><span class="line">	BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找递归实现 </span></span><br><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!BST)  <span class="comment">// 如果根结点为空，返回 NULL </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">if</span>(X &lt; BST-&gt;Data) <span class="comment">// 比根结点小，去左子树查找 </span></span><br><span class="line">		<span class="keyword">return</span> Find(X,BST-&gt;Left); </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Data &lt; X)  <span class="comment">// 比根结点大，去右子树查找 </span></span><br><span class="line">		<span class="keyword">return</span> Find(X,BST-&gt;Right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Data == X) <span class="comment">// 找到了 </span></span><br><span class="line">		<span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找非递归实现</span></span><br><span class="line"><span class="function">BinTree <span class="title">IterFind</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(BST)&#123;</span><br><span class="line">		<span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">			BST = BST-&gt;Left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Data &lt; X)  <span class="comment">// 比根结点大，去右子树查找 </span></span><br><span class="line">			BST = BST-&gt;Right;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Data == X) <span class="comment">// 找到了 </span></span><br><span class="line">			<span class="keyword">return</span> BST;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小值的递归实现</span></span><br><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!BST)    <span class="comment">// 如果为空了，返回 NULL </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Left)   <span class="comment">// 还存在左子树，沿左分支继续查找 </span></span><br><span class="line">		<span class="keyword">return</span> FindMin(BST-&gt;Left);</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 找到了 </span></span><br><span class="line">		<span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最大值的非递归实现</span></span><br><span class="line"><span class="function">BinTree <span class="title">FindMax</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BST)  <span class="comment">// 如果不空 </span></span><br><span class="line">		<span class="keyword">while</span>(BST-&gt;Right)   <span class="comment">// 只要右子树还存在 </span></span><br><span class="line">			BST = BST-&gt;Right;</span><br><span class="line">	<span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!BST)&#123;  <span class="comment">// 如果为空，初始化该结点 </span></span><br><span class="line">		BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">		BST-&gt;Data = X;</span><br><span class="line">		BST-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">		BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">// 不为空 </span></span><br><span class="line">		<span class="keyword">if</span>(X &lt; BST-&gt;Data)  <span class="comment">// 如果小，挂在左边 </span></span><br><span class="line">			BST-&gt;Left = Insert(X,BST-&gt;Left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Data &lt; X)  <span class="comment">// 如果大，挂在右边 </span></span><br><span class="line">			BST-&gt;Right = Insert(X,BST-&gt;Right);</span><br><span class="line">		<span class="comment">// 如果相等，什么都不用做 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">	BinTree tmp;</span><br><span class="line">	<span class="keyword">if</span>(!BST)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"要删除的元素未找到"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)   <span class="comment">// X 比当前结点值小，在左子树继续查找删除 </span></span><br><span class="line">		BST-&gt;Left = Delete(X,BST-&gt;Left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Data &lt; X)   <span class="comment">// X 比当前结点值大，在右子树继续查找删除 </span></span><br><span class="line">		BST-&gt;Right = Delete(X,BST-&gt;Right);</span><br><span class="line">	<span class="keyword">else</span>&#123;  <span class="comment">//  找到被删除结点 </span></span><br><span class="line">		<span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;  <span class="comment">// 被删除结点有俩孩子结点 </span></span><br><span class="line">			tmp = FindMin(BST-&gt;Right);   <span class="comment">// 找到右子树中值最小的</span></span><br><span class="line">			BST-&gt;Data = tmp-&gt;Data;     <span class="comment">// 用找到的值覆盖当前结点 </span></span><br><span class="line">			BST-&gt;Right = Delete(tmp-&gt;Data,BST-&gt;Right);    <span class="comment">// 把前面找到的右子树最小值结点删除 </span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;  <span class="comment">// 被删除结点只有一个孩子结点或没有孩子结点 </span></span><br><span class="line">			tmp = BST;</span><br><span class="line">			<span class="keyword">if</span>(!BST-&gt;Left &amp;&amp; !BST-&gt;Right)  <span class="comment">// 没有孩子结点 </span></span><br><span class="line">				BST = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; !BST-&gt;Right)  <span class="comment">// 只有左孩子结点 </span></span><br><span class="line">				BST = BST-&gt;Left;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left &amp;&amp; BST-&gt;Right)  <span class="comment">// 只有右孩子结点 </span></span><br><span class="line">				BST = BST-&gt;Right;</span><br><span class="line">			<span class="built_in">free</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">		InOrderTraversal(BT-&gt;Left);  <span class="comment">// 进入左子树 </span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;BT-&gt;Data;  <span class="comment">// 打印根 </span></span><br><span class="line">		InOrderTraversal(BT-&gt;Right);  <span class="comment">// 进入右子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	BinTree BST = <span class="literal">NULL</span>;</span><br><span class="line">	BST = Insert(<span class="number">5</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">7</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">3</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">1</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">2</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">4</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">6</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">8</span>,BST); </span><br><span class="line">	BST = Insert(<span class="number">9</span>,BST); </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">			    5</span></span><br><span class="line"><span class="comment">			   /\</span></span><br><span class="line"><span class="comment">			  3  7</span></span><br><span class="line"><span class="comment">             /\	 /\</span></span><br><span class="line"><span class="comment">            1 4 6  8</span></span><br><span class="line"><span class="comment">			\      \</span></span><br><span class="line"><span class="comment">			 2      9</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历的结果是："</span>; </span><br><span class="line">	InOrderTraversal(BST);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"查找最小值是："</span>&lt;&lt;FindMin(BST)-&gt;Data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"查找最大值是："</span>&lt;&lt;FindMax(BST)-&gt;Data&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"查找值为3的结点左子树结点值为："</span>&lt;&lt;Find(<span class="number">3</span>,BST)-&gt;Left-&gt;Data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"查找值为7的结点右子树结点值为："</span>&lt;&lt;IterFind(<span class="number">7</span>,BST)-&gt;Right-&gt;Data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除值为5的结点"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	Delete(<span class="number">5</span>,BST);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">			    6</span></span><br><span class="line"><span class="comment">			   /\</span></span><br><span class="line"><span class="comment">			  3  7</span></span><br><span class="line"><span class="comment">             /\	  \</span></span><br><span class="line"><span class="comment">            1 4    8</span></span><br><span class="line"><span class="comment">			\      \</span></span><br><span class="line"><span class="comment">			 2      9</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历的结果是："</span>; </span><br><span class="line">	InOrderTraversal(BST);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="0-为何要使用AVL树？"><a href="#0-为何要使用AVL树？" class="headerlink" title="0. 为何要使用AVL树？"></a>0. 为何要使用AVL树？</h4><p>二叉搜索树的搜索效率与其树的深度相关，而二叉搜索树的组成又与其插入序列相关，在极端情况下，二叉搜索树退化为一条单链（比如插入序列是 1 2 3 … n），使得搜索效率大大降低，为了避免这种情况出现，我们采用二叉平衡树对插入结点进行调整，使得树的深度尽可能小</p>
<h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul>
<li>平衡因子<br>BF(T) = $ {h}_{L}-{h}_{R}$​，其中${h}_{L}$、$h_R$分别是左右子树的高度</li>
<li>平衡二叉树(AVL 树)<br>空树，或者任一结点左、右子树高度差的绝对值不超过 1，即 |BF(T)|≤1 的树</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181102110417706.jpg" alt="img"></p>
<h4 id="2-平衡二叉树的调整"><a href="#2-平衡二叉树的调整" class="headerlink" title="2. 平衡二叉树的调整"></a>2. 平衡二叉树的调整</h4><h5 id="0-遵循原则"><a href="#0-遵循原则" class="headerlink" title="0. 遵循原则"></a>0. 遵循原则</h5><ul>
<li>从离插入结点最近的结点调整</li>
</ul>
<h5 id="1-RR-单旋"><a href="#1-RR-单旋" class="headerlink" title="1. RR 单旋"></a>1. RR 单旋</h5><p>当”插入结点”(BR)是”被破坏平衡结点”(A)<strong>右子树</strong>的<strong>右子树</strong>时，即 RR 插入时，采用 RR 旋转调整<br><img src="https://img-blog.csdnimg.cn/20181102110800268.jpg" alt="img"><br>其基本思路是把 B 的左子树腾出来挂到 A 的右子树上，返回 B 作为当前子树的根</p>
<p>示意图：<br><img src="https://img-blog.csdnimg.cn/20181102113105538.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RRRotation</span><span class="params">(AVLTree A)</span></span>&#123;</span><br><span class="line">	AVLTree B = A-&gt;right;   <span class="comment">// B 为 A 的右子树  </span></span><br><span class="line">	A-&gt;right = B-&gt;left;    <span class="comment">// B 的左子树挂在 A 的右子树上 </span></span><br><span class="line">	B-&gt;left = A;   <span class="comment">//  A 挂在 B 的左子树上 </span></span><br><span class="line">	<span class="keyword">return</span> B;  <span class="comment">// 此时 B 为根结点了   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h5 id="2-LL-单旋"><a href="#2-LL-单旋" class="headerlink" title="2. LL 单旋"></a>2. LL 单旋</h5><p>当”插入结点”(BL)是”被破坏平衡结点”(A)<strong>左子树</strong>的<strong>左子树</strong>时，即 LL 插入，采用 RR 旋转调整<br><img src="https://img-blog.csdnimg.cn/20181102112405164.jpg" alt="img"><br>其基本思路是把 B 的右子树腾出来挂到 A 的左子树上，返回 B 作为当前子树的根</p>
<p>示意图：<br><img src="https://img-blog.csdnimg.cn/20181102114124904.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LLRotation</span><span class="params">(AVLTree A)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 此时根节点是 A </span></span><br><span class="line">	AVLTree B = A-&gt;left;  <span class="comment">// B 为 A 的左子树  </span></span><br><span class="line">	A-&gt;left = B-&gt;right;   <span class="comment">// B 的右子树挂在 A 的左子树上 </span></span><br><span class="line">	B-&gt;right = A;     <span class="comment">//  A 挂在 B 的右子树上 </span></span><br><span class="line">	<span class="keyword">return</span> B;  <span class="comment">// 此时 B 为根结点了 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h5 id="3-LR-双旋"><a href="#3-LR-双旋" class="headerlink" title="3. LR 双旋"></a>3. LR 双旋</h5><p>当”插入结点”(CL 或者 CR)是”被破坏平衡结点”(A)<strong>左子树</strong>的<strong>右子树</strong>时，即 LR 插入，采用 LR 旋转调整<br><img src="https://img-blog.csdnimg.cn/20181102112415831.jpg" alt="img"><br>基本思想是先将 B 作为根结点进行 <strong>RR 单旋</strong>转化为 LL 插入，再将 A 作为根结点进行 <strong>LL 单旋</strong>（先 RR 再 LL）</p>
<p>示意图：<br><img src="https://img-blog.csdnimg.cn/20181102115543530.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LRRotation</span><span class="params">(AVLTree A)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 先 RR 单旋</span></span><br><span class="line">	A-&gt;left = RRRotation(A-&gt;left);</span><br><span class="line">	<span class="comment">// 再 LL 单旋 </span></span><br><span class="line">	<span class="keyword">return</span> LLRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>总结：叫 LR 双旋是从上到下看，而实际先 RR 单旋再 LL 单旋是从下往上的过程</p>
<h5 id="4-RL-双旋"><a href="#4-RL-双旋" class="headerlink" title="4. RL 双旋"></a>4. RL 双旋</h5><p>当”插入结点”(CL 或者 CR)是”被破坏平衡结点”(A)<strong>右子树</strong>的<strong>左子树</strong>时，即 RL 插入，采用 RL 旋转调整<br><img src="https://img-blog.csdnimg.cn/20181102112435166.jpg" alt="img"><br>基本思想是先将 B 作为根结点进行 <strong>LL 单旋</strong>转化为 RR 插入，再将 A 作为根结点进行 <strong>RR单旋</strong>（先 LL 再 RR）</p>
<p>示意图：<br><img src="https://img-blog.csdnimg.cn/20181102115827971.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RLRotation</span><span class="params">(AVLTree A)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 先 LL 单旋</span></span><br><span class="line">	A-&gt;right = LLRotation(A-&gt;right);</span><br><span class="line">	<span class="comment">// 再 RR 单旋 </span></span><br><span class="line">	<span class="keyword">return</span> RRRotation(A); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>总结：叫 RL 双旋是从上到下看，而实际先 LL 单旋再 RR 单旋是从下往上的过程</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="1-什么是堆"><a href="#1-什么是堆" class="headerlink" title="1. 什么是堆"></a>1. 什么是堆</h4><p>优先队列（priority Queue）：特殊的”队列”，取出元素的顺序是依照元素的优先级（关键字）大小，而不是元素进入队列的先后顺序，以<strong>完全二叉树</strong>存储</p>
<p><img src="https://img-blog.csdnimg.cn/20181104104440648.jpg" alt="img"></p>
<p>两个特性</p>
<ul>
<li><p>结构性：用<strong>数组</strong>表示的<strong>完全二叉树</strong></p>
</li>
<li><p>有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）</p>
<ul>
<li><p>“最大堆(MaxHeap)”，也称”大顶堆”：最大值</p>
<p><img src="https://img-blog.csdnimg.cn/20181104104459868.jpg" alt="img"></p>
</li>
<li><p>“最小堆(MinHeap)”，也称”小顶堆”：最小值</p>
<p><img src="https://img-blog.csdnimg.cn/20181104104516209.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181104104530440.jpg" alt="img"></p>
<h4 id="2-堆的抽象数据类型描述"><a href="#2-堆的抽象数据类型描述" class="headerlink" title="2. 堆的抽象数据类型描述"></a>2. 堆的抽象数据类型描述</h4><ul>
<li><p>数据名称：最大堆（MaxHeap）</p>
</li>
<li><p>数据对象集：完全二叉树，每个结点的元素值<strong>不小于</strong>其子结点的元素值</p>
</li>
<li><p>操作集：最大堆 H ∈ MaxHeap，元素 item ∈ ElementType</p>
<p>主要操作有：</p>
<ul>
<li><code>MaxHeap Create(int MaxSize)</code>：创建一个空的最大堆</li>
<li><code>Boolean IsFull(MaxHeap H)</code>：判断最大堆 H 是否已满</li>
<li><code>Boolean Insert(MaxHeap H,ElementType item)</code>：将元素 item 插入最大堆 H</li>
<li><code>Boolean IsEmpty(MaxHeap H)</code>：判断最大堆 H 是否为空</li>
<li><code>ElementType DeleteMax(MaxHeap H)</code>：返回 H 中最大元素（高优先级）</li>
</ul>
</li>
</ul>
<h5 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h5><p> 插入数组最后一个位置，再从下往上找合适地方</p>
<h5 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h5><p> 删除根结点，将数组最后一个位置的数取到根结点，从上往下找合适地方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxData 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">	ElementType *Elements;   <span class="comment">// 存储堆元素的数组 </span></span><br><span class="line">	<span class="keyword">int</span> Size;      <span class="comment">// 堆的当前元素个数 </span></span><br><span class="line">	<span class="keyword">int</span> Capacity;  <span class="comment">// 堆的最大容量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MaxHeap <span class="title">Create</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>;  <span class="comment">// 建堆 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(MaxHeap H)</span></span>;    <span class="comment">// 判断堆是否满</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span>;   <span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(MaxHeap H)</span></span>;    <span class="comment">//  判断堆是否为空</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(MaxHeap H)</span></span>;  <span class="comment">// 删除并返回堆中最大元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(MaxHeap H)</span></span>;  <span class="comment">// 层序遍历 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建堆 </span></span><br><span class="line"><span class="function">MaxHeap <span class="title">Create</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">	MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HeapStruct));</span><br><span class="line">	<span class="comment">// Elements[0] 作为哨兵，堆元素从  Elements[1] 开始存放 </span></span><br><span class="line">	H-&gt;Elements = (ElementType *)<span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">	H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">	H-&gt;Capacity = MaxSize;</span><br><span class="line">	<span class="comment">// "哨兵"大于堆中所有可能的值 </span></span><br><span class="line">	H-&gt;Elements[<span class="number">0</span>] = MaxData;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入，从完全二叉树的最后一个位置插入 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆已满，无法插入！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = ++H-&gt;Size;  <span class="comment">// 指向堆中最后一个位置 </span></span><br><span class="line">	<span class="keyword">for</span>(;H-&gt;Elements[i/<span class="number">2</span>] &lt; item;i/=<span class="number">2</span>)    <span class="comment">// 向上找比 item 大的结点 </span></span><br><span class="line">		H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>];  <span class="comment">//  向下赋值 </span></span><br><span class="line">	H-&gt;Elements[i] = item;  <span class="comment">// 找到了，把 item 值放进去 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除，从根结点删除 </span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent,child;</span><br><span class="line">	ElementType Max,tmp;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆为空，无法删除！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	Max = H-&gt;Elements[<span class="number">1</span>];  <span class="comment">// 拿到最大值</span></span><br><span class="line">	tmp = H-&gt;Elements[H-&gt;Size--];  <span class="comment">// 拿到完全二叉树最后一个值 </span></span><br><span class="line">	<span class="comment">// 判别条件：parent 是否有左孩子结点 </span></span><br><span class="line">	<span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;Size;parent=child)&#123;</span><br><span class="line">		<span class="comment">// 左右孩子结点中找较大的值 </span></span><br><span class="line">		child = <span class="number">2</span> * parent;  <span class="comment">// 左孩子结点 </span></span><br><span class="line">		<span class="comment">// child!=H-&gt;Size 表示 child 不为当前最后一个结点，即 parent 有右孩子结点 </span></span><br><span class="line">		<span class="keyword">if</span>((child!=H-&gt;Size) &amp;&amp;(H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class="number">1</span>]))</span><br><span class="line">			child++;  </span><br><span class="line">		<span class="comment">// 给 tmp 找个合适的位置 </span></span><br><span class="line">		<span class="comment">// 如果当前左右孩子结点比 tmp 都小，说明 tmp 位置已经合适 </span></span><br><span class="line">		<span class="keyword">if</span>(H-&gt;Elements[child] &lt;= tmp)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>    <span class="comment">// 否则把较大的孩子结点提上来，自己继续下去找 </span></span><br><span class="line">			H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class="line">	&#125;</span><br><span class="line">	H-&gt;Elements[parent] = tmp;  <span class="comment">// 在合适的位置把 tmp 放进去 </span></span><br><span class="line">	<span class="keyword">return</span> Max;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否已经满 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !H-&gt;Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"层序遍历的结果是："</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=H-&gt;Size;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,H-&gt;Elements[i]);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MaxHeap H;</span><br><span class="line">	<span class="keyword">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line">	H = Create(MaxSize);</span><br><span class="line">	Insert(H,<span class="number">55</span>);</span><br><span class="line">	Insert(H,<span class="number">66</span>);</span><br><span class="line">	Insert(H,<span class="number">44</span>);</span><br><span class="line">	Insert(H,<span class="number">33</span>);</span><br><span class="line">	Insert(H,<span class="number">11</span>);</span><br><span class="line">	Insert(H,<span class="number">22</span>);</span><br><span class="line">	Insert(H,<span class="number">88</span>);</span><br><span class="line">	Insert(H,<span class="number">99</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 99</span></span><br><span class="line"><span class="comment">		/  \</span></span><br><span class="line"><span class="comment">	   88  66</span></span><br><span class="line"><span class="comment">	  / \  / \</span></span><br><span class="line"><span class="comment">	 55 11 22 44</span></span><br><span class="line"><span class="comment">	/ </span></span><br><span class="line"><span class="comment">   33	  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	LevelOrderTraversal(H);</span><br><span class="line">	DeleteMax(H);</span><br><span class="line">	LevelOrderTraversal(H);</span><br><span class="line">	DeleteMax(H);</span><br><span class="line">	LevelOrderTraversal(H);</span><br><span class="line">	DeleteMax(H);</span><br><span class="line">	LevelOrderTraversal(H);</span><br><span class="line">	DeleteMax(H);</span><br><span class="line">	LevelOrderTraversal(H);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124</span></span><br></pre></td></tr></table></figure>
<h5 id="3-最小堆的建立"><a href="#3-最小堆的建立" class="headerlink" title="3. 最小堆的建立"></a>3. 最小堆的建立</h5><p>不是初始化堆啦！<br>堆的建立：将<strong>已经存在的 N 个元素</strong>按最小堆的要求存放在一个一维数组中</p>
<h6 id="0-注意"><a href="#0-注意" class="headerlink" title="0. 注意"></a>0. 注意</h6><p>对于一组相同数据，插入建堆和调整建堆建出来的堆也许不一样</p>
<h6 id="1-插入建堆"><a href="#1-插入建堆" class="headerlink" title="1. 插入建堆"></a>1. 插入建堆</h6><p>通过插入，将 N 个元素一个一个相继插入到一个<strong>初始为空</strong>的堆中去，其时间代价最大是 O(NlogN)O(N logN)<em>O</em>(<em>N<strong>l</strong>o<strong>g</strong>N</em>)（每次插入是 logN，总共 N 次）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MinData = <span class="number">-100000</span>;  <span class="comment">// 哨兵值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">1005</span>;   <span class="comment">// 最大个数 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">Heap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> *data;   <span class="comment">// 存值的数组 </span></span><br><span class="line">	<span class="keyword">int</span> size;   <span class="comment">// 当前元素个数 </span></span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 最大容量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MinData = <span class="number">-100000</span>;  <span class="comment">// 哨兵值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">1005</span>;   <span class="comment">// 最大个数 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">Heap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> *data;   <span class="comment">// 存值的数组 </span></span><br><span class="line">	<span class="keyword">int</span> size;   <span class="comment">// 当前元素个数 </span></span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 最大容量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line"><span class="function">Heap <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Heap H;</span><br><span class="line">	H = (Heap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HeapStruct));</span><br><span class="line">	H-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MaxSize+<span class="number">1</span>));</span><br><span class="line">	H-&gt;size = <span class="number">0</span>;</span><br><span class="line">	H-&gt;capacity = MaxSize;</span><br><span class="line">	H-&gt;data[<span class="number">0</span>] = MinData;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Heap H,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = ++H-&gt;size;  <span class="comment">// 指向数组最后一个 </span></span><br><span class="line">	<span class="keyword">for</span>(;H-&gt;data[i/<span class="number">2</span>]&gt;x;i/=<span class="number">2</span>)</span><br><span class="line">		H-&gt;data[i] = H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">	H-&gt;data[i] = x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bl</span><span class="params">(Heap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=H-&gt;size;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;H-&gt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Heap H;</span><br><span class="line">	H = Create();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">		Insert(H,t);</span><br><span class="line">	&#125;</span><br><span class="line">	bl(H);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263</span></span><br></pre></td></tr></table></figure>
<h6 id="2-调整建堆"><a href="#2-调整建堆" class="headerlink" title="2. 调整建堆"></a>2. 调整建堆</h6><p>将 N 个元素直接按顺序存入，再调整各结点的位置（简单说来，对于从最后一个有孩子结点的结点来说，其本身结点和孩子结点共同构成”子最小堆”，借助前面删除的想法，对每个”子最小堆”排序，当排序完成，整个最小堆也建立成功），时间代价是 O(n)O(n)<em>O</em>(<em>n</em>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MinData = <span class="number">-100000</span>;  <span class="comment">// 哨兵值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">1005</span>;   <span class="comment">// 最大个数 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">Heap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> *data;   <span class="comment">// 存值的数组 </span></span><br><span class="line">	<span class="keyword">int</span> size;   <span class="comment">// 当前元素个数 </span></span><br><span class="line">	<span class="keyword">int</span> capacity;  <span class="comment">// 最大容量 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line"><span class="function">Heap <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Heap H;</span><br><span class="line">	H = (Heap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HeapStruct));</span><br><span class="line">	H-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MaxSize+<span class="number">1</span>));</span><br><span class="line">	H-&gt;size = <span class="number">0</span>;</span><br><span class="line">	H-&gt;capacity = MaxSize;</span><br><span class="line">	H-&gt;data[<span class="number">0</span>] = MinData;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序，类似堆的"删除操作" </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Heap H,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> child,parent;</span><br><span class="line">	<span class="keyword">int</span> tmp = H-&gt;data[i];  <span class="comment">// 拿到当前"根结点的值" </span></span><br><span class="line">	<span class="keyword">for</span>(parent = i;parent*<span class="number">2</span>&lt;=H-&gt;size;parent = child)&#123;</span><br><span class="line">		child = <span class="number">2</span> * parent;</span><br><span class="line">		<span class="keyword">if</span>((child!=H-&gt;size) &amp;&amp; (H-&gt;data[child+<span class="number">1</span>] &lt; H-&gt;data[child]))</span><br><span class="line">			child++;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;data[child] &gt;= tmp)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			H-&gt;data[parent] = H-&gt;data[child]; </span><br><span class="line">	&#125;</span><br><span class="line">	H-&gt;data[parent] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(Heap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i= H-&gt;size/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="comment">// 以每个有孩子结点的结点作为根结点，对其子树进行堆排序 </span></span><br><span class="line">		sort(H,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bl</span><span class="params">(Heap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=H-&gt;size;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;H-&gt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Heap H;</span><br><span class="line">	H = Create();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;H-&gt;data[++H-&gt;size];</span><br><span class="line">	adjust(H);</span><br><span class="line">	bl(H); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><h4 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1. 定义"></a>1. 定义</h4><p><strong>带权路径长度（WPL）</strong>：设二叉树有 nn<em>n</em> 个叶子结点，每个叶子结点带有权值 wkw_k<em>w**k</em>，从根结点到每个叶子结点的长度为 lkl_k<em>l**k</em>，则每个叶子结点的带权路径长度之和就是：WPL = ∑nk=1wklk\sum_{k=1}^{n}w_kl_k∑<em>k</em>=1<em>n<strong>w</strong>k<strong>l</strong>k</em></p>
<p>最优二叉树或哈夫曼树：WPL 最小的二叉树</p>
<h4 id="2-哈夫曼树的构造"><a href="#2-哈夫曼树的构造" class="headerlink" title="2. 哈夫曼树的构造"></a>2. 哈夫曼树的构造</h4><ul>
<li>每次把权值最小的两颗二叉树合并</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181105100214250.gif" alt="="></p>
<h4 id="3-哈夫曼树的特点"><a href="#3-哈夫曼树的特点" class="headerlink" title="3. 哈夫曼树的特点"></a>3. 哈夫曼树的特点</h4><ul>
<li>没有度为 1 的结点</li>
<li>n 个叶结点的哈夫曼树共有 2n-1 个结点</li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
<li>对同一组权值，可能存在不同构的多棵哈夫曼树</li>
</ul>
<h4 id="4-最小堆实现哈夫曼树"><a href="#4-最小堆实现哈夫曼树" class="headerlink" title="4. 最小堆实现哈夫曼树"></a>4. 最小堆实现哈夫曼树</h4><p>刚开始挺懵逼，堆里面怎么还出哈夫曼树了呢…看姥姥留言堆里本来就是放东西的，既然可以放数…那为什么不能放树，醍醐灌顶</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinData -1000 </span></span><br><span class="line"><span class="keyword">int</span> A[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;  <span class="comment">// 预先定义好一组权值 </span></span><br><span class="line"><span class="keyword">int</span> A_length = <span class="number">4</span>;  <span class="comment">// 定义其长度 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MinHeap</span>;</span>   </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span>  <span class="comment">// 存放哈夫曼树的堆 </span></span><br><span class="line">	HuffmanTree *data;   <span class="comment">// 存值的数组  </span></span><br><span class="line">	<span class="keyword">int</span> size;   <span class="comment">// 堆的当前大小  </span></span><br><span class="line">	<span class="keyword">int</span> capacity; <span class="comment">// 最大容量	</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span> <span class="comment">// 哈夫曼树 </span></span><br><span class="line">	<span class="keyword">int</span> weight;  <span class="comment">//权值</span></span><br><span class="line">	HuffmanTree Left;  <span class="comment">// 左子树 </span></span><br><span class="line">	HuffmanTree right; <span class="comment">// 右子树 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MinHeap <span class="title">create</span><span class="params">()</span></span>; <span class="comment">// 初始化堆</span></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Create</span><span class="params">()</span></span>; <span class="comment">// 初始化哈夫曼树 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(MinHeap H,<span class="keyword">int</span> i)</span></span>; <span class="comment">// 调整子最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(MinHeap H)</span></span>; <span class="comment">// 调整最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMinHeap</span><span class="params">(MinHeap H)</span></span>;  <span class="comment">// 建堆 </span></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span>; <span class="comment">// 删除最小堆元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree Huff)</span></span>;  <span class="comment">// 插入最小堆元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(HuffmanTree Huff)</span></span>; <span class="comment">// 先序遍历 </span></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>; <span class="comment">// 哈夫曼树的构建 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化堆</span></span><br><span class="line"><span class="function">MinHeap <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MinHeap H;</span><br><span class="line">	HuffmanTree Huff;</span><br><span class="line">	H = (MinHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HeapStruct));</span><br><span class="line">	H-&gt;data = (HuffmanTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode) * (MaxSize+<span class="number">1</span>));</span><br><span class="line">	H-&gt;capacity = MaxSize;</span><br><span class="line">	H-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 给堆置哨兵 </span></span><br><span class="line">	Huff = Create();</span><br><span class="line">	Huff-&gt;weight = MinData;</span><br><span class="line">	H-&gt;data[<span class="number">0</span>] = Huff;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化哈夫曼树 </span></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">	HuffmanTree Huff;</span><br><span class="line">	Huff = (HuffmanTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">	Huff-&gt;weight = <span class="number">0</span>;</span><br><span class="line">	Huff-&gt;Left = <span class="literal">NULL</span>;</span><br><span class="line">	Huff-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Huff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整子最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(MinHeap H,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent,child;</span><br><span class="line">	<span class="keyword">int</span> tmp = H-&gt;data[i]-&gt;weight; <span class="comment">// 取出当前"根结点"值</span></span><br><span class="line">	<span class="keyword">for</span>(parent=i;parent*<span class="number">2</span>&lt;=H-&gt;size;parent = child)&#123;</span><br><span class="line">		child = <span class="number">2</span> * parent;</span><br><span class="line">		<span class="keyword">if</span>((child!=H-&gt;size) &amp;&amp; (H-&gt;data[child+<span class="number">1</span>]-&gt;weight &lt; H-&gt;data[child]-&gt;weight))</span><br><span class="line">			child++;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;data[child]-&gt;weight &gt;= tmp)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			H-&gt;data[parent] = H-&gt;data[child];</span><br><span class="line">	&#125; </span><br><span class="line">	H-&gt;data[parent]-&gt;weight = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =H-&gt;size/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		sort(H,i);<span class="comment">// 每个"子最小堆"调整 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMinHeap</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 将权值读入堆中</span></span><br><span class="line">	HuffmanTree Huff;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A_length;i++)&#123;</span><br><span class="line">		Huff = Create();</span><br><span class="line">		Huff-&gt;weight = A[i];</span><br><span class="line">		H-&gt;data[++H-&gt;size] = Huff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整堆 </span></span><br><span class="line">	adjust(H);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最小堆元素</span></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent,child;</span><br><span class="line">	HuffmanTree T = H-&gt;data[<span class="number">1</span>];  <span class="comment">// 取出根结点的哈夫曼树 </span></span><br><span class="line">	HuffmanTree tmp = H-&gt;data[H-&gt;size--]; <span class="comment">// 取出最后一个结点哈夫曼树的权值 </span></span><br><span class="line">	<span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent = child)&#123;</span><br><span class="line">		child = <span class="number">2</span> * parent;</span><br><span class="line">		<span class="keyword">if</span>((child!=H-&gt;size) &amp;&amp; (H-&gt;data[child+<span class="number">1</span>]-&gt;weight &lt; H-&gt;data[child]-&gt;weight))</span><br><span class="line">			child++;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;data[child]-&gt;weight &gt;= tmp-&gt;weight)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			H-&gt;data[parent] = H-&gt;data[child];</span><br><span class="line">	&#125; </span><br><span class="line">	H-&gt;data[parent] = tmp;</span><br><span class="line">	<span class="comment">// 构造一个 HuffmanTree 结点，附上刚才取出来的权值，返回该结点 </span></span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree Huff)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> weight = Huff-&gt;weight; <span class="comment">// 取出权值</span></span><br><span class="line">	<span class="keyword">int</span> i = ++H-&gt;size;</span><br><span class="line">	<span class="keyword">for</span>(;H-&gt;data[i/<span class="number">2</span>]-&gt;weight &gt; weight;i/=<span class="number">2</span>)</span><br><span class="line">		H-&gt;data[i] = H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">	H-&gt;data[i] = Huff;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(HuffmanTree Huff)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Huff)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Huff-&gt;weight&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		PreOrderTraversal(Huff-&gt;Left);</span><br><span class="line">		PreOrderTraversal(Huff-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼树的构造 </span></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>&#123;</span><br><span class="line">	HuffmanTree T;</span><br><span class="line">	BuildMinHeap(H); <span class="comment">// 建堆 </span></span><br><span class="line">	<span class="keyword">int</span> times = H-&gt;size;</span><br><span class="line">	<span class="comment">// 做 times-1 次合并 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;times;i++)&#123;</span><br><span class="line">		T = (HuffmanTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">		T-&gt;Left = Delete(H);   <span class="comment">// 从堆中删除一个结点，作为新 T 的左子结点 </span></span><br><span class="line">		T-&gt;right = Delete(H);  <span class="comment">// 从堆中删除一个结点，作为新 T 的右子结点 </span></span><br><span class="line">		T-&gt;weight = T-&gt;Left-&gt;weight + T-&gt;right-&gt;weight; <span class="comment">// 重新计算权值 </span></span><br><span class="line">		Insert(H,T);  <span class="comment">// 再加进堆中 </span></span><br><span class="line">	&#125;</span><br><span class="line">	T = Delete(H);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MinHeap H;</span><br><span class="line">	HuffmanTree Huff; </span><br><span class="line">	H = create();</span><br><span class="line">	Huff = Huffman(H); </span><br><span class="line">	PreOrderTraversal(Huff);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="1-数组存储的基础实现"><a href="#1-数组存储的基础实现" class="headerlink" title="1. 数组存储的基础实现"></a>1. 数组存储的基础实现</h4><p>此时并查集用一个结构体存储，data 存值（下标+1），parent 存父结点下标<br>查找操作中先线性查找到需要找到的值，再循环查找其根结点<br>并操作先找到两合并数组的树根，如果不相等，把一棵树挂到另一棵树根下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElementType Data; <span class="comment">// 存值</span></span><br><span class="line">	<span class="keyword">int</span> parent;  <span class="comment">// 指向父结点 </span></span><br><span class="line">&#125;SetType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType s[],ElementType x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;  </span><br><span class="line">	<span class="comment">// 找到数组中该值对应的下标 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MaxSize &amp;&amp; s[i].Data!=x;i++);</span><br><span class="line">	<span class="keyword">if</span>(MaxSize &lt;= i) <span class="comment">// 如果没有找到，返回 -1 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// 找到该结点的根结点 </span></span><br><span class="line">	<span class="keyword">for</span>(;s[i].parent &gt;= <span class="number">0</span>;i = s[i].parent); </span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">// 返回根结点在数组 s 中的下标 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType s[],ElementType x1,ElementType x2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> root1 = Find(s,x1);  <span class="comment">// 找到 x1 的根结点下标 </span></span><br><span class="line">	<span class="keyword">int</span> root2 = Find(s,x2);  <span class="comment">// 找到 x2 的根结点下标 </span></span><br><span class="line">	<span class="comment">// 如果根结点的下标不同，说明不是一个集合</span></span><br><span class="line">	<span class="keyword">if</span>(root1 != root2)&#123;   </span><br><span class="line">		s[root1].parent = root2;   <span class="comment">// 把 x1 挂到 x2 的集合 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SetType s[MaxSize];</span><br><span class="line">	<span class="comment">// 初始化数组，父结点全部指向 -1 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">		s[i].Data = i+<span class="number">1</span>;</span><br><span class="line">		s[i].parent = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	Union(s,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	Union(s,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">	Union(s,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">	Union(s,<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">6</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">8</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</span></span><br></pre></td></tr></table></figure>
<h4 id="2-优化存储结构"><a href="#2-优化存储结构" class="headerlink" title="2. 优化存储结构"></a>2. 优化存储结构</h4><p>观察上面的结构体，其实值和数组下标差一，那可以直接把值 1 ~ n 映射为下标的 0 ~ n-1<br>查找操作直接去找其父结点<br>并操作直接把一棵树挂另一棵树上去</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SetType; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(SetType s[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">		s[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType s[],<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 直接去找父结点 </span></span><br><span class="line">	<span class="keyword">for</span>(;s[x]&gt;=<span class="number">0</span>;x = s[x]); </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType s[],<span class="keyword">int</span> x1,<span class="keyword">int</span> x2)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 直接合并 </span></span><br><span class="line">	s[x1] = x2;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 此时数组下标既做下标又存值，数组值存父结点下标 </span></span><br><span class="line">	SetType s[MaxSize];</span><br><span class="line">	Init(s);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	Union(s,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	Union(s,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">	Union(s,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">	Union(s,<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">6</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Find(s,<span class="number">8</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>
<h4 id="3-按秩归并优化-Union"><a href="#3-按秩归并优化-Union" class="headerlink" title="3. 按秩归并优化 Union"></a>3. 按秩归并优化 Union</h4><p>当多次并操作时，其中一个操作数固定，另一个操作数一直递增或一直递减时，树会退化成单链表</p>
<h5 id="1-根据树高归并"><a href="#1-根据树高归并" class="headerlink" title="1. 根据树高归并"></a>1. 根据树高归并</h5><p>一种解决办法是每次将 “矮” 的树挂到 “高”树上去<br><strong>树高</strong>信息存储在根结点的数组值中（之前根结点的数组值都存的 -1，现在存 -树高）<br>这样当”矮”树挂到”高”树上，树的高度不会增加，只有当两棵树一样高，高度才+1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并，假设此时 x1 x2 已经分别是根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType s[],<span class="keyword">int</span> x1,<span class="keyword">int</span> x2)</span></span>&#123;</span><br><span class="line">	<span class="comment">// x1 更高，负数啊！ </span></span><br><span class="line">	<span class="keyword">if</span>(s[x1] &lt; s[x2])&#123;</span><br><span class="line">		s[x2] = x1;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 树高相等 </span></span><br><span class="line">		<span class="keyword">if</span>(s[x1] == s[x2])</span><br><span class="line">		   s[x2]--;  <span class="comment">// 树高 +1 ，是负数 </span></span><br><span class="line">		s[x1] = x2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<h5 id="2-根据规模归并"><a href="#2-根据规模归并" class="headerlink" title="2. 根据规模归并"></a>2. 根据规模归并</h5><p>另一种解决办法是规模小的树挂到规模更高的树上去<br><strong>规模</strong>信息存储在根结点的数组值中（之前根结点的数组值都存的 -1，现在存 -元素个数）<br>这样当小树挂到大树上，只有较少的树会高一层</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并，假设此时 x1 x2 已经分别是根</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType s[],<span class="keyword">int</span> x1,<span class="keyword">int</span> x2)</span></span>&#123;</span><br><span class="line">	<span class="comment">// x1 规模更大，负数啊！ </span></span><br><span class="line">	<span class="keyword">if</span>(s[x1] &lt; s[x2])&#123;</span><br><span class="line">		s[x1] += s[x2];    <span class="comment">//  两树合并，规模相加 </span></span><br><span class="line">		s[x2] = x1;   <span class="comment">// x2 挂到 x1 上 </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		s[x2] += s[x1];   <span class="comment">//  两树合并，规模相加 </span></span><br><span class="line">		s[x1] = x2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<h4 id="4-路径压缩优化-Find"><a href="#4-路径压缩优化-Find" class="headerlink" title="4. 路径压缩优化 Find"></a>4. 路径压缩优化 Find</h4><p>查找不可避免的越查越深，路径压缩可以把待查找结点与根结点之间的一系列结点的上一结点都变为根结点，即当查找 D 后：<br><img src="https://img-blog.csdnimg.cn/20181107200837443.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType s[],<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[x] &lt; <span class="number">0</span>)  <span class="comment">// 本身已经是根 </span></span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">// 1. 找到根  2. 把根变成 x 的父结点  3.再返回根 </span></span><br><span class="line">		<span class="keyword">return</span> s[x] = Find(s,s[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><h4 id="1-什么是图"><a href="#1-什么是图" class="headerlink" title="1. 什么是图"></a>1. 什么是图</h4><ul>
<li>表示”多对多”的关系</li>
<li>包含<ul>
<li>一组顶点：通常用 V（Vertex）表示顶点集合</li>
<li>一组边：通常用 E（Edge）表示边的集合<ul>
<li>边是顶点对：（v,w）∈ E，其中 v,w ∈ V v—w</li>
<li>有向边 <v,w> 表示从 v 指向 w 的边（单行线） v→w</v,w></li>
<li>不考虑重边和自回路</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-常见术语"><a href="#2-常见术语" class="headerlink" title="2. 常见术语"></a>2. 常见术语</h4><ul>
<li>无向图：图中所有的边无所谓方向</li>
<li>有向图：图中的边可能是双向，也可能是单向的，方向是很重要的</li>
<li>权值：给图中每条边赋予的值，可能有各种各样的现实意义</li>
<li>网络：带权值的图</li>
<li>邻接点：有边直接相连的顶点</li>
<li>出度：从某顶点发出的边数</li>
<li>入度：指向某顶点的边数</li>
<li>稀疏图：顶点很多而边很少的图</li>
<li>稠密图：顶点多边也多的图</li>
<li>完全图：对于给定的一组顶点，顶点间都存在边</li>
</ul>
<h4 id="3-抽象数据类型定义"><a href="#3-抽象数据类型定义" class="headerlink" title="3. 抽象数据类型定义"></a>3. 抽象数据类型定义</h4><ul>
<li><p>类型名称：图（Graph）</p>
</li>
<li><p>数据对象集：G（V，E）由一个非空的有限顶点集合 V 和一个有限边集合 E 组成</p>
</li>
<li><p>操作集：对于任意图 G ∈ Graph，以及 v ∈ V，e ∈ E</p>
<p>主要操作有：</p>
<ul>
<li><code>Graph Crate()</code>：建立并返回空图</li>
<li><code>Graph InsertVertex(Graph G,Vertex v)</code>：将 v 插入 G</li>
<li><code>Graph InsertEdge(Graph G,Edge e)</code>：将 e 插入 G</li>
<li><code>void DFS(Graph G,Vertex v)</code>：从顶点 v 出发深度优先遍历图 G</li>
<li><code>void BFS(Graph G,Vertex v)</code>：从顶点 v 出发宽度优先遍历图 G</li>
</ul>
</li>
</ul>
<h5 id="1-邻接矩阵表示"><a href="#1-邻接矩阵表示" class="headerlink" title="1. 邻接矩阵表示"></a>1. 邻接矩阵表示</h5><ul>
<li><p>邻接矩阵$G[N][N]$——N 个顶点从 0 到 N-1 编号</p>
<script type="math/tex; mode=display">
\begin{equation}G[i][j]=\left\{\begin{array}{ll}
1 & \text { 若 }<v_{i}, v_{j}>\text { 是 } G \text { 中的边 } \\
0 & \text { 否则 }
\end{array}\right.\end{equation}</script><p><img src="https://img-blog.csdnimg.cn/20181113150234459.jpg" alt="img"></p>
</li>
<li><p>特征：</p>
<ul>
<li>对角线元素全 0</li>
<li>关于对角线对称</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有邻接点</li>
<li>方便计算任一顶点的度<ul>
<li>无向图：对应行（或列）非 0 元素的个数</li>
<li>有向图：对应行非 0 元素的个数是出度；对应列非 0 元素的个数是入度</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>浪费空间——存稀疏图</li>
<li>浪费时间——统计稀疏图的边</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> weightType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">ptrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span>   <span class="comment">// 图 </span></span><br><span class="line">	<span class="keyword">int</span> Nv;   <span class="comment">// 顶点数 </span></span><br><span class="line">	<span class="keyword">int</span> Ne;   <span class="comment">// 边数</span></span><br><span class="line">	weightType G[MaxVertexNum][MaxVertexNum];</span><br><span class="line">	DataType Data[MaxVertexNum]; <span class="comment">// 存顶点的数据 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">typedef</span> ptrToGNode MGraph;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">ptrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span>  <span class="comment">// 边 </span></span><br><span class="line">	Vertex V1,V2;    <span class="comment">// 有向边&lt;V1,V2&gt; </span></span><br><span class="line">	weightType Weight;  <span class="comment">// 权重 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ptrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图 </span></span><br><span class="line"><span class="function">MGraph <span class="title">Create</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">	Vertex v,w;</span><br><span class="line">	MGraph Graph;</span><br><span class="line">	</span><br><span class="line">	Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">	Graph-&gt;Nv = VertexNum;</span><br><span class="line">	Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;VertexNum;v++)</span><br><span class="line">		<span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;VertexNum;w++)</span><br><span class="line">			Graph-&gt;G[v][w] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入边 </span></span><br><span class="line"><span class="function">MGraph <span class="title">Insert</span><span class="params">(MGraph Graph,Edge E)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 插入边 &lt;V1,V2&gt;</span></span><br><span class="line">	Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果是无向图，还需要插入边 &lt;V2,V1&gt;</span></span><br><span class="line">	Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图 </span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MGraph Graph;</span><br><span class="line">	Edge E;</span><br><span class="line">	Vertex V;</span><br><span class="line">	<span class="keyword">int</span> Nv,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);   <span class="comment">// 读入顶点数 </span></span><br><span class="line">	Graph = Create(Nv);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(Graph-&gt;Ne));  <span class="comment">// 读入边数 </span></span><br><span class="line">	<span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>)&#123;   </span><br><span class="line">		E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);  <span class="comment">// 读入每个边的数据 </span></span><br><span class="line">			Insert(Graph,E);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(MGraph Graph)</span></span>&#123;</span><br><span class="line">	Vertex v,w;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;Graph-&gt;Nv;v++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;Graph-&gt;Nv;w++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,Graph-&gt;G[v][w]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MGraph Graph;</span><br><span class="line">	Graph = BuildGraph();</span><br><span class="line">	<span class="built_in">print</span>(Graph);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182</span></span><br></pre></td></tr></table></figure>
<p>简洁版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN],Nv,Ne;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,v1,v2,w;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">	<span class="comment">// 初始化图 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Nv;i++) </span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Nv;j++)</span><br><span class="line">			G[i][j] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">	<span class="comment">// 插入边 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;w);</span><br><span class="line">		G[v1][v2] = w;</span><br><span class="line">		G[v2][v1] = w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Nv;j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,G[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	BuildGraph();</span><br><span class="line">	<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure>
<h5 id="2-邻接表表示"><a href="#2-邻接表表示" class="headerlink" title="2. 邻接表表示"></a>2. 邻接表表示</h5><ul>
<li><p>邻接表：G[N] 为指针数组，对应矩阵每行一个链表，只存非 0 元素</p>
<p><img src="https://img-blog.csdnimg.cn/2018111315021063.jpg" alt="img"></p>
</li>
<li><p>特点：</p>
<ul>
<li>方便找任一顶点的所有邻接顶点</li>
<li>节省稀疏图的空间<ul>
<li>需要 N 个头指针 + 2E 个结点（每个结点至少 2 个域）</li>
</ul>
</li>
<li>对于是否方便计算任一顶点的度<ul>
<li>无向图：方便</li>
<li>有向图：只能计算出度</li>
</ul>
</li>
<li>不方便检查任意一对顶点间是否存在边</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> weightType;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">ptrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span>  <span class="comment">// 边 </span></span><br><span class="line">	Vertex V1,V2;    <span class="comment">// 有向边&lt;V1,V2&gt; </span></span><br><span class="line">	weightType Weight;  <span class="comment">// 权重 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ptrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span> *<span class="title">ptrToAdjVNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>&#123;</span>  <span class="comment">// 邻接表内元素 </span></span><br><span class="line">	Vertex AdjV;  <span class="comment">// 邻接点下标 </span></span><br><span class="line">	weightType Weight;  <span class="comment">// 权值 </span></span><br><span class="line">	ptrToAdjVNode Next;  <span class="comment">// 下一个 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>  <span class="comment">// 邻接表头 </span></span><br><span class="line">	ptrToAdjVNode FirstEdge;  <span class="comment">// 存每个顶点指针</span></span><br><span class="line">	DataType Data;  <span class="comment">// 顶点数据 </span></span><br><span class="line">&#125;AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">ptrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span>  <span class="comment">// 图 </span></span><br><span class="line">	<span class="keyword">int</span> Nv;  <span class="comment">// 顶点</span></span><br><span class="line">	<span class="keyword">int</span> Ne;  <span class="comment">// 边数 </span></span><br><span class="line">	AdjList G; <span class="comment">// 邻接表 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">typedef</span> ptrToGNode LGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="function">LGraph <span class="title">create</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">	Vertex v,w;</span><br><span class="line">	LGraph Graph;</span><br><span class="line">	</span><br><span class="line">	Graph = (LGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">	Graph-&gt;Nv = VertexNum;  <span class="comment">// 初始化边</span></span><br><span class="line">	Graph-&gt;Ne = <span class="number">0</span>;   <span class="comment">// 初始化点</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 每条边的 FirstEdge 指向 NULL </span></span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;Graph-&gt;Nv;v++)</span><br><span class="line">		Graph-&gt;G[v].FirstEdge = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条边到邻接表的顶点指针之后 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(LGraph Graph,Edge E)</span></span>&#123;</span><br><span class="line">	ptrToAdjVNode newNode; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**************** 插入边&lt;V1,V2&gt; ******************/</span> </span><br><span class="line">	<span class="comment">// 为 V2 建立新的结点 </span></span><br><span class="line">	newNode = (ptrToAdjVNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">	newNode-&gt;AdjV = E-&gt;V2;</span><br><span class="line">	newNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将 V2 插入到邻接表头 </span></span><br><span class="line">	newNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class="line">	Graph-&gt;G[E-&gt;V1].FirstEdge = newNode;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*************** 若为无向图，插入边&lt;V2,V1&gt; *************/</span> </span><br><span class="line">	newNode = (ptrToAdjVNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">	newNode-&gt;AdjV = E-&gt;V1;</span><br><span class="line">	newNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">	</span><br><span class="line">	newNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class="line">	Graph-&gt;G[E-&gt;V2].FirstEdge = newNode;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图</span></span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LGraph Graph;</span><br><span class="line">	Edge E;</span><br><span class="line">	Vertex V;</span><br><span class="line">	<span class="keyword">int</span> Nv,i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">	Graph = create(Nv);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(Graph-&gt;Ne));</span><br><span class="line">	<span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">			E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">			InsertEdge(Graph,E);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Graph;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(LGraph Graph)</span></span>&#123;</span><br><span class="line">	Vertex v;</span><br><span class="line">	ptrToAdjVNode tmp;</span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;Graph-&gt;Nv;v++)&#123;</span><br><span class="line">		tmp = Graph-&gt;G[v].FirstEdge;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,v);</span><br><span class="line">		<span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,tmp-&gt;AdjV);</span><br><span class="line">			tmp = tmp-&gt;Next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LGraph Graph;</span><br><span class="line">	Graph = BuildGraph();</span><br><span class="line">	<span class="built_in">print</span>(Graph);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112</span></span><br></pre></td></tr></table></figure>
<p>简化版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span> *<span class="title">AdjList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> weight;  <span class="comment">// 权值 </span></span><br><span class="line">  	<span class="keyword">int</span> adjv;   <span class="comment">// 下标 </span></span><br><span class="line">	AdjList next;  <span class="comment">// 其后一个 </span></span><br><span class="line">&#125;;</span><br><span class="line">AdjList Graph[MaxVertexNum];</span><br><span class="line"><span class="keyword">int</span> Ne,Nv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> v1,v2,w;</span><br><span class="line">	AdjList NewNode;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line">		Graph[i] = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">		Graph[i]-&gt;adjv = i;</span><br><span class="line">		Graph[i]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;w);</span><br><span class="line">		NewNode = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">		NewNode-&gt;adjv = v1;</span><br><span class="line">		NewNode-&gt;weight = w;</span><br><span class="line">		</span><br><span class="line">		NewNode-&gt;next = Graph[v2]-&gt;next;</span><br><span class="line">		Graph[v2]-&gt;next = NewNode;</span><br><span class="line">		</span><br><span class="line">		NewNode = (AdjList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AdjVNode));</span><br><span class="line">		NewNode-&gt;adjv = v2;</span><br><span class="line">		NewNode-&gt;weight = w;</span><br><span class="line">		</span><br><span class="line">		NewNode-&gt;next = Graph[v1]-&gt;next;</span><br><span class="line">		Graph[v1]-&gt;next = NewNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	AdjList tmp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line">		tmp = Graph[i];</span><br><span class="line">		<span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,tmp-&gt;adjv);</span><br><span class="line">			tmp = tmp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	BuildGraph();</span><br><span class="line">	<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="1-DFS"><a href="#1-DFS" class="headerlink" title="1. DFS"></a>1. DFS</h4><p>深度优先搜索（Depth First Search)，类似于树的先序遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">( Vertex V )</span></span>&#123;</span><br><span class="line">    visited[ V ] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( V 的每个邻接点 W )</span><br><span class="line">        <span class="keyword">if</span>( !visited[ W ])</span><br><span class="line">            DFS( W );</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>若有 N 个顶点、E 条边，时间复杂度是</p>
<ul>
<li>用邻接表存储，O(N + E)</li>
<li>用邻接矩阵存储，O(N2^22)</li>
</ul>
<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="2. BFS"></a>2. BFS</h4><p>广度优先搜索（Breadth First Search)，相当于树的层序遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">( Vertex V )</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Vertex&gt; q;</span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    q.push(V);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        V = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>( V 的每个邻接点 W )&#123;</span><br><span class="line">        	<span class="keyword">if</span>( !visited[ W ])&#123;</span><br><span class="line">            	visited[W] = <span class="literal">true</span>;s</span><br><span class="line">            	q.push(W);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>若有 N 个顶点、E 条边，时间复杂度是</p>
<ul>
<li>用邻接表存储，O(N + E)</li>
<li>用邻接矩阵存储，$O(n^{2})$</li>
</ul>
<h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><h5 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1. 抽象"></a>1. 抽象</h5><p>在网络（带权图）中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径</p>
<ul>
<li>这条路径就是两点之间的<strong>最短路径</strong>（ShorttestPath）</li>
<li>第一个顶点为<strong>源点</strong>（Source）</li>
<li>最后一个顶点为<strong>终点</strong>（Destination）</li>
</ul>
<h5 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h5><ul>
<li><p>单源</p>
<p>最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径</p>
<ul>
<li>（有向）无权图</li>
<li>（有向）有权图</li>
</ul>
</li>
<li><p><strong>多源</strong>最短路径问题：求任意两顶点间的最短路径</p>
</li>
</ul>
<h4 id="2-无权图的单源最短路算法"><a href="#2-无权图的单源最短路算法" class="headerlink" title="2. 无权图的单源最短路算法"></a>2. 无权图的单源最短路算法</h4><p>按照递增（非递减）的顺序找出到各个顶点的最短路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unweighted</span><span class="params">( Vertex s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Vertex&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    wile(!q.empty())&#123;</span><br><span class="line">        v = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>( V 的每个临界点 W)&#123;</span><br><span class="line">            dist[W] = dist[v] + <span class="number">1</span>; <span class="comment">// 当前距离上一距离 + 1</span></span><br><span class="line">            path[W] = v;  <span class="comment">// s 到 w 的必经顶点就是前一个顶点 v</span></span><br><span class="line">            q.push(W);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-有权图的单源最短路算法"><a href="#3-有权图的单源最短路算法" class="headerlink" title="3. 有权图的单源最短路算法"></a>3. 有权图的单源最短路算法</h4><h5 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h5><ul>
<li>令 S = {源点s + 已经确定了最短路径的顶点 $v_i$}</li>
<li>对任一未收录的顶点 v，定义 dist[v] 为 s 到 v 的最短路径长度，但该路径仅经过 S 中的顶点。即路径 {s→($v_i$∈S)→v} 的最小长度</li>
<li>若路径是按照递增（非递减）的顺序生成的，则<ul>
<li>真正的最短路必须只经过 S 中的顶点</li>
<li>每次从未收录的顶点中选一个 dist 最小的收录</li>
<li>增加一个 v 进入 S，可能影响另外一个 w 的 dist 值<ul>
<li>dist[w] = min{dist[w],dist[v] + <v,w>的权重}</v,w></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">( Vertex s )</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        V = 未收录顶点中dist最小值;</span><br><span class="line">        <span class="keyword">if</span>( 这样的V不存在 )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        collected[V] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( V 的每个邻接点 W )</span><br><span class="line">            <span class="keyword">if</span>( collected[W] == <span class="literal">false</span> )</span><br><span class="line">                <span class="keyword">if</span>(dist[V] + E&lt;V,W&gt; &lt; dist[W])&#123;</span><br><span class="line">             		dist[W] = dist[V] + E&lt;V,W&gt;;</span><br><span class="line">                    path[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出未收录顶点中dist最小值 和 更新dist[W]的操作可以考虑两种方法：</p>
<ol>
<li><p>直接扫描所有未收录顶点 ——O(|V|)</p>
<p>T = O($|V|^2$ + |E|) ——稠密图效果更好</p>
</li>
<li><p>将dist存在最小堆中 ——O(log|V|)</p>
<p>更新dist[w]的值 —O(log|V|)</p>
<p>T = O(|E|log|V|) —— 稀疏图效果更好</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Init -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"><span class="keyword">int</span> G[MaxVertex][MaxVertex];</span><br><span class="line"><span class="keyword">int</span> dist[MaxVertex];  <span class="comment">// 距离 </span></span><br><span class="line"><span class="keyword">int</span> path[MaxVertex];  <span class="comment">// 路径 </span></span><br><span class="line"><span class="keyword">int</span> collected[MaxVertex];  <span class="comment">// 被收录集合 </span></span><br><span class="line"><span class="keyword">int</span> Nv;   <span class="comment">// 顶点 </span></span><br><span class="line"><span class="keyword">int</span> Ne;   <span class="comment">// 边 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Vertex v1,v2;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;Nv;</span><br><span class="line">	<span class="comment">// 初始化图 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">			G[i][j] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 初始化路径 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		path[i] = Init;</span><br><span class="line">	<span class="comment">// 初始化距离</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Nv;i++)</span><br><span class="line">		dist[i] = Inf;</span><br><span class="line">	<span class="comment">// 初始化收录情况 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		collected[i] = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;Ne;</span><br><span class="line">	<span class="comment">// 初始化点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">		G[v1][v2] = w;  <span class="comment">// 有向图 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化距离和路径信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crate</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	collected[s] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">if</span>(G[s][i])&#123;</span><br><span class="line">			dist[i] = G[s][i];</span><br><span class="line">			path[i] = s;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找未收录顶点中dist最小者</span></span><br><span class="line"><span class="function">Vertex <span class="title">FindMin</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = <span class="number">0</span>;  <span class="comment">// 之前特地把 dist[0] 初始化为正无穷 </span></span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">if</span>(i != s &amp;&amp; dist[i] &lt; dist[min] &amp;&amp; !collected[i])</span><br><span class="line">			min = i;</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">	crate(s); </span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		Vertex V = FindMin(s);   <span class="comment">// 找到 </span></span><br><span class="line">		<span class="keyword">if</span>(!V)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		collected[V] = <span class="literal">true</span>;  <span class="comment">//收录</span></span><br><span class="line">		<span class="keyword">for</span>(Vertex W=<span class="number">1</span>;W&lt;=Nv;W++)</span><br><span class="line">			<span class="keyword">if</span>(!collected[W] &amp;&amp; G[V][W])&#123;  <span class="comment">// 如果未被收录</span></span><br><span class="line">				<span class="keyword">if</span>(dist[V] + G[V][W] &lt; dist[W])&#123;</span><br><span class="line">					dist[W] = G[V][W] + dist[V];</span><br><span class="line">					path[W] = V;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dist[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;path[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	build();</span><br><span class="line">	Dijkstra(<span class="number">1</span>);</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-多源最短路算法"><a href="#4-多源最短路算法" class="headerlink" title="4. 多源最短路算法"></a>4. 多源最短路算法</h4><ul>
<li><p>直接将单源最短路算法调用|V|遍</p>
<p>T = O($|V|^3$ + |E|×|V|) ——对于稀疏图效果好</p>
</li>
<li><p>Floyd 算法</p>
<p>T = O($|V|^3$) ——对于稠密图效果好</p>
</li>
</ul>
<h5 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h5><ul>
<li>$D^k[i][j]$= 路径{ i →{$l$≤ $k$} → j } 的最小长度</li>
<li>$D^0,D^1,…,D^{|V|-1}[i][j]$即给出了 i 到 j 的真正最短距离</li>
<li>最初的 $D^{-1}$ 是全 0 的邻接矩阵</li>
<li>若 i 和 j 不直接相连，初始化为无穷大</li>
<li>当 $D^{k-1}$已经完成，递推到 $D^k$时：<ul>
<li>或者 k 不属于 最短路径 { i →{$ l$ ≤ $k$ } → j }，则 </li>
<li>或者$ k $属于最短路径 { i →{ $l≤ $$k$} → j }，则该路径必定由两段最短路径组成：$D^k[i][j]=D^{k-1}[i][k]+D^{k-1}[k][j]$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; N; i++ )</span><br><span class="line">        <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; N; j++ )&#123;</span><br><span class="line">            D[i][j] = G[i][j];</span><br><span class="line">            path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; N; k++ )</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i&lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; N; j++ )</span><br><span class="line">            	<span class="keyword">if</span>( D[i][k] + D[k][j] &lt; D[i][j] ) &#123;</span><br><span class="line">            		D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"><span class="keyword">int</span> G[MaxVertex][MaxVertex];</span><br><span class="line"><span class="keyword">int</span> dist[MaxVertex][MaxVertex];  <span class="comment">// 距离 </span></span><br><span class="line"><span class="keyword">int</span> path[MaxVertex][MaxVertex];  <span class="comment">// 路径 </span></span><br><span class="line"><span class="keyword">int</span> Nv;   <span class="comment">// 顶点 </span></span><br><span class="line"><span class="keyword">int</span> Ne;   <span class="comment">// 边 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Vertex v1,v2;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;Nv;</span><br><span class="line">	<span class="comment">// 初始化图 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">			G[i][j] = INF;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;Ne;</span><br><span class="line">	<span class="comment">// 初始化点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">		G[v1][v2] = w;  </span><br><span class="line">		G[v2][v1] = w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">for</span>(Vertex j=<span class="number">1</span>;j&lt;=Nv;j++)&#123;</span><br><span class="line">			dist[i][j] = G[i][j];</span><br><span class="line">			path[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(Vertex k=<span class="number">1</span>;k&lt;=Nv;k++)</span><br><span class="line">		<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">			<span class="keyword">for</span>(Vertex j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">				<span class="keyword">if</span>(dist[i][k] + dist[k][j] &lt; dist[i][j])&#123;</span><br><span class="line">					dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">					path[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)&#123; </span><br><span class="line">		<span class="keyword">for</span>(Vertex j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dist[i][j]&lt;&lt;<span class="string">" "</span>;	</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)&#123; </span><br><span class="line">		<span class="keyword">for</span>(Vertex j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;path[i][j]&lt;&lt;<span class="string">" "</span>;	</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	build();</span><br><span class="line">	Floyd();</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h3><h4 id="1-什么是最小生成树"><a href="#1-什么是最小生成树" class="headerlink" title="1. 什么是最小生成树"></a>1. 什么是最小生成树</h4><ul>
<li><p>是一棵</p>
<p>树</p>
<ul>
<li>无回路</li>
<li>|V|个顶点一定有 |V|-1 条边</li>
</ul>
</li>
<li><p>是</p>
<p>生成</p>
<p>树</p>
<ul>
<li>不唯一</li>
<li>包含全部顶点</li>
<li>|V|-1 条边都在图里</li>
</ul>
</li>
<li><p>边的权值和<strong>最小</strong></p>
</li>
</ul>
<h4 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2. 贪心算法"></a>2. 贪心算法</h4><ul>
<li>什么是 “贪”：每一步都是最好的</li>
<li>什么是 “好”：权重最小的边</li>
<li>需要约束：<ul>
<li>只能用图里有的边</li>
<li>只能正好用掉 |V|-1 条边</li>
<li>不能有回路</li>
</ul>
</li>
</ul>
<h5 id="1-Prim-算法"><a href="#1-Prim-算法" class="headerlink" title="1. Prim 算法"></a>1. Prim 算法</h5><p><img src="https://img-blog.csdnimg.cn/20181118171739821.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MST = &#123;s&#125;;  <span class="comment">// parent[s] = -1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        V = 未收录顶点中dist最小者;   <span class="comment">// dist[V] = E&lt;V,W&gt; 或 正无穷</span></span><br><span class="line">        <span class="keyword">if</span> ( 这样的V不存在 )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dist[V] = <span class="number">0</span>;  <span class="comment">// 将V收录进MST</span></span><br><span class="line">        <span class="keyword">for</span> ( V 的每个邻接点 W )</span><br><span class="line">            <span class="keyword">if</span> ( dist[W]!= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> ( E&lt;V,W&gt; &lt; dist[w] )&#123;</span><br><span class="line">                    dist[W] = E&lt;V,W&gt;;</span><br><span class="line">                    parent[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( MST 中收的顶点不到|V|个)</span><br><span class="line">        Error ( <span class="string">"图不连通"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：T = O($|V|^2$) —— 稠密图合算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 105</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex; </span><br><span class="line"><span class="keyword">int</span> G[MaxVertex][MaxVertex];</span><br><span class="line"><span class="keyword">int</span> parent[MaxVertex];   <span class="comment">// 并查集 </span></span><br><span class="line"><span class="keyword">int</span> dist[MaxVertex]; <span class="comment">// 距离 </span></span><br><span class="line"><span class="keyword">int</span> Nv;    <span class="comment">// 结点 </span></span><br><span class="line"><span class="keyword">int</span> Ne;    <span class="comment">// 边 </span></span><br><span class="line"><span class="keyword">int</span> sum;  <span class="comment">// 权重和 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="built_in">vector</span>&lt;Vertex&gt; MST;  <span class="comment">// 最小生成树 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Vertex v1,v2;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;Nv&gt;&gt;Ne;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">			G[i][j] = <span class="number">0</span>;  <span class="comment">// 初始化图 </span></span><br><span class="line">		dist[i] = INF;   <span class="comment">// 初始化距离</span></span><br><span class="line">		parent[i] = <span class="number">-1</span>;  <span class="comment">// 初始化并查集 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">		G[v1][v2] = w;</span><br><span class="line">		G[v2][v1] = w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prim算法前的初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IniPrim</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	MST.push_back(s);</span><br><span class="line">	<span class="keyword">for</span>(Vertex i =<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">if</span>(G[s][i])&#123;</span><br><span class="line">			dist[i] = G[s][i];</span><br><span class="line">			parent[i] = s;</span><br><span class="line">		&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找未收录中dist最小的点 </span></span><br><span class="line"><span class="function">Vertex <span class="title">FindMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = INF;</span><br><span class="line">	Vertex xb = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="keyword">if</span>(dist[i] &amp;&amp; dist[i] &lt; min)&#123; </span><br><span class="line">			min = dist[i];</span><br><span class="line">			xb = i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> xb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"被收录顺序："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;MST[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"权重和为："</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"该生成树为："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;parent[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">	IniPrim(s);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		Vertex v = FindMin();</span><br><span class="line">		<span class="keyword">if</span>(v == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		sum += dist[v];</span><br><span class="line">		dist[v] = <span class="number">0</span>;</span><br><span class="line">		MST.push_back(v);</span><br><span class="line">		<span class="keyword">for</span>(Vertex w=<span class="number">1</span>;w&lt;=Nv;w++)</span><br><span class="line">			<span class="keyword">if</span>(G[v][w] &amp;&amp; dist[w])</span><br><span class="line">				<span class="keyword">if</span>(G[v][w] &lt; dist[w])&#123;</span><br><span class="line">					dist[w] = G[v][w];</span><br><span class="line">					parent[w] = v;</span><br><span class="line">				&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	build();</span><br><span class="line">	Prim(<span class="number">1</span>);</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091</span></span><br></pre></td></tr></table></figure>
<h5 id="2-Kruskal-算法"><a href="#2-Kruskal-算法" class="headerlink" title="2. Kruskal 算法"></a>2. Kruskal 算法</h5><p><img src="https://img-blog.csdnimg.cn/20181118171601539.gif" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span> <span class="params">( Graph G )</span></span>&#123;</span><br><span class="line">    MST = &#123; &#125;;</span><br><span class="line">    <span class="keyword">while</span> ( MST 中不到|V|<span class="number">-1</span>条边 &amp;&amp;  E中还有边 ) &#123;</span><br><span class="line">        从 E 中取一条权重最小的边 E&lt;V,W&gt;;    <span class="comment">// 最小堆</span></span><br><span class="line">        将 E&lt;V,W&gt; 从 E 中删除;</span><br><span class="line">        <span class="keyword">if</span> ( E&lt;V,W&gt; 不在 MST 中构成回路 )  <span class="comment">// 并查集</span></span><br><span class="line">            将 E&lt;V,W&gt; 加入MST;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            彻底无视 E&lt;V,W&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( MST 中不到|V|<span class="number">-1</span>条边 )</span><br><span class="line">        Error(<span class="string">"图不连通"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：T = O(|E|log|E|) —— 稀疏图合算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertex 105</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex; </span><br><span class="line"><span class="keyword">int</span> G[MaxVertex][MaxVertex];</span><br><span class="line"><span class="keyword">int</span> parent[MaxVertex];   <span class="comment">// 并查集最小生成树 </span></span><br><span class="line"><span class="keyword">int</span> Nv;    <span class="comment">// 结点 </span></span><br><span class="line"><span class="keyword">int</span> Ne;    <span class="comment">// 边 </span></span><br><span class="line"><span class="keyword">int</span> sum;  <span class="comment">// 权重和 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	Vertex v1;</span><br><span class="line">	Vertex v2;</span><br><span class="line">	<span class="keyword">int</span> weight; <span class="comment">// 权重 </span></span><br><span class="line">	<span class="comment">// 重载运算符成最大堆 </span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> weight&gt;a.weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; MST;  <span class="comment">// 最小生成树 </span></span><br><span class="line">priority_queue&lt;Node&gt; q;   <span class="comment">// 最小堆 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化图信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Vertex v1,v2;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;Nv&gt;&gt;Ne;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Nv;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Nv;j++)</span><br><span class="line">			G[i][j] = <span class="number">0</span>;  <span class="comment">// 初始化图</span></span><br><span class="line">		parent[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">tmpE</span>;</span></span><br><span class="line">		tmpE.v1 = v1;</span><br><span class="line">		tmpE.v2 = v2;</span><br><span class="line">		tmpE.weight = w;</span><br><span class="line">		q.push(tmpE); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  路径压缩查找 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(parent[x] &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> parent[x] = Find(parent[x]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//  按秩归并 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> x2)</span></span>&#123;</span><br><span class="line">    x1 = Find(x1);</span><br><span class="line">    x2 = Find(x2);</span><br><span class="line">	<span class="keyword">if</span>(parent[x1] &lt; parent[x2])&#123;</span><br><span class="line">		parent[x1] += parent[x2];</span><br><span class="line">		parent[x2] = x1;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		parent[x2] += parent[x1];</span><br><span class="line">		parent[x1] = x2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 最小生成树的边不到 Nv-1 条且还有边 </span></span><br><span class="line">	<span class="keyword">while</span>(MST.size()!= Nv<span class="number">-1</span> &amp;&amp; !q.empty())&#123;</span><br><span class="line">		Node E = q.top();  <span class="comment">// 从最小堆取出一条权重最小的边</span></span><br><span class="line">		q.pop(); <span class="comment">// 出队这条边 </span></span><br><span class="line">		<span class="keyword">if</span>(Find(E.v1) != Find(E.v2))&#123;  <span class="comment">// 检测两条边是否在同一集合 </span></span><br><span class="line">			sum += E.weight; </span><br><span class="line">			Union(E.v1,E.v2);     <span class="comment">// 并起来 </span></span><br><span class="line">			MST.push_back(E);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"被收录顺序："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">0</span>;i&lt;Nv;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;MST[i].weight&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"权重和为："</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">for</span>(Vertex i=<span class="number">1</span>;i&lt;=Nv;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;parent[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	build();</span><br><span class="line">	Kruskal();</span><br><span class="line">	output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h3><ol>
<li>以关键字 key 为自变量，通过一个确定的函数 h（<strong>散列函数</strong>），计算出对应的函数值 h(key)，作为数据对象的存储地址</li>
<li>可能不同的关键字会映射到同一个散列地址上，即  $h(key_i)=h(key_j)$（当 $key_i$≠ $key_j$），称为“<strong>冲突</strong>”——需要某种冲突解决策略</li>
</ol>
<h3 id="2-基本工作"><a href="#2-基本工作" class="headerlink" title="2. 基本工作"></a>2. 基本工作</h3><ul>
<li><strong>计算位置</strong>：构造散列函数确定关键词存储位置</li>
<li><strong>解决冲突</strong>：应用某种策略解决多个关键词位置相同的问题</li>
</ul>
<p>时间复杂度几乎为是常数：O(1)</p>
<h3 id="3-散列函数的构造"><a href="#3-散列函数的构造" class="headerlink" title="3. 散列函数的构造"></a>3. 散列函数的构造</h3><h4 id="1-考虑因素"><a href="#1-考虑因素" class="headerlink" title="1. 考虑因素"></a>1. 考虑因素</h4><ol>
<li><strong>计算简单</strong>，以便提高转换速度</li>
<li>关键词对应的<strong>地址空间分布均匀</strong>，以尽量减少冲突</li>
</ol>
<h4 id="2-数字关键词"><a href="#2-数字关键词" class="headerlink" title="2. 数字关键词"></a>2. 数字关键词</h4><h5 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1. 直接定址法"></a>1. 直接定址法</h5><p> 取关键词的某个线性函数值为散列地址，即：h(key) = a x key + b （a、b为常数)</p>
<h5 id="2-除留余数法"><a href="#2-除留余数法" class="headerlink" title="2. 除留余数法"></a>2. 除留余数法</h5><p> 散列函数为：h(key) = key mod p （p 一般取素数)</p>
<h5 id="3-数字分析法"><a href="#3-数字分析法" class="headerlink" title="3. 数字分析法"></a>3. 数字分析法</h5><p> 分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址</p>
<h5 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4. 折叠法"></a>4. 折叠法</h5><p> 把关键词分割成位数相同的几个部分，然后叠加</p>
<h5 id="5-平方取中法"><a href="#5-平方取中法" class="headerlink" title="5. 平方取中法"></a>5. 平方取中法</h5><p> 将关键词平方，取中间几位</p>
<h4 id="3-字符串关键字"><a href="#3-字符串关键字" class="headerlink" title="3. 字符串关键字"></a>3. 字符串关键字</h4><h5 id="1-ASCII码加和法"><a href="#1-ASCII码加和法" class="headerlink" title="1. ASCII码加和法"></a>1. ASCII码加和法</h5><p> h(key) = (Σkey[i]) mod TableSize</p>
<h5 id="2-前3个字符移位法"><a href="#2-前3个字符移位法" class="headerlink" title="2. 前3个字符移位法"></a>2. 前3个字符移位法</h5><p> h(key) = (key[0]×$27^2$ + key[1]×27 + key[2])mod TableSize</p>
<h5 id="3-移位法"><a href="#3-移位法" class="headerlink" title="3. 移位法"></a>3. 移位法</h5><p> h(key) = $\begin{equation}\left(\sum_{i=0}^{n-1} \mathrm{key}[\mathrm{n}-\mathrm{i}-1] \times 32^{i}\right)\end{equation}$ mod TableSize</p>
<p>例子（移位法）</p>
<p>h(“abcde”) = ‘a’x$32^4$ + ‘b’x$32^3$ +’c’x$32^2$+ ‘d’x32 + ‘e’= (((‘a’x32+‘b’)x32+‘c’)x32+‘d’)x32+‘e’</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Index <span class="title">Hash</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *Key,<span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h = <span class="number">0</span>;   <span class="comment">// 散列值函数，初始化为 0 </span></span><br><span class="line">    <span class="keyword">while</span> ( *Key != <span class="string">'\0'</span> )    <span class="comment">// 位移映射</span></span><br><span class="line">        h = ( h &lt;&lt; <span class="number">5</span>) + *Key++;</span><br><span class="line">    <span class="keyword">return</span> h % TableSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="4-冲突处理方法"><a href="#4-冲突处理方法" class="headerlink" title="4. 冲突处理方法"></a>4. 冲突处理方法</h3><h4 id="1-常用策略"><a href="#1-常用策略" class="headerlink" title="1. 常用策略"></a>1. 常用策略</h4><ul>
<li>换个位置：<strong>开放地址法</strong></li>
<li>同一位置的冲突对象组织在一起：<strong>链地址法</strong></li>
</ul>
<h4 id="2-开放定址法"><a href="#2-开放定址法" class="headerlink" title="2. 开放定址法"></a>2. 开放定址法</h4><ul>
<li>一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一空地址</li>
<li>若发生了第 i 次冲突，试探的下一个地址将增加 di_i<em>i</em>，基本公式是： $h_i(key)=(h(key)+d_i)$mod TableSize （1 ≤ i ≤ TableSize）</li>
<li>di_i<em>i</em> 决定了不同的解决冲突方案</li>
</ul>
<h5 id="1-线性探测"><a href="#1-线性探测" class="headerlink" title="1. 线性探测"></a>1. 线性探测</h5><p> 以<strong>增量序列</strong> 1,2,…, (TableSize - 1) 循环试探下一个存储地址</p>
<h5 id="2-平方探测法"><a href="#2-平方探测法" class="headerlink" title="2. 平方探测法"></a>2. 平方探测法</h5><p> 以增量序列$1^2,-1^2,2^2,-2^2,…,q^2,-q^2$且 q ≤ ⌊ TableSize/2 ⌋ 循环试探下一个存储地址</p>
<p> 如果散列表长度是某个 4k+3（k是正整数）形式的<strong>素数</strong>时，平方探测法就可以探查到整个散列表空间</p>
<h5 id="3-双散列"><a href="#3-双散列" class="headerlink" title="3. 双散列"></a>3. 双散列</h5><p>$d_i$为$i*h_2(key)$，$h_2(key)$ 是另一个散列函数，探测序列成:$h_2(key),2h_2(key),3h_2(key)$</p>
<p> 对任意 key,$h_2(key)\neq 0$</p>
<p> $h_2(key)$ = p - (key mod p) （p &lt; TableSize，p、TableSize 都是素数）</p>
<h5 id="4-再散列"><a href="#4-再散列" class="headerlink" title="4. 再散列"></a>4. 再散列</h5><p> 当散列表元素太多（即装填因子 α 太大）时，查找效率会下降</p>
<p> 解决的方法是加倍扩大散列表，这个过程就叫”再散列”，扩大时，原有元素需要重新计算放置到新表中</p>
<h4 id="3-分离链接法"><a href="#3-分离链接法" class="headerlink" title="3. 分离链接法"></a>3. 分离链接法</h4><p> 将相应位置上冲突的所有关键词存储在同一个单链表中</p>
<h3 id="5-抽象数据类型定义-1"><a href="#5-抽象数据类型定义-1" class="headerlink" title="5. 抽象数据类型定义"></a>5. 抽象数据类型定义</h3><ul>
<li><p>数据类型：符号表（SymbolTable）</p>
</li>
<li><p>数据对象集：符号表是”名字(Name)-属性(Attribute)”对的集合</p>
</li>
<li><p>操作集：Table ∈ SymbolTable，Name ∈ NameType，Attr ∈ AttributeType</p>
<p>主要操作：</p>
<ul>
<li><code>SymbolTable InitalizeTable(int TableSize)</code>：创建一个长度为 TableSize 的符号表</li>
<li><code>Boolean IsIn(SymbolTable Table,NameType Name)</code>：查找特定的名字 Name 是否在 Table 中</li>
<li><code>AttributeType Find(SymbolTable Table,NameType Name)</code>：获取 Table 中指定名字 Name 对应的属性</li>
<li><code>SymbolTable Modefy(SymbolTable Table,NameType Name,AttributeType Attr)</code>：将 Table 中指定名字 Name 的属性修改为 Attr</li>
<li><code>SymbolTable Insert(SymbolTable Table,NameType Name,AttributeType Attr)</code>：向 Table 中插入一个新名字 Name 及其属性 Attr</li>
<li><code>SymbolTable Delete(SymbolTable Table,NameType Name)</code>：从 Table 中删除一个名字 Name 及其属性</li>
</ul>
</li>
</ul>
<h4 id="1-平方探测法实现"><a href="#1-平方探测法实现" class="headerlink" title="1. 平方探测法实现"></a>1. 平方探测法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTABLESIZE 100000   <span class="comment">// 定义允许开辟的最大散列表长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType; </span><br><span class="line"><span class="keyword">typedef</span> Index Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;   <span class="comment">// 分别对应：有合法元素、空、有已删除元素 </span></span><br><span class="line">	Legitimate,Empty,Deleted</span><br><span class="line">&#125; EntryType;  <span class="comment">// 定义单元状态类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> <span class="title">Cell</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span>&#123;</span>   <span class="comment">//  哈希表存值单元 </span></span><br><span class="line">	ElementType Data;  <span class="comment">// 存放元素</span></span><br><span class="line">	EntryType Info;  <span class="comment">// 单元状态	</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span> *<span class="title">HashTable</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>&#123;</span>  <span class="comment">// 哈希表结构体 </span></span><br><span class="line">	<span class="keyword">int</span> TableSize;   <span class="comment">// 哈希表大小 </span></span><br><span class="line">	Cell *Cells;   <span class="comment">// 哈希表存值单元数组 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextPrime</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">// 查找素数 </span></span><br><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">( <span class="keyword">int</span> TableSize)</span></span>; <span class="comment">// 创建哈希表 </span></span><br><span class="line"><span class="function">Index <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> Key,<span class="keyword">int</span> TableSize)</span></span>;   <span class="comment">// 哈希函数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找素数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextPrime</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = (N%<span class="number">2</span>)?N+<span class="number">2</span>:N+<span class="number">1</span>;  <span class="comment">// 从大于 N 的下个奇数开始</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(p &lt;= MAXTABLESIZE)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p);i&gt;<span class="number">2</span>;i--)</span><br><span class="line">			<span class="keyword">if</span>(!(p%i))  <span class="comment">// p 不是素数 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">2</span>) </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		p += <span class="number">2</span>;  <span class="comment">// 继续试探下个奇数 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈希表 </span></span><br><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">( <span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">	HashTable H;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTbl));</span><br><span class="line">	<span class="comment">// 保证哈希表最大长度是素数 </span></span><br><span class="line">	H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">	<span class="comment">// 初始化单元数组</span></span><br><span class="line">	H-&gt;Cells = (Cell *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cell)*H-&gt;TableSize);</span><br><span class="line">	<span class="comment">// 初始化单元数组状态 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++)</span><br><span class="line">		H-&gt;Cells[i].Info = Empty;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平方探测查找 </span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(HashTable H,ElementType Key)</span></span>&#123;</span><br><span class="line">	Position CurrentPos,NewPos; </span><br><span class="line">	<span class="keyword">int</span> CNum = <span class="number">0</span> ;   <span class="comment">// 记录冲突次数</span></span><br><span class="line">	CurrentPos = NewPos = Hash(Key,H-&gt;TableSize);</span><br><span class="line">	<span class="comment">// 如果当前单元状态不为空，且数值不等，则一直做 </span></span><br><span class="line">	<span class="keyword">while</span>(H-&gt;Cells[NewPos].Info != Empty &amp;&amp; H-&gt;Cells[NewPos].Data != Key)&#123;</span><br><span class="line">		<span class="keyword">if</span>(++CNum % <span class="number">2</span> )&#123; <span class="comment">// 冲突奇数次发生 </span></span><br><span class="line">			NewPos = CurrentPos + (CNum+<span class="number">1</span>)/<span class="number">2</span>*(CNum+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			<span class="comment">// 如果越界，一直减直到再次进入边界 </span></span><br><span class="line">			<span class="keyword">while</span>(H-&gt;TableSize &lt;= NewPos)&#123;</span><br><span class="line">				NewPos -= H-&gt;TableSize; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;  <span class="comment">// 冲突偶数次发生 </span></span><br><span class="line">			NewPos = CurrentPos - CNum/<span class="number">2</span>*CNum/<span class="number">2</span>;</span><br><span class="line">			<span class="comment">// 如果越界，一直加直到再次进入边界 </span></span><br><span class="line">			<span class="keyword">while</span>(NewPos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				NewPos += H-&gt;TableSize; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> NewPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">( HashTable H,ElementType Key,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	Position Pos = i;</span><br><span class="line">	Pos = Find(H,Key);</span><br><span class="line">	<span class="comment">// 如果单元格状态不是"存在合法元素" </span></span><br><span class="line">	<span class="keyword">if</span>( H-&gt;Cells[Pos].Info != Legitimate)&#123;</span><br><span class="line">		H-&gt;Cells[Pos].Info = Legitimate;</span><br><span class="line">		H-&gt;Cells[Pos].Data = Key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 除留余数法哈希函数 </span></span><br><span class="line"><span class="function">Index <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> Key,<span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Key % TableSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;H-&gt;Cells[i].Data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	HashTable H = CreateTable(<span class="number">9</span>);</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">		Insert(H,tmp,i);</span><br><span class="line">	&#125;</span><br><span class="line">	output(H);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-分离链接法实现"><a href="#2-分离链接法实现" class="headerlink" title="2. 分离链接法实现"></a>2. 分离链接法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTABLESIZE 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>   <span class="comment">// 单链表 </span></span><br><span class="line">	ElementType Data;</span><br><span class="line">	PtrToLNode Next;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span> *<span class="title">HashTable</span>;</span>  <span class="comment">// 散列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TblNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> TableSize;   <span class="comment">// 表的最大长度 </span></span><br><span class="line">	List Heads;  <span class="comment">// 指向链表头结点的数组 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextPrime</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = (N%<span class="number">2</span>)?(N+<span class="number">2</span>):(N+<span class="number">1</span>);   <span class="comment">// 比 tablesize 大的奇数 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(p &lt;= MAXTABLESIZE)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p);i&gt;<span class="number">2</span>;i--)</span><br><span class="line">			<span class="keyword">if</span>(!(p%i))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">2</span>)  <span class="comment">// 找到素数了 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		p += <span class="number">2</span>; <span class="comment">// 下一个奇数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈希表 </span></span><br><span class="line"><span class="function">HashTable <span class="title">CreateTable</span><span class="params">( <span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">	HashTable H;</span><br><span class="line">	H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TblNode));</span><br><span class="line">	H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">	H-&gt;Heads = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TblNode) * H-&gt;TableSize);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++) </span><br><span class="line">		H-&gt;Heads[i].Next = <span class="literal">NULL</span>;  <span class="comment">// 链表头：H-&gt;Heads[i] 是不存东西的 </span></span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除留余数法哈希函数 </span></span><br><span class="line"><span class="function">Index <span class="title">Hash</span><span class="params">(	<span class="keyword">int</span> TableSize,ElementType Key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>  Key%TableSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(HashTable H,ElementType Key)</span></span>&#123;</span><br><span class="line">	Position p;</span><br><span class="line">	Index pos;</span><br><span class="line">	</span><br><span class="line">	pos = Hash(H-&gt;TableSize,Key); </span><br><span class="line">	p = H-&gt;Heads[pos].Next;  <span class="comment">//获得链表头 </span></span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; p-&gt;Data != Key)</span><br><span class="line">		p = p-&gt;Next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(HashTable H,ElementType Key)</span></span>&#123;</span><br><span class="line">	Position p,NewCell;</span><br><span class="line">	Index pos;</span><br><span class="line">	</span><br><span class="line">	p = Find(H,Key);</span><br><span class="line">	<span class="keyword">if</span>(!p)&#123;  <span class="comment">// 关键词未找到，可以插入 </span></span><br><span class="line">		NewCell = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">		NewCell-&gt;Data = Key;</span><br><span class="line">		pos = Hash(H-&gt;TableSize,Key);   <span class="comment">// 初始散列表地址</span></span><br><span class="line">		<span class="comment">// 将新增结点插到最前面</span></span><br><span class="line">		NewCell-&gt;Next = H-&gt;Heads[pos].Next;</span><br><span class="line">		H-&gt;Heads[pos].Next = NewCell;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">		List p = H-&gt;Heads[i].Next;  </span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;p-&gt;Data;</span><br><span class="line">			p = p-&gt;Next;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyTable</span><span class="params">(HashTable H)</span></span>&#123;</span><br><span class="line">	Position P,tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;H-&gt;TableSize;i++)&#123;</span><br><span class="line">		P = H-&gt;Heads[i].Next;</span><br><span class="line">		<span class="keyword">while</span>( P )&#123;</span><br><span class="line">			tmp = P-&gt;Next;</span><br><span class="line">			<span class="built_in">free</span>(P);</span><br><span class="line">			P = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(H-&gt;Heads);</span><br><span class="line">	<span class="built_in">free</span>(H);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	HashTable H = CreateTable(<span class="number">9</span>);</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">		Insert(H,tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	output(H);</span><br><span class="line">	DestroyTable(H);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Chenyang Min
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://perfectism13.github.io/2020/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%20%E7%AC%94%E8%AE%B0/" title="数据结构与算法 笔记">https://perfectism13.github.io/2020/08/17/数据结构与算法 笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/24/%E7%94%A8Keras%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%8A%A8%E4%BD%9C%E5%88%86%E7%B1%BB/" rel="prev" title="用Keras实现视频动作分类">
      <i class="fa fa-chevron-left"></i> 用Keras实现视频动作分类
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构与算法-笔记"><span class="nav-text">数据结构与算法 笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、数据结构"><span class="nav-text">一、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-其他定义"><span class="nav-text">1. 其他定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-解决问题方法的效率"><span class="nav-text">2. 解决问题方法的效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-最终定义"><span class="nav-text">3. 最终定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-抽象数据类型（Abstract-Data-Type）"><span class="nav-text">4. 抽象数据类型（Abstract Data Type）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、算法"><span class="nav-text">二、算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-描述算法的手段"><span class="nav-text">2. 描述算法的手段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-评价"><span class="nav-text">3. 评价</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-复杂度的渐进表示法"><span class="nav-text">4. 复杂度的渐进表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-复杂度分析小窍门"><span class="nav-text">5. 复杂度分析小窍门</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表"><span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是线性表"><span class="nav-text">1. 什么是线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线性表的抽象数据类型描述"><span class="nav-text">2. 线性表的抽象数据类型描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-线性表的顺序存储实现"><span class="nav-text">1. 线性表的顺序存储实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-线性表的链表存储实现"><span class="nav-text">2. 线性表的链表存储实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆栈"><span class="nav-text">堆栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是堆栈"><span class="nav-text">1. 什么是堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-堆栈的抽象数据类型描述"><span class="nav-text">2. 堆栈的抽象数据类型描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-栈的顺序存储实现"><span class="nav-text">1. 栈的顺序存储实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-栈的链表存储实现"><span class="nav-text">2. 栈的链表存储实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是队列"><span class="nav-text">1. 什么是队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-队列的抽象数据类型描述"><span class="nav-text">2. 队列的抽象数据类型描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-循环队列的顺序存储实现"><span class="nav-text">1. 循环队列的顺序存储实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-队列的链式存储实现"><span class="nav-text">2. 队列的链式存储实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-树的定义"><span class="nav-text">1. 树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-特征"><span class="nav-text">1. 特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-基本术语"><span class="nav-text">2. 基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-树的表示"><span class="nav-text">3. 树的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-儿子-兄弟表示法"><span class="nav-text">1. 儿子-兄弟表示法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-二叉树"><span class="nav-text">2. 二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-二叉树-1"><span class="nav-text">2. 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义-1"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-五种基本形态"><span class="nav-text">2. 五种基本形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-特殊形态"><span class="nav-text">3. 特殊形态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-重要性质"><span class="nav-text">4. 重要性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-抽象数据类型定义"><span class="nav-text">5. 抽象数据类型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-顺序存储结构"><span class="nav-text">1. 顺序存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-链表存储"><span class="nav-text">2. 链表存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的遍历"><span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-树的表示"><span class="nav-text">0. 树的表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-先序遍历"><span class="nav-text">1. 先序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-递归实现"><span class="nav-text">1.递归实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-非递归实现"><span class="nav-text">2. 非递归实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-中序遍历"><span class="nav-text">2.中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-递归实现-1"><span class="nav-text">1. 递归实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-非递归实现-1"><span class="nav-text">2. 非递归实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-后序遍历"><span class="nav-text">3. 后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-递归实现-2"><span class="nav-text">1. 递归实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-非递归实现-2"><span class="nav-text">2. 非递归实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-总结"><span class="nav-text">4. 总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-层序遍历"><span class="nav-text">5. 层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-例子"><span class="nav-text">6. 例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-输出叶子结点"><span class="nav-text">1. 输出叶子结点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-树的高度"><span class="nav-text">2. 树的高度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-由两种遍历序列确定二叉树"><span class="nav-text">3. 由两种遍历序列确定二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树"><span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义-2"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-特殊函数"><span class="nav-text">2. 特殊函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-查找"><span class="nav-text">1. 查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-查找最大和最小元素"><span class="nav-text">2. 查找最大和最小元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-删除"><span class="nav-text">3. 删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-代码实现"><span class="nav-text">4. 代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡二叉树"><span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-为何要使用AVL树？"><span class="nav-text">0. 为何要使用AVL树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义-3"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-平衡二叉树的调整"><span class="nav-text">2. 平衡二叉树的调整</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#0-遵循原则"><span class="nav-text">0. 遵循原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-RR-单旋"><span class="nav-text">1. RR 单旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-LL-单旋"><span class="nav-text">2. LL 单旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-LR-双旋"><span class="nav-text">3. LR 双旋</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-RL-双旋"><span class="nav-text">4. RL 双旋</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是堆"><span class="nav-text">1. 什么是堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-堆的抽象数据类型描述"><span class="nav-text">2. 堆的抽象数据类型描述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-插入"><span class="nav-text">1. 插入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-删除"><span class="nav-text">2. 删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-最小堆的建立"><span class="nav-text">3. 最小堆的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#0-注意"><span class="nav-text">0. 注意</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-插入建堆"><span class="nav-text">1. 插入建堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-调整建堆"><span class="nav-text">2. 调整建堆</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈夫曼树"><span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-定义-4"><span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-哈夫曼树的构造"><span class="nav-text">2. 哈夫曼树的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-哈夫曼树的特点"><span class="nav-text">3. 哈夫曼树的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-最小堆实现哈夫曼树"><span class="nav-text">4. 最小堆实现哈夫曼树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集"><span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组存储的基础实现"><span class="nav-text">1. 数组存储的基础实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-优化存储结构"><span class="nav-text">2. 优化存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-按秩归并优化-Union"><span class="nav-text">3. 按秩归并优化 Union</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-根据树高归并"><span class="nav-text">1. 根据树高归并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-根据规模归并"><span class="nav-text">2. 根据规模归并</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-路径压缩优化-Find"><span class="nav-text">4. 路径压缩优化 Find</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图"><span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的定义"><span class="nav-text">图的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是图"><span class="nav-text">1. 什么是图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-常见术语"><span class="nav-text">2. 常见术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-抽象数据类型定义"><span class="nav-text">3. 抽象数据类型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-邻接矩阵表示"><span class="nav-text">1. 邻接矩阵表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-邻接表表示"><span class="nav-text">2. 邻接表表示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历"><span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-DFS"><span class="nav-text">1. DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-BFS"><span class="nav-text">2. BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最短路径问题"><span class="nav-text">最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概述"><span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-抽象"><span class="nav-text">1. 抽象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-分类"><span class="nav-text">2. 分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-无权图的单源最短路算法"><span class="nav-text">2. 无权图的单源最短路算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-有权图的单源最短路算法"><span class="nav-text">3. 有权图的单源最短路算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dijkstra-算法"><span class="nav-text">Dijkstra 算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-多源最短路算法"><span class="nav-text">4. 多源最短路算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd-算法"><span class="nav-text">Floyd 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树问题"><span class="nav-text">最小生成树问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是最小生成树"><span class="nav-text">1. 什么是最小生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-贪心算法"><span class="nav-text">2. 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Prim-算法"><span class="nav-text">1. Prim 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Kruskal-算法"><span class="nav-text">2. Kruskal 算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列查找"><span class="nav-text">散列查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基本思想"><span class="nav-text">1. 基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-基本工作"><span class="nav-text">2. 基本工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-散列函数的构造"><span class="nav-text">3. 散列函数的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-考虑因素"><span class="nav-text">1. 考虑因素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数字关键词"><span class="nav-text">2. 数字关键词</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-直接定址法"><span class="nav-text">1. 直接定址法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-除留余数法"><span class="nav-text">2. 除留余数法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-数字分析法"><span class="nav-text">3. 数字分析法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-折叠法"><span class="nav-text">4. 折叠法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-平方取中法"><span class="nav-text">5. 平方取中法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-字符串关键字"><span class="nav-text">3. 字符串关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-ASCII码加和法"><span class="nav-text">1. ASCII码加和法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-前3个字符移位法"><span class="nav-text">2. 前3个字符移位法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-移位法"><span class="nav-text">3. 移位法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-冲突处理方法"><span class="nav-text">4. 冲突处理方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-常用策略"><span class="nav-text">1. 常用策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-开放定址法"><span class="nav-text">2. 开放定址法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线性探测"><span class="nav-text">1. 线性探测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-平方探测法"><span class="nav-text">2. 平方探测法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-双散列"><span class="nav-text">3. 双散列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-再散列"><span class="nav-text">4. 再散列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-分离链接法"><span class="nav-text">3. 分离链接法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-抽象数据类型定义-1"><span class="nav-text">5. 抽象数据类型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-平方探测法实现"><span class="nav-text">1. 平方探测法实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-分离链接法实现"><span class="nav-text">2. 分离链接法实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chenyang Min</p>
  <div class="site-description" itemprop="description">Computer Vision, Deep Learning</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenyang Min</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '809715bb1dc3b600fe38',
      clientSecret: '962bbbd3c02e9ff070497a47a3a7dc38e33d97f2',
      repo        : 'perfectism13.github.io',
      owner       : 'perfectism13',
      admin       : ['perfectism13'],
      id          : 'ad04e55e2d5d77c116574e743fac8375',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
